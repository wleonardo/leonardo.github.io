[{"title":"反思JavaScript: 通过函数代替break","date":"2017-01-27T11:05:17.000Z","path":"2017/01/27/rethinking-javascript-break-is-the-goto-of-loops/","text":"原文：https://hackernoon.com/rethinking-javascript-break-is-the-goto-of-loops-51b27b1c85f8#.k2oyppp5i 在我的上一篇文章 Death of the for Loop中，我试图去说服你放弃使用for 循环改用函数式的解决方案。反过来，你提出了一个很好的问题，那么for循环中break怎么办？ break 会相当于循环中的GOTO，我们应该避免使用。 break 应该像GOTO一样被废弃。 你可能会想“算了吧Joel，你这只是耸人听闻，break怎么可能会像GOTO一样？” 1// bad code. no copy paste. 1234567outer: for (var i in outerList) &#123;inner: for (var j in innerList) &#123; break outer; &#125; &#125; 我可以提供标记作为证明。在其他语言中，标记和GOTO是相互对应的。在JavaScript，标记与break和continue也是相互对应的。因为break和continue来自于相同标记组，这也导致了它们和GOTO很像。 JavaScript标签，break和continue是GOTO和非结构化编程时代的遗留 xkcd “但是如果它没有伤害任何人，那么我们为什么不把它留下语法中，而我们可以选择其他的方案？” 我们为什么限制我们如何编写软件?这个听上去有些违背直觉，但是限制是一个好事。限制我们使用GOTO就是一个很好的例子。我们也很欢迎限制我们的“use strict”，甚至批评不使用它的人。 “limitations can make things better. A lot better. “— Charles Scalfani 限制（规则）可以使我们写出更好的代码。 为什么编程需要限制_限制使艺术，设计，生活更美好._medium.com 我们对于break的选择是什么?我不是要做一个虚有其表的事情，但是也没有一个方案可以适合所有的情况。 这是一个完全不同的编程方式。 一个完全不同的思考方式。函数式编程的思想。 有一个好消息是，有很多的库和工具可以帮助我们，例如Lodash, Ramda, lazy.js, 递归等等 我们将从一个简单的cats集合和一个isKitten函数开始，这些将在下面所有的例子中被用到。 123456const cats = [ &#123; name: &apos;Mojo&apos;, months: 84 &#125;, &#123; name: &apos;Mao-Mao&apos;, months: 34 &#125;, &#123; name: &apos;Waffles&apos;, months: 4 &#125;, &#123; name: &apos;Pickles&apos;, months: 6 &#125;] 1const isKitten = cat =&gt; cat.months &lt; 7 让我们从一个我们熟悉的for循环的例子开始。它会遍历我们的cats，然后当找到第一只小猫的时候退出循环。 1var firstKitten 123456for (var i = 0; i &lt; cats.length; i++) &#123; if (isKitten(cats[i])) &#123; firstKitten = cats[i] break &#125;&#125; 现在，让我们和lodash中一个相同作用的例子做比较。 1const firstKitten = _.find(cats, isKitten) 这个例子相当的简单。接下来让我们尝试一些边缘情况吧。现在我们改为遍历cat集合，然后选出前5只小猫，然后退出循环。 1var first5Kittens = [] 1234// old-school edge case kitty loopfor (var i = 0; i &lt; cats.length; i++) &#123; if (isKitten(cats[i])) &#123; first5Kittens.push(cats[i]) 12345 if (first4Kittens.length &gt;= 5) &#123; break &#125; &#125;&#125; 简单的方式lodash是一个很好的库也可以坐很多的事情，但是有时候你需要一些其他更加专业的工具。这里我们介绍一个新朋友, lazy.js. “像Underscore，但是更加偷懒”。但是偷懒就是我们想要的. 123const result = Lazy(cats) .filter(isKitten) .take(5) 困难的方法库都是有趣的，但是有时候真正有趣的是从头开始创造东西。 所以我们可以创建一个通用的函数，让它可以像filter一样使用也可以增加限制的功能。 第一步就是把我们上面写的边缘情况的for循环封装在一个函数中。 接下来，让我们是这个函数更加通用并且遍历所有cat具体的内容。使用limit来代替5,predicate来代替isKitten，list来代替cats。然后把这些作为函数的参数。 现在我们有了一个可用的且可重复的takeFirst函数，这个可以让我们完全不用去关心我们cat的逻辑实现！ 我们的函数现在依旧还是一个纯函数。也就是说函数的输出只和输入的参数有关。如果传入相同的参数，一定会得到相同的结果。 现在我们已经还是有那个肮脏的for循环，所以让我们继续重构。下一步就是把i和newList放入参数列表。 当limit变为0的时候 (limit会在递归过程中减少)或者是遍历完了列表，我们希望可以退出递归(isDone)。 如果递归还在进行，我们将会核对是否有符合我们的过滤条件predicate的值。如果当前值符合过滤条件，我们会调用takeFirst，减少limit并把当前值保存在我们的newList中，否者，移动到列表的下一个值。 如果你还没有看过Rethinking JavaScript: The if statement，它会解释这个用三元表达式代替if‘的最后一步。 Rethinking JavaScript: The if statement_Thinking functionally has opened my mind about programming._medium.com 现在我们像下面这样调用我们的新方法： 1const first5Kittens = takeFirst(5, isKitten, cats) 为了兼容更多的情况，我们可以柯里化takeFirst，然后使用它去创建一些其他的函数（关于柯里化的介绍在另一篇文章中） 12const first5 = takeFirst(5)const getFirst5Kittens = first5(isKitten) 1const first5Kittens = getFirst5Kittens(cats) 总结现在有很多优秀的库例如 lodash, ramda和lazy.js供我们使用。但是如果我们足够大胆，也可以使用递归来创建我们自己的函方法。 我必须要警告虽然takeFirst看上去很酷 但是使用递归是有得也有失的. 递归在Javascript中是很危险的，它很容易就会导致超出最大调用堆栈大小的报错。 我将会在我的下一篇文章中重写JavaScript的递归。敬请关注。 我知道这只是一件小事，但是当我收到来自Medium和Twitter (@joelnet)的follow通知时会使我很开心。当然，如果你觉得我实在胡说八道，你也可以在下面的讨论区告诉我。 Cheers!","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Node学习之路：require()工作原理","date":"2017-01-27T07:23:25.000Z","path":"2017/01/27/how-require-actually-works/","text":"原文：http://thenodeway.io/posts/how-require-actually-works/ 介绍 Node学习之路 掌握的基本知识 理解回调函数中的错误优先 测试要点 进阶 单例模式 设计自定义类型 工厂模式 高级 require() 工作原理 危险的模块设计模式 几乎所有的Node.js开发者都可以说出require()的作用，但是又有多少人真正知道require()是如何工作的呢。我们几乎每天都会使用它去加载库和模块，但是它的原理还是一个谜。 因为好奇，我查看了Node的核心源码去寻找答案。但是我不是找到了一个函数，而是找到了Node的核心模块:module.js。这个文件惊人的强大，它包含了文件的加载，编译，并且可以缓存所有使用过的文件。对外使用的require()只是冰山一角。 module.js12345function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; // ... module.js里的模块类型在Node.js中有两个主要的作用。第一，它为所有的Node.js模块提供了一个函数用于编译。每一个文件在这个基础模块中运行后都会返回一个新的实例，即使这个文件运行了也还是会存在。这就是为什么我们可以随时使用 module.exports并且可以返回它。 这个模块的第二个主要的作用就是管理Node模块加载机制。这个独立的require函数其实是module.require的一个引用，而module.require只是一个把Module._load简单包裹了一下（wapper）。这个函数才是真正控制文件的加载的，接下来我们通过这个函数继续我们的探索。 Module._load12345678Module._load = function(request, parent, isMain) &#123; // 1\\. 检查 Module._cache 是否有缓存 // 2\\. 如果没有缓存则创建一个新的模块实例 // 3\\. 将模块实例保存到缓存中 // 4\\. 通过给予的filename去调用module.load()，然后调用module.compile()去读取文件内容 // 5\\. 如果文件的载入和解析过程中发生错误，删除缓存中的该模块 // 6\\. 返回 module.exports&#125;; Module._load是一个负责新模块的加载和管理模块缓存的函数。缓存所有加载过的模块可以减少文件的重复加载并且明显地加快你的应用。此外，共享模块的实例可以把模块像单例来使用，可以在整个项目的运行中都可以保存它的状态。 如果一个模块不存在在缓存中，Module._load 会为这个文件创建一个新的基础模块。Module._load会通知模块去读取新的文件的内容，然后把内容送到module._compile。[1] 如果你看了上面的#6，那么你就会看到module.exports会被返回给用户。这就是为什么你可以通过exports和module.exports创建一个对外的公共接口，而这些就是Module._load做的事情，然后通过require返回出去。我很惊讶于除此之外没有其他的神奇的地方了，但是没有什么比它更加简洁更加好的了。 module._compile123456Module.prototype._compile = function(content, filename) &#123; // 1\\. 创建一个独立的require函数，该函数可以调用module.require。 // 2\\. 给require加上其他帮助性的函数Attach other helper methods to require. // 3\\. 将代码包裹在一个函数中，并提供了require，module等变量在模块作用域中。 // 4\\. 运行这个函数&#125;; 这里就是见证奇迹的地方。第一，一个特殊的单独的require函数被创造用于这个模块。这个require函数就是我们最熟悉的那个函数。这个函数只是把 Module.require包裹了一下，它也包含了一些鲜为人知的帮助性的属性和方法供我们使用： require(): 加载一个外部模块 require.resolve(): 通过解析一个模块绝对路径来生成模块的name require.main: 主要模块 require.cache: 所有模块的缓存 require.extensions: 每一个有效文件的编译函数都是基于这个来做扩展 一旦require完成了，整个加载好的源码会被包裹在一个新的函数里面，同时传入require, module, exports和其对外的变量作为新函数的参数。这样就创造了一个新的函数作用域，这样可以避免污染Node的全局环境。 123(function (exports, require, module, __filename, __dirname) &#123; // 你的代码会被放在这里&#125;); 最后，这个包含了模块的函数会被运行。整个Module._compile方法的执行时同步的，所以Module._load会等待Module._compile执行完，然后会返回module.exports给用户。 结论至此，我们已经看完了require的代码，通过这一圈的代码就创造出了我们一开始想要去了解的那个require 函数。 如果你了解了上面所有的内容，那么你将会了解到require(&#39;module&#39;)最后的秘密。没错，就是模块系统本身也可以通过模块系统加载进来的。一开始，这个可能听上去有些奇怪，但是这样可以让用户不用了解Node.js的核心原理就可以使用加载系统加载自己的模块。流行的模块例如mockery and rewire就是这样构建的。 如果你想了解更多的细节，你可以浏览module.js源码。你会得到更多的信息也会了解的更多，我将会给第一个回答出什么是‘NODE_MODULE_CONTEXTS’并且为什么要加上这个的人加分。 [1] module._compile函数只是用于运行JavaScript文件。JSON文件会简单地通过 JSON.parse()解析然后返回。 [2] 当然这些模块都是由一些私有的函数方法构建的，例如Module._resolveLookupPaths and Module._findPath。你可以想一想是否可以有更好的办法… 请开启你的Javascript然后浏览 comments powered by Disqus.","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"10 个技巧，让你在2017 年成为更好的 Node 开发者","date":"2017-01-27T07:22:17.000Z","path":"2017/01/27/10-tips-to-become-a-better-node-developer/","text":"本文是由我们的客座作者Azat Mardan写的。SitePoint引入客座帖子的目的是希望能给你带来web社区里著名作者和演讲者的有趣内容。 在2012年，我加入了Storify并开始使用Node作为我的主要语言。从那以后，我从未回首过去并觉得我错过了Python，Ruby，Java以及PHP，这些在过去10年里，我在web开发过程中使用的语言。 Storify提供给我一个很有趣的工作，因为Storify和其他的公司不太一样，Storify之前（可能到现在也是）所有的代码都是由JavaScript编写的。而大多数公司，特别是大公司，例如PayPal，Walmart(沃尔玛)或者Capital One(第一资本)，只是在某一些特定的部分使用了Node。通常，他们使用Node作为API接口或者用在业务流程层，这样做是很好的。但是作为一个软件工程师，没什么比得上能够完全沉浸在Node环境里。 下面我将列出10条建议，这些建议可以帮助你在2017年成为一个更好的Node开发者。其中一些建议是我在日常实践中所学到的，另一些是从那些写了最流行的Node和npm模块的人们身上学到的。 下面是我们将要介绍的内容： 避免复杂性 — 尽可能将你的代码块拆到最小，要小到极致。 使用异步编程 — 像躲避瘟疫般避免使用同步代码。 避免require阻塞 — 把你所有的require声明都放在文件的顶部，因为require是同步的，会阻塞代码运行。 了解require缓存 — 了解它则可以利用它，否则它可能会带来bug。 始终检查错误 — 错误不是足球，任何时候都不要抛出错误或者跳过错误检查。 只在同步代码中使用try…catch — 在异步代码中try...catch是没有作用的。V8引擎针对try...catch无法进行优化。 返回callbacks或者使用if … else — 返回一个callback只是为了确保不继续执行。 监听错误事件 — 几乎所有的Node的类/对象都有event emitter(观察者模式)并且会广播error事件，确保你监听了它们。 了解你的npm — 使用-S或者-D来安装模块来代替--save或者–save-dev`。 在package.json中使用精确的版本号: npm在使用-S来安装模块时会自动使用默认的版本号，你需要手动修改去锁定版本号。除非是开源模块，否者不要相信你的项目中的SemVer（语义化版本标准）。 加分 — 使用不同的依赖。把项目在开发阶段需要的东西放在 devDependencies 中，记得使用 npm i –production。多余的依赖越多，出现问题的风险就越大。 好的，接下来让我们一个个单独地去了解上面的每一点。 避免复杂性让我看一眼npm的创造者Isaac Z. Schlueter写的一些模块，例如，use-strict，这个模块是用来在Javascript中强制使用严格模式，这个模块仅仅只有三行代码： 123var module = require(&apos;module&apos;)module.wrapper[0] += &apos;&quot;use strict&quot;;&apos;Object.freeze(module.wrap) 所以我们为什么要避免复杂性呢? 一个起源于美国海军的著名短语:KEEP IT SIMPLE STUPID(或者是“Keep it simple, stupid”)。这就是原因。事实说明，人类大脑在任何一个时间只能在其工作记忆中保持五到七个项目。 把你的代码模块化成一个更加小的部分，你和其他的开发者会更加好的理解它。你也可以更加好的去测试它。如下例子， 1234567app.use(function(req, res, next) &#123; if (req.session.admin === true) return next() else return next(new Error(&apos;Not authorized&apos;))&#125;, function(req, res, next) &#123; req.db = db next()&#125;) 或者是 1234const auth = require(&apos;./middleware/auth.js&apos;)const db = require(&apos;./middleware/db.js&apos;)(db)app.use(auth, db) 我相信大多数人都会喜欢第二个例子，特别是光看名字就能了解其作用。当日，在你编写代码的时候，你可能认为你知道代码是如何运行的。甚至你想要展示你把几个功能连接在一起写在同一行中是多么的机智。但是，这样你是写了一段愚蠢的代码。如果你思考的很复杂去写这代码，那么今后你再去看这段代码将会很难去理解。保证你的代码简单，特别是在Node的异步代码中。 当然也会有left-pad 事件，但是其实它只是影响了依赖于left-pad模块的项目而且11分钟后就发布了替代品。代码的最小化带来的好处超过了它的缺点。npm已经改变了发布策略,任何重要的项目都应该使用缓存或私有的源（作为临时解决方案）。 使用异步编程在Node中同步代码只要很小的一部分。这些代码大多数都是用于命令行工具或者其他与web应用无关的脚本。Node开发者大多数都是编写web应用，因此使用异步代码可以避免阻塞现场。 例如，当你在编写一个数据库的脚本或者是一个不需要控制并行的任务时，下面这种写法可能是可以的： 1234let data = fs.readFileSync(&apos;./acconts.json&apos;)db.collection(&apos;accounts&apos;).insert(data, (results))=&gt;&#123; fs.writeFileSync(&apos;./accountIDs.json&apos;, results, ()=&gt;&#123;process.exit(1)&#125;)&#125;) 但是当你创建一个web应用时，下面这个写法会更好： 1234567app.use(&apos;/seed/:name&apos;, (req, res) =&gt; &#123; let data = fs.readFile(`./$&#123;req.params.name&#125;.json`, ()=&gt;&#123; db.collection(req.params.name).insert(data, (results))=&gt;&#123; fs.writeFile(`./$&#123;req.params.name&#125;IDs.json`, results, ()=&#123;res.status(201).send()&#125;) &#125;) &#125;)&#125;) 这个区别在于你是否需要编写一个并发（通常是长期运行）或者非并发（短期运行）的系统。根据经验来说，总是要在Node中使用异步代码。 避免require阻塞Node有一个使用了CommonJS模块格式的简单的模块加载系统。它是基于require函数，require函数可以很方便的在不同的文件中引入模块。和AMD/requirejs不同，Node/CommonJS的模块加载时同步的。require的工作方式是：引入一个模块或者一个文件export的内容: 1`const react = require(&apos;react&apos;)` 但是大多数的开发者并不知道require是会被缓存的。因此，只要解析的文件名（resolved filename）没有剧烈的变化（比如npm模块不存在的情况），模块的代码只会被执行并存入变量中一次（在当前进程中）。这是一个很好的优化。当然，即使有了缓存，你最好还是把你的require声明写在开头。下面这段代码，它在路由中真正使用到了axios模块的时候才加载。当请求发送的时候/connect会因为需要加载模块所以会变得慢。 12345app.post(&apos;/connect&apos;, (req, res) =&gt; &#123; const axios = require(&apos;axios&apos;) axios.post(&apos;/api/authorize&apos;, req.body.auth) .then((response)=&gt;res.send(response))&#125;) 一个更好，性能更优的方式是在服务定义之前就引入模块而不是在路由中: 1234567const axios = require(&apos;axios&apos;)const express = require(&apos;express&apos;)app = express()app.post(&apos;/connect&apos;, (req, res) =&gt; &#123; axios.post(&apos;/api/authorize&apos;, req.body.auth) .then((response)=&gt;res.send(response))&#125;) 知道require会被缓存我在上面一节已经提到了require会被缓存，但是有趣的是我们在module.exports之外也会有代码。举例来说： 12345console.log(&apos;I will not be cached and only run once, the first time&apos;)module.exports = () =&gt; &#123; console.log(&apos;I will be cached and will run every time this module is invoked&apos;)&#125; 从中我们了解到有一些代码只会运行一次，你可以使用这个特性来优化你的代码。 始终检查错误Node不是Java。在Java中，你可以抛出错误，因为如果发生了错误那么你会希望应用不在继续执行。在Java中，你可以在外层仅仅使用一个简单的try...catch就可以处理多个错误。 但是在Node中并不是这样的。自从Node使用了事件循环和异步执行后，任何的错误发生时都会与错误处理器（例如try...catch）的上下文分离，下面这样做在Node中是没有用的： 12345678try &#123; request.get(&apos;/accounts&apos;, (error, response)=&gt;&#123; data = JSON.parse(response) &#125;)&#125; catch(error) &#123; // Will NOT be called console.error(error)&#125; 但是try...catch在同步代码中是可以被用的。前面的代码片段可以被更好的重构为： 12345678request.get(&apos;/accounts&apos;, (error, response)=&gt;&#123; try &#123; data = JSON.parse(response) &#125; catch(error) &#123; // Will be called console.error(error) &#125;&#125;) 如果我们无法将request的返回内容包裹在try...catch中，那么我们将没有办法去处理请求的错误。Node的开发者通过在返回的参数里面加上error来解决了这个问题。因此，我们需要在每一个回调中手动去处理错误。你可以去检查这些错误（判断error不是null）,然后展示错误信息给用户或者展示在客户端上并且记录它， 或者你可以通过调用 callback ，给它传 error 参数，将错误传回给上一级调用栈（如果你在调用栈之上有另一个回调函数）。 12345678request.get(&apos;/accounts&apos;, (error, response)=&gt;&#123; if (error) return console.error(error) try &#123; data = JSON.parse(response) &#125; catch(error) &#123; console.error(error) &#125;&#125;) 一个小技巧是你可以使用okay库。你可以像下面的例子一样使用它去避免在回调地狱中手动去检查错误(你好, 回调地狱). 123456789var ok = require(&apos;okay&apos;)request.get(&apos;/accounts&apos;, ok(console.error, (response)=&gt;&#123; try &#123; data = JSON.parse(response) &#125; catch(error) &#123; console.error(error) &#125;&#125;)) 返回回调或者使用if … elseNode是并行的。但是如果你不够细心也会因为这个特性产生bug。 为了安全起见，应该要使用return来终止代码的继续执行： 123let error = trueif (error) return callback(error)console.log(&apos;I will never run - good.&apos;) 这样可以避免一些因为代码逻辑的处理不当导致一些不应该执行的内容（或者错误）被执行。 123let error = trueif (error) callback(error)console.log(&apos;I will run. Not good!&apos;) 请确保使用return去阻止代码的继续执行。 监听 error 事件Node中几乎所有的类/对象都有事件分发器（观察者模式）并且会广播 error 事件。 这是一个很好的特性，可以使开发者在这些讨厌的错误造成巨大后果之前捕捉到它们。 养成一个通过.on()来创建error事件监听的好习惯： 123456789101112var req = http.request(options, (res) =&gt; &#123; if ((&apos;&apos; + res.statusCode).match(/^2\\d\\d$/)) &#123; // Success, process response &#125; else if ((&apos;&apos; + res.statusCode).match(/^5\\d\\d$/)) // Server error, not the same as req error. Req was ok. &#125;&#125;)req.on(&apos;error&apos;, (error) =&gt; &#123; // Can&apos;t even make a request: general error, e.g. ECONNRESET, ECONNREFUSED, HPE_INVALID_VERSION console.log(error)&#125;) 了解你的npm很多的Node和前端的开发者知道在安装模块的时候使用--save会在安装模块的同时，会在package.json保存一条含有模块版本信息的条目。当然，还有--save-dev可以用于安装devDependencies(在生成环境中不需要的模块)。但是你知道用-S和-D是否可以代替--save 和--save-dev么？答案是可以的。 当你安装模块的时候，你需要删除-S和-D自动为你模块的版本号添加的^标签。否者当你使用npm install（或者npm i）安装模块的时候，就会自动拉取最新的镜像（版本号的第二位数字）。例如v6.1.0就是v6.2.0的一个镜像分支。 npm团队推荐使用semver，但是你最好不要这样。npm团队认为开源开发者会遵守semver所以他们在npm安装时自动加上了^。没有人可以去保证，所以最好是锁定你的版本号。更好的办法是使用shrinkwrap：npm shrinkwrap会生成一个包含依赖的具体版本的文件。 结束语这篇文章是两部分的第一部分，我们已经提到了很多方面，从使用callbacks和异步代码，到核查错误和锁定依赖。希望你们可以从中学习到一些新的，或者有用的信息。敬请期待即将推出的第二部分。 同时，告诉我你的想法。我是否遗漏了什么？你是否有不一样的做法？在下面的评论区告诉我你的想法吧。","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"new到底做了什么","date":"2017-01-27T07:20:49.000Z","path":"2017/01/27/new-working/","text":"在Javscript中，我们实例化一个类的时候都会使用类似的代码 1var coder = new Man() 那么在new的时候，new到底做了什么呢，其实很简单，new的作用，就是先创建一个空对象，然后将新对象的proto链接到类的prototype，最后通过将新对象作为上下文（this），调用call来执行类的构造函数。实现代码如下 123var coder = &#123;&#125;;coder.__proto__ = Man.prototypeMan.call(coder) 具体可以查看MDN的文档new运算符","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"开发推荐 mac中好用的软件","date":"2017-01-27T07:19:30.000Z","path":"2017/01/27/mac-software/","text":"这里只是我个人用到的一些比较好用的软件，本人是前端开发，所以偏前端的软件可能多一些，不喜勿喷哦，也希望大家可以推荐好的软件给我。 sublime不知道该从哪个软件开始写起，后来一想还是从自己最常用的软件开始吧 sublime作为一个轻量级的ide，性能很优秀，基本什么配置的电脑都可以流畅使用，随着sublime2到sublime3，不管你需要什么样的插件都可以找的到。 Parallers Desktop 个人认为mac上最好的虚拟机，没有之一。第一次使用Parallers的融合模式，确实是惊艳到我了，虚拟机居然可以这种地步，一直以为虚拟机就是在一个窗口中，然后在这个窗口内使用。Parallers可以使你使用其他平台的软件像是在使用mac上软件，唯一的问题就是window上的广告和通知也显示在mac上了，感觉怪怪的,另外Parallers现在好像都要收费了，而且还挺贵的，不过确实物超所值。 Dash开发往往会遇到很多的类库，用到的时候总会需要查询一些文档，一个个去找太麻烦了，dash可以把文档下载下来，而且可以很方便的查询文档，而且dash可以和大多数ide对接，只需要选中你想要查询的函数，加上快捷键就可以直接在dash中查询到对应函数的说明，可以提交开发的效率。另外网路不好的情况下，离线的文档有时候可以帮你解决很多问题。 *","tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/软件/"}]},{"title":"class in ES6","date":"2017-01-27T07:18:42.000Z","path":"2017/01/27/class-in-ES6/","text":"在es6出来之后，我们看到js终于有class这个关键字，表示我们终于可以使用官方的类了。那么es6的类和之前的我们使用原型链继承实现的类有什么联系么。 答案是一模一样 JavaScript classes introduced in ECMAScript 2015 are syntactical sugar over JavaScript’s existing prototype-based inheritance. (在 ECMAScript 6 引入的 JavaScript 类（class）是 JavaScript 现有的原型继承的语法糖。) —— MDN Classes 好吧，那么为了使我们更好的理解es6的class，也是倒过来更好的理解js的原型链，下面我们把类的es6写法和原型链实现的写法一一列出 ###类的创建，类的构造器和原型方法ES61234567891011121314class Polygon &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125; calcArea() &#123; return this.height * this.width; &#125;&#125;const square = new Polygon(10, 10);// 100console.log(square.area); 原型链12345678var Polygon = function(height, width)&#123; this.height = height; this.width = width;&#125;Polygon.prototype.calcArea = function() &#123; return this.height * this.width;&#125; ###类的静态方法static关键字用来定义类的静态方法。静态方法是指那些不需要对类进行实例化)，使用类名就可以直接访问的方法，需要注意的是静态方法不能被实例化的对象调用。静态方法经常用来作为工具函数。ES6123456789101112131415161718class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; static distance(a, b) &#123; const dx = a.x - b.x; const dy = a.y - b.y; return Math.sqrt(dx*dx + dy*dy); &#125;&#125;const p1 = new Point(5, 5);const p2 = new Point(10, 10);console.log(Point.distance(p1, p2)); 原型链1234567891011var Point = function(x, y)&#123; this.x = x; this.y = y;&#125;Point.distance = function(a, b) &#123; const dx = a.x - b.x; const dy = a.y - b.y; return Math.sqrt(dx*dx + dy*dy);&#125; 至此我们也可以明白了如何用原型链去构建一个类 其实当我们去查看babel对于类的实现，其实也是一样的 123456789101112131415161718var _createClass = function() &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function(Constructor, protoProps, staticProps) &#123; //实例方法（原型方法）的实现 if (protoProps) defineProperties(Constructor.prototype, protoProps); //静态函数的实现 if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;(); ###类的继承 未完 参考文档Javascript原型链MDN Classes","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"semver","date":"2017-01-27T07:17:50.000Z","path":"2017/01/27/semver/","text":"semver规则","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"node-js-best-practices-how-to-become-a-better-developer-in-2017","date":"2017-01-27T07:16:45.000Z","path":"2017/01/27/node-js-best-practices-how-to-become-a-better-developer-in-2017/","text":"一年前，我们写了一篇文章How to Become a Better Node.js Developer in 2016 ，这篇文章成功地获取了不错的反响，所以我想现在是时候回顾这个主题为2017年做准备了。 ###2017年最好的Node.js实践 使用ES2015去年我们建议了你使用ES2015，当前现在的情况已经大有不同了 回到那个时候，Node.js v4是当时的稳定版本(LTS)，支持了ES2015中57%的功能。一年过去了，现在Node v6已经增长到支持ES2015中99%的功能了。 如果你现在在使用最新的LTS Node.js版本，你甚至可以不再需要babel就可以使用所有ES2015的特性。但是即使如此，在浏览器端你可能还是需要babel。 如果你需要关于Node.js版本对于ES2015支持情况的更多的信息，我推荐你可以查询node.green ####使用Promises 在80年代第一次提出Promises的概念。现在多数现代编程语言已经支持这一特性了，使我们的编码变得更加简单。 想象一个如下的功能，它需要读取一个文件，然后解析它，然后打印出其中的name字段。如果使用回调，它可能是下面这个样子的： 123456789101112fs.readFile(&apos;./package.json&apos;, &apos;utf-8&apos;, function (err, data) &#123; if (err) &#123; return console.log(err) &#125; try &#123; JSON.parse(data) &#125; catch (ex) &#123; return console.log(ex) &#125; console.log(data.name)&#125;) Promises可以使得这段代码变的更加有可读性：123456fs.readFileAsync(&apos;./package.json&apos;).then(JSON.parse).then((data) =&gt; &#123; console.log(data.name)&#125;).catch((e) =&gt; &#123; console.error(&apos;error reading/parsing file&apos;, e)&#125;) 当前，现在的fs的并没有一个返回一个Promise的readFileAsyncapi。为了做到这个，我们使用可以一个类似promisifyAll的模块。 ####使用标准的JavaScript格式 当我们谈到代码风格的时候，一个公司有统一的代码风格是至关重要的。只有这样，当你需要改变你的项目的时候，你才可以高效的从零开始，而不用担心基础的架构不一样。 在RisingStack，我们在所有的项目中都使用了JavaScript Standard Style。 使用 Standard后，在你安装之后就可以直接使用，你不需要再做其他的事情，也不需要管理.eslintrc, .jshintrc, 或者 .jscsrc文件。具体的Standard的规则可以查看Standard rules。 ###使用docker—容器将在2017年被大量使用在生成环境 你可以把docker镜像当做部署的工具。docker容器可以将一个软件打包在一个完整的文件系统中，这个容器可以包含你在服务器上需要的一切，例如代码，运行环境，系统工具，系统程序库。 但是为什么我们需要开始使用容器呢? 容器可以使你的应用运行在一个隔离的环境中 作为一个安全工具，可以使你的代码更加的安全 轻量级的docker镜像 使得你的部署变得稳定 你可以在本地运行模拟线上的运行环境 你可以从official getting started tutorial开始学习docker。另外也推荐Kubernetes best practices ####监控你的项目 当你的应用发生错误的时候，第一个知道的人不应该是用户而应该是开发者。 最新的一个开源解决方案Prometheus可以帮助你实现项目的监控。Prometheus是一个基于SoundCloud的开源工具箱，它可以监控你的项目并报警。Prometheus唯一的缺点是你需要设置一些配置并且需要需要自己管理。 如果你在寻找一个开箱即用的解决方案，你也可以使用我们自己开发的Trace by RisingStack Trace可以帮助你做到以下的事情 报警 生产环境下的内存和cpu分析 分布式追踪和错误寻找 性能监控 保护你的npm包的安全 ####在后台进程中使用消息服务 如果你使用http请求发送消息，当你的接收服务器宕机了，你所有的消息都会丢失。如果你的传输层支持持久化，类似使用消息队列来发送消息，你就不会有这个问题。 你的接收服务器器宕机了，消息将会被保存下来，在服务重启后会继续发送，如果你的服务器未宕机但是发送了错误，消息会被重新发送一次，这样可以保证你的数据不会丢失。 举个例子：你需要发送数千份邮件，在这个场景下，你只需要获取到一些类似邮件地址和用户的姓名等基础信息，后台就可以很轻松地将这些信息和邮件信息整合后发送出去。 这种方式最大的好处是，你可以你需要的时候横向扩展你的服务，而不会有邮件被丢失。如果你需要发送数百万的邮件，你可以用相同的方式来增加你的服务。 对于消息队列的选择有很多 RabbitMQ Kafka NSQ AWS SQS ####使用最新的LTS版本的Node.js 为了平衡稳定性和新特性，我推荐你使用最新的LTS版本的Node.js。当我写这篇文章的时候，最新的LTS版本是6.9.2。 你可以使用nvm来切换你的node版本，你只需要两个指令就可管理和切换你的node版本 12nvm install 6.9.2 nvm use 6.9.2 ####使用语义化的版本管理 几个月前，我们进行了一个Node.js开发者调查，我们从中获取了开发者对于使用语义化版本的使用情况。 不幸的是，我们发现调查者只有71%的人在他们提交和使用模块时使用语义化的版本管理。我们认为这个数字应该要更高 - 每一个都应该使用语义版本!，因为不根据semver规则来提交package，会很容易摧毁你的Node.js应用。 通过版本号来管你的项目或者模块是至关重要的。你的用户应该要知道一个模块是否更新了，在使用新版本前他们要做什么。 这就是语义版本控制的来历。一个版本号应该要有主版本号、副版本号、补丁版本号，更新不同位置的版本号代表不同的意思： 主版本号:表示更新会有不兼容的API 副版本号:表示更新会有新的功能（不破坏现有的api） 补丁版本号:表示更新是模块做了向后兼容的bug修复 npm是根据semver规则来安装依赖的，因此当你发布一个模块之前，请确认是否遵循了semver规则，否则你会破坏了其他使用了你的依赖的应用。 ####保证你的应用安全 保证你的用户数据的安全将是你2017年的头等大事。仅在2016年一年，因为缺少一些安全的措施就有数百万的用户账户被泄漏。 你可以通过阅读我们的博客Node.js Security Checklist来入门Node.js的安全，博客里包含了以下的话题： 安全的HTTP Headers 强制保护 Session管理 不安全的依赖 数据验证 当你掌握了这些基础，你可以来观看我关于Node的互动讨论Surviving Web Security with Node.js 学习ServerlessServerless started with the introduction of AWS Lambda. Since then it is growing fast, with a blooming open-source community.In the next years, serverless will become a major factor for building new applications. If you’d like to stay on the edge, you should start learning it today.One of the most popular solutions is the , which helps in deploying AWS Lambda functions. Serverless是AWS Lambda第一个提出来的，之后它发展的很快，并建立了一个开源的社区。 接下来的一年，构建新应用时serverless会成为一个标准。如果你想要留在这个领域，你需要重现在开始就学习它。 Serverless Framework是当前最流行的解决方案，在部署AWS Lambda functions可以帮助你。 ####参加会议与聚会并发言 参加会议和聚会是一个很好地方式去了解和学习新的趋势，开发技巧和最佳实践。当日，这也是一个场合去认识更多新的人。 To take it one step forward, I’d like to encourage you to speak at one of these events as well!As public speaking is tough, and “imagine everyone’s naked” is the worst advice, I’d recommend checking out speaking.io for tips on public speaking! 在此基础上，我也鼓励你在一些会议上发言。 在公共场合发言是一个不容易的事情，“imagine everyone’s naked”是最坏的建议。我建议你可以去speaking.io学习一些技巧。 ####Become a better Node.js developer in 2017 原文链接","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Closures","date":"2017-01-27T07:16:02.000Z","path":"2017/01/27/Closures/","text":"Closures are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions ‘remember’ the environment in which they were created. — MDN 看不懂上面的英文这么办，下面是中文翻译 闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。 关于闭包已经有很多很多的文章了，文章的最后会放一些链接，在这里我只写以下几点 闭包的实现是因为Js中有函数作用域，变量查询是一级一级查询上去，直到根作用域也就是说在任何一级的作用域中都可以访问之前所有作用域连的变量，同时内存回收机制是不会回收还被引用的变量。 闭包不是实现Js类的基础，但是可以通过闭包实现类的私有变量和私有函数 闭包的性能很差，有时候可以绑定在prototype中（只可以访问this下的变量） 123456789101112131415161718//在这个例子中firstName和LastName不想直接被外界访问，同时可以使用闭包使外界获取到值，//同时函数尽量绑定在prototype上，所以getFullName绑定在prototype上，//所以我个人认为在这样的情况下，一些用于访问私有变量的基础函数可以使用闭包，//大多数类函数可以绑定在prototype中，通过可以访问私有变量的基础函数来实现访问私有变量var Man = function()&#123; var firstName = &apos;wang&apos;; var LastName = &apos;yuekai&apos;; this.getFirstName = function()&#123; return firstName; &#125; this.getLastName = function()&#123; return LastName; &#125;&#125;Man.prototype.getFullName = function()&#123; return this.getFirstName() + this.getLastName()&#125; 其他文献学习Javascript闭包（Closure）闭包","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Javascript原型链","date":"2017-01-27T07:15:21.000Z","path":"2017/01/27/prototype-chain/","text":"原型链的继承就是将子类的prototype.__proto__链接到父类的prototype，借此完成原型链1child.prototype.__proto__.= parent.prototype 实例化的对象没有prototype,prototype是函数特有的属性，所有的对象都有__proto__, 这是指向实例化这个对象的类的prototype,所有对象的原型链最后是null 下面是经典的原型链继承的例子，我借此解释一下12345678910111213141516171819 function extend(Child, Parent) &#123; var F = function()&#123;&#125;; //将父类的prototype复制到F函数中 F.prototype = Parent.prototype; /*new F()实例化F()实际的作用是生成了一个下面这个对象 &#123; __proto__: &#123; //Parent.prototype &#125; &#125; 这样就完成了 Child.prototype.__proto__ = Parent.prototype这个原型链继承的核心内容 */ Child.prototype = new F(); //Parent.prototype的constructor是Parent，为了准确这里要手动将Child.prototype.constructor改为Child Child.prototype.constructor = Child; //这里是为了代码实际开发时方便调用父类，不用使用__proto__ Child.uber = Parent.prototype; &#125; 涉及到继承这一块，Javascript 只有一种结构，那就是：对象。在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。—MDN原型链描述 上面这句话有些长，看代码获取会直观一点 12345childClass.prototype.__proto__ == parantClass.prototypechildInstance.__proto__ == childClass.prototypechildInstance.__proto__.__proto__ == childClass.prototype.prototype == parantClass.prototype 对于这里的childInstance.__proto__ == childClass.prototype，是由关键字new实现的，具体可以看我的另外一篇文章new到底做了什么 参考文献Javascript继承机制的设计思想Javascript面向对象编程（二）：构造函数的继承继承与原型链","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Javascript 代码优化","date":"2017-01-27T07:13:35.000Z","path":"2017/01/27/optimizing-javascript/","text":"客户端的脚本可以使你的应用变得动态和生动，但是浏览器对于JavaScript的解释可能会导致效率的底下，而且随着客户端本身的不同也会导致性能的不同。我们整理了一些建议和最好的实践来优化你的Javascript 代码。 ###定义class的方法 下面这个例子是低效的，每一次实例化baz.Bar，都会创建一个新foo的闭包函数。 123456baz.Bar = function() &#123; // constructor body this.foo = function() &#123; // method body &#125;;&#125; 比较好的方法是 1234567baz.Bar = function() &#123; // constructor body&#125;;baz.Bar.prototype.foo = function() &#123; // method body&#125;; 这种方式，无论创建多少个baz.Bar的示例，都只会创建一个foo函数，同时也没有闭包函数产生。 ###初始化实例变量Place instance variable declaration/initialization on the prototype for instance variables with value type (rather than reference type) initialization values (i.e. values of type number, Boolean, null, undefined, or string).这个可以避免每次构建函数被调用时不必要地每次都运行初始化代码（但是如果你的实例变量是依赖于构建函数的传入参数，或者依赖于构建时的一些状态则不适用于该建议） 例子 123456foo.Bar = function() &#123; this.prop1_ = 4; this.prop2_ = true; this.prop3_ = []; this.prop4_ = &apos;blah&apos;;&#125;; 应该改为下面这种形式 123456789foo.Bar = function() &#123; this.prop3_ = [];&#125;;foo.Bar.prototype.prop1_ = 4;foo.Bar.prototype.prop2_ = true;foo.Bar.prototype.prop4_ = &apos;blah&apos;; ###避免落入闭包的陷进 闭包是Javascript中一个很强大也很有用的一个特性；同时，它也有一些缺点： 闭包是最常见的导致内存泄漏的原因 创建一个闭包比起不使用闭包来创建一个内在的函数来说慢得多，和重用一个静态的函数来比要更加慢。如下例子 1234function setupAlertTimeout() &#123; var msg = &apos;Message to alert&apos;; window.setTimeout(function() &#123; alert(msg); &#125;, 100);&#125; 较快的：123456function setupAlertTimeout() &#123; window.setTimeout(function() &#123; var msg = &apos;Message to alert&apos;; alert(msg); &#125;, 100);&#125; 更快的12345678function alertMsg() &#123; var msg = &apos;Message to alert&apos;; alert(msg);&#125;function setupAlertTimeout() &#123; window.setTimeout(alertMsg, 100);&#125; 闭包会增加作用域的长度。当浏览器解析属性的时候，作用域的每一级都必须被查询。如下例子 1234567891011121314var a = &apos;a&apos;;function createFunctionWithClosure() &#123; var b = &apos;b&apos;; return function () &#123; var c = &apos;c&apos;; a; b; c; &#125;;&#125;var f = createFunctionWithClosure();f(); 当f被执行，引用c快于b,快于a。在ie中使用闭包的信息可以浏览IE+JScript Performance Recommendations Part 3: JavaScript Code inefficiencies ###避免使用with在你的代码中要避免视同with。它的性能很差，因为它会修改作用域链，使得其他的作用域连中查找变量变得困难。网站应用中最常见的内存泄漏是因为JavaScript脚本引擎和浏览器的C ++对象实现DOM一件的循环引用（例如：between the JavaScript script engine and Internet Explorer’s COM infrastructure, or between the JavaScript engine and Firefox XPCOM infrastructure） ###避免浏览器内存泄漏 在web应用中内存泄漏是一个很常见的问题，它会导致巨大的性能问题。当你的网站应用导致浏览器使用的的内存增加，会影响到用户的系统的其他部分变得缓慢。 这里有一些经验的法则来避免内存泄漏： 把事件处理绑定在事件管理系统上 最常见的循环引用类型就是 [ DOM element –&gt; event handler –&gt; closure scope –&gt; DOM ]，为了避免这种问题，应该选择一个经过良好测试的事件管理系统来绑定事件处理，例如Google doctype，Dojo或者Jquery。 未完 原文链接“","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"About this and prototype","date":"2017-01-27T07:12:03.000Z","path":"2017/01/27/About-this-and-prototype/","text":"对于js中this创建的对象，相当于改变了自身的字面量，而本身有一个自带的属性为prototype，这个不属于字面量的内容123456789101112131415function Person () &#123; this.name = &quot;wang&quot;; this.age = 15;&#125;Person.prototype.name = &apos;lala&apos;;var john = new Person();console.log(JSON.stringify(john));//&#123;name:&quot;wang&quot;, age:15&#125;//这里说明了this等同于的是对象字面量console.log(john.name) //“wang”，这里说明了，js会优先寻找字面量里面是否有这个对象，其次才会去prototype里面寻找 对象的样子如下12345678&#123; name:&apos;wang&apos;, age: 15, prototype:&#123; constructor:[Function], name: &apos;lala&apos; &#125;&#125;","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"require()","date":"2017-01-26T07:05:17.000Z","path":"2017/01/26/require/","text":"1module = new Module() //module 为 Module类的实例 12345678var Module = function(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; this.filename = null; this.loaded = false; this.children = [];&#125; 123var require = function()&#123; return module.exports&#125; 模块的加载实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出。—— require() 源码解读 所以说每一个require的文件执行的过程，都是先读取文件，注入变量，再执行代码，所以node文件不需要自己实例化Module,在require的时候会自动实例化的，所以从另一个角度说，文件并不会直接执行，所以看上去文件中的require，module等变量都为创建而可以执行。1234567891011121314151617//a.jsexports.multiply = function(n) &#123; return n * 1000 &#125;;//index.jsrequire(&apos;./a.js&apos;)//require(&apos;./a.js&apos;)实际的变为了 var module = &#123; exports: &#123;&#125; &#125;;(function(module, exports) &#123; exports.multiply = function(n) &#123; return n * 1000 &#125;; &#125;(module, module.exports)) return module.exports; ####Demo require原理 读取js文件并运行","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"use generator and co in mocha","date":"2017-01-25T07:05:17.000Z","path":"2017/01/25/use-generator-and-co-in-mocha/","text":"主要的点在于当 it() 函数的回调函数带有done参数，mocha会等到回调函数里面出 done 或者或者超时才完成一条测试。同时因为每个测试用例最多执行2000毫秒，所以要面对需要很长时间的测试，需要通过设置 -t 来修改最长时间（暂时没有更好的方法）1234it(&apos;option is empty&apos;, function(done) &#123; ... done()//结束一条测试&#125;); 例子12345678910111213describe(&apos;runBash&apos;, function() &#123; it(&apos;option is Sync&apos;, function(done) &#123; var instructionList = [&apos;echo &quot;one&quot;&apos;, &apos;echo &quot;two&quot;&apos;]; var option = &#123; webRoot: &apos;../fake-natoo&apos; &#125;; co(function*(done) &#123; var errCode = yield runBash(instructionList, option); expect(errCode).to.be.equal(null); done();//完成测试 &#125;.call(this, done));//传入done &#125;);&#125;); ps Mocha默认每个测试用例最多执行2000毫秒(可以通过-t来调整)Mocha默认会高亮显示超过75毫秒的测试用例（可以通过-s来调整）&lt;&lt;测试框架 Mocha 实例教程&gt;&gt;(阮一峰)","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Test","slug":"Test","permalink":"http://yoursite.com/tags/Test/"}]}]