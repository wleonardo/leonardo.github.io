[{"title":"中间件（middleware）","date":"2018-05-06T10:21:08.000Z","path":"2018/05/06/middleware/","text":"在我们日常开发中，越来越多看到了中间件这个词，例如Koa，redux等。这里就大概记录一下Koa和redux中间件的实现方式，可以从中看到中间件的实现方式都是大同小异，基本都是实现了洋葱模型。 对于中间件我们需要了解的是 中间件是如何存储的 中间件是如何执行的 Koa作为TJ大神的作品，真不愧是号称基于 Node.js 平台的下一代 web 开发框架，其中对于中间件的实现，generator/yield,还是await/async,对于回调地狱的处理，都是给后来的开发者很大的影响。 Koa 1的中间件存储123456789101112131415161718192021222324252627282930/** * https://github.com/Koajs/Koa/blob/1.6.0/lib/application.js */ ... var app = Application.prototype; function Application() &#123; if (!(this instanceof Application)) return new Application; this.env = process.env.NODE_ENV || &apos;development&apos;; this.subdomainOffset = 2; this.middleware = []; this.proxy = false; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response);&#125;...app.use = function(fn)&#123; if (!this.experimental) &#123; // es7 async functions are not allowed, // so we have to make sure that `fn` is a generator function assert(fn &amp;&amp; &apos;GeneratorFunction&apos; == fn.constructor.name, &apos;app.use() requires a generator function&apos;); &#125; debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;); this.middleware.push(fn); return this;&#125;; 可以在这里看到我们通过app.use加入的中间件，保存在一个middleware的数组中。 执行123456789101112131415161718192021222324252627282930/** * https://github.com/Koajs/Koa/blob/1.6.0/lib/application.js */app.listen = function()&#123; debug(&apos;listen&apos;); var server = http.createServer(this.callback()); return server.listen.apply(server, arguments);&#125;;// 删除了一些警告代码app.callback = function()&#123; ... var fn = this.experimental ? compose_es7(this.middleware) : co.wrap(compose(this.middleware)); var self = this; ... return function handleRequest(req, res)&#123; var ctx = self.createContext(req, res); self.handleRequest(ctx, fn); &#125;&#125;;app.handleRequest = function(ctx, fnMiddleware)&#123; ctx.res.statusCode = 404; onFinished(ctx.res, ctx.onerror); fnMiddleware.call(ctx).then(function handleResponse() &#123; respond.call(ctx); &#125;).catch(ctx.onerror);&#125;; 可以在这里看到middleware数组经过一些处理，生成了fn，然后通过fnMiddleware.call(ctx)传入ctx来处理，然后就将ctx传给了respond,所以这里的fnMiddleware就是我们需要去了解的内容。 这里首先判断是否是this.experimental来获取是否使用了async/await，这个我们在Koa1中不做详细介绍。我们主要是来看一下co.wrap(compose(this.middleware))。 让我们先来看一下compose()12345678910111213141516171819/** * 这里使用了Koa1@1.6.0 package.json中的Koa-compose的版本 * https://github.com/Koajs/compose/blob/2.3.0/index.js */function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; return yield *next; &#125;&#125;function *noop()&#123;&#125; co.wrap(compose(this.middleware))就变成了如下的样子 1234567891011co.wrap(function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; return yield *next;&#125;) 我们可以看到这里对middleware进行了倒序遍历。next = middleware[i].call(this, next);可以写为类似下面这个代码结构 12345678910111213function *middleware1() &#123; ... yield function *next1() &#123; ... yield function *next2() &#123; ... ... ... &#125; ... &#125; ...&#125; 然后next = middleware[i].call(this, next);其实每一个next就是一个middleware，所以也就可以变成12345678910111213function *middleware1() &#123; ... yield function *middleware2() &#123; ... yield function *middleware() &#123; ... ... ... &#125; ... &#125; ...&#125; 然后我们就获得了下面这个代码 12345678910111213141516171819co.wrap(function *(next)&#123; next = function *middleware1() &#123; ... yield function *middleware2() &#123; ... yield (function *middleware3() &#123; ... yield function *() &#123; // noop // NO next yield ! &#125; ... &#125; ... &#125; ... &#125; return yield *next;&#125;) 至此我们来看一眼洋葱模型, 是不是和我们上面的代码结构很想。 现在我们有了洋葱模型式的中间节代码，接下来就是执行它。接下来就是co.wrap,这里我们就不详细说明了，co框架就是一个通过Promise来让generator自执行的框架，实现了类似async/await的功能（其实应该说async/await的实现方式就是Promise和generator）。 这里提一个最后yield *next，是\b让code可以少执行一些，因为如果使用yield next，会返回一个迭代器，然后co来执行这个迭代器，而yield *则是相当于将generator里面的内容写在当前函数中，详细可以见yield* \b关于Koa1可以看我的早一些写的另一篇Koa中间件（middleware）实现探索 Koa 2的中间件存储123456789101112131415161718192021222324252627282930/** * https://github.com/Koajs/Koa/blob/1.6.0/lib/application.js */ ... constructor() &#123; super(); this.proxy = false; this.middleware = []; this.subdomainOffset = 2; this.env = process.env.NODE_ENV || &apos;development&apos;; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); &#125;... use(fn) &#123; if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;); if (isGeneratorFunction(fn)) &#123; deprecate(&apos;Support for generators will be removed in v3. &apos; + &apos;See the documentation for examples of how to convert old middleware &apos; + &apos;https://github.com/Koajs/Koa/blob/master/docs/migration.md&apos;); fn = convert(fn); &#125; debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;); this.middleware.push(fn); return this; &#125; Koa2对于middleware的\b存储和Koa1基本一模一样，\b保存在一个数组中。 执行1234567891011121314151617181920212223242526callback() &#123; const fn = compose(this.middleware); if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror); const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest; &#125; /** * Handle request in callback. * * @api private */ handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); 这里主要就是两行代码\u001c123const fn = compose(this.middleware);// fnMiddleware === fnfnMiddleware(ctx).then(handleResponse).catch(onerror); Koa2的代码似乎比Koa1要简介一些了，\b在默认使用await/async之后，\b少了co的使用。 从fnMiddleware(ctx).then(handleResponse).catch(onerror);我们可以知道fnMiddleware返回了一个Promise,然后执行了这个Promise，所以我们主要知道\bcompose做了什么就好。 12345678910111213141516171819202122232425/** * https://github.com/Koajs/compose/blob/4.0.0/index.js */function compose (middleware) &#123; ... return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;)) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, function next () &#123; return dispatch(i + 1) &#125;)) &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; 看起来这段代码比Koa1的compose稍微复杂了些，其实差不多，\b主要的代码\b其实也就两个 12345678910111213function compose (middleware) &#123; ... return function (context, next) &#123; let index = -1 return dispatch(0) function dispatch (i) &#123; let fn = middleware[i] return Promise.resolve(fn(context, function next () &#123; return dispatch(i + 1) &#125;)) &#125; &#125;&#125; 相比于Koa1遍历middleware数组，Koa2改为了递归。同上面一样，我们可以将函数\b写为如下结构 1234567891011async function middleware1() &#123; ... await (async function middleware2() &#123; ... await (async function middleware3() &#123; ... &#125;); ... &#125;); ...&#125; 因为async函数的自执行，所以直接运行该函数就可以了。 可以看到Koa1\u001c与Koa2的中间件的实现方式基本是一样的，只是一个是基于generator/yield， 一个是基于async/await。 Redux相比于Koa的中间件的具体实现，Redux相对稍复杂一些。 本人对于Redux基本没有使用，只是写过一些简单的demo，看过一部分的源码，如有错误，请指正 存储我们在使用Redux的时候可能会这么写12345678910111213141516// 好高阶的函数啊const logger = store =&gt; next =&gt; action =&gt; &#123; console.group(action.type) console.info(&apos;dispatching&apos;, action) let result = next(action) console.log(&apos;next state&apos;, store.getState()) console.groupEnd(action.type) return result&#125;let store = createStore( todoApp, applyMiddleware( logger )) 我们可以很方便的找到applyMiddleware的源码。 1234567891011121314151617181920212223export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; Redux没有单独保存middleware的地方，但是通过展开符的...middlewares，我们也可以知道至少一开始的middlewares是一个数组的形式。 执行执行的代码，还是上面那段代码片段。 我们可以看到applyMiddleware()中，对传入的middlewares做了简单的封装，目的是为了让每个middleware在执行的时候可以拿到当前的一些环境和一些必要的接口函数。也就是上面那个高阶函数logger所需要的三个参数store,next,action。 一开始是middlewares.map(middleware =&gt; middleware(middlewareAPI))，而middlewareAPI传入了getState和dispatch接口（dispatch接口暂时没有用）。这一步就实现了上面高阶函数logger所需要的参数store。 然后是我们看到好多次的compose函数，我们找到compose函数的实现。 1234567891011export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; 我们看到compose对传入的中间件函数，通过Array.reduce函数处理了一下。最终的函数应该大概类似下面这个格式 12345678910// 加入函数名next方便后面理解function chain(...args) &#123; return () =&gt; &#123; return a(function next(...args) &#123; return b(function next(...args) &#123; return c(...args); &#125;) &#125;) &#125;&#125; 这里已经再次出现了我们熟悉的洋葱模型。同时将下一个组件已参数（next）的形式传入当前的中间件，这里就完成了上面的高阶函数logger所需要的第二个参数next,在中间件内部调用next函数就可以继续中间节的流程。 最后传入了store.dispatch也就是高阶函数logger所需要的第二个参数action，这个就不用多数了，就是将我们刚刚得到的洋葱格式的函数调用一下，通过闭包使得每个中间节都可以拿到store.dispatch。 至此，Redux和Koa的中间件的介绍就差不多了，两者都是以数组的形式保存了中间件，执行的时候都是创建了一个类似洋葱模型的函数结构，也都是将一个包裹下一个中间件的函数当做next，传入当前中间件，使得当前中间件可以通过调用next来执行洋葱模型，同时在next执行的前后都可以写逻辑代码。不同的是Koa1是通过遍历生成的，Koa2是通过递归来生成的，redux是通过reduce来生成的（和Koa1的遍历类似）。 所以中间件其实都基本类似，所以好好的理解了一种中间件的实现方式，其他的学起来就很快了（只是表示前端这一块哦）。","tags":[{"name":"前端","slug":"前端","permalink":"http://wangyuekai.com/tags/前端/"}]},{"title":"promise-a+","date":"2017-12-28T10:17:46.000Z","path":"2017/12/28/promise-a/","text":"Promise A+ 学习 在js的本身被设计为异步的，那么这就给编码提出了一个要求，该如何去优雅的编写js代码中异步的代码，最早的时候，我们使用回调来处理这个问题。但是同时也产生了回调地狱的问题。 后来则出现了Promise，Promise的出现可以说彻底改变了对于异步代码的编写方式。Promise的影响之深远，可以说es6加入了Promise，koa中yield，Generator也是配合了Promise才实现了类似await，async的功能。知道ES7中真正的async和await也是基于Promise实现的（其实async和await只是Generator的语法糖）。可以说Promise在异步编程中已经无处不在了。 所以了解Promise的规范还是很有必要的。当然最好的是去看一下规范的原文。 Promise A+的英文原文：Promise/A+下面对于原文的翻译，我将会引用一个网上已有的翻译版本【翻译】Promises/A+规范的内容，在此感激作者。 一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。 Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 then 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。 本规范详细列出了 then 方法的执行过程，所有遵循 Promises/A+ 规范实现的 promise 均可以本标准作为参照基础来实施 then 方法。因而本规范是十分稳定的。尽管 Promise/A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。 从历史上说，本规范实际上是把之前 Promise/A 规范 中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。 最后，核心的 Promises/A+ 规范不设计如何创建、解决和拒绝 promise，而是专注于提供一个通用的 then 方法。上述对于 promises 的操作方法将来在其他规范中可能会提及。 术语1.1 Promisepromise 是一个拥有 then 方法的对象或函数，其行为符合本规范； 1.2 thenable是一个定义了 then 方法的对象或函数，文中译作“拥有 then 方法”； 1.3 值（value）指任何 JavaScript 的合法值（包括 undefined , thenable 和 promise）； 1.4 异常（exception）是使用 throw 语句抛出的一个值。 1.5 据因（reason）表示一个 promise 的拒绝原因。 要求2.1 Promise 的状态一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。 2.1.1 等待态（Pending）处于等待态时，promise 需满足以下条件： 可以迁移至执行态或拒绝态 2.1.2 执行态（Fulfilled）处于执行态时，promise 需满足以下条件： 不能迁移至其他任何状态 必须拥有一个不可变的终值 2.1.3 拒绝态（Rejected）处于拒绝态时，promise 需满足以下条件： 不能迁移至其他任何状态 必须拥有一个不可变的据因 这里的不可变指的是恒等（即可用 === 判断相等），而不是意味着更深层次的不可变 2.2 then方法一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因 promise 的 then 方法接受两个参数： 1promise.then(onFulfilled, onRejected) 2.2.1 onFulfilled 和 onRejected 都是可选参数。2.2.1.1 如果 onFulfilled 不是函数，其必须被忽略2.2.1.2 如果 onRejected 不是函数，其必须被忽略2.2.2 如果 onFulfilled 是函数：2.2.2.1 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值 类似 onFulfilled(value); 2.2.2.2 在 promise 执行结束前其不可被调用123456789101112// 这里的onFulfilled为伪代码，表示onFulfilled的执行函数var onFulfilled = function() &#123; console.log(&quot;onFulfilled&quot;);&#125;var c = new Promise((onFulfilled, onRejected) =&gt; &#123; onFulfilled(&apos;ok&apos;); console.log(&apos;123&apos;);&#125;)&gt; &apos;123&apos;&gt; &apos;onFulfilled&apos; 2.2.2.3 其调用次数不可超过一次12345678var c = new Promise((onFulfilled, onRejected) =&gt; &#123; onFulfilled(&apos;ok&apos;); onFulfilled(&apos;ok2&apos;);&#125;);c.then((data) =&gt; &#123; console.log(data); // &apos;ok&apos;&#125;) 2.2.3 如果 onRejected 是函数：2.2.3.1 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因2.2.3.2 在 promise 被拒绝执行前其不可被调用2.2.3.3 其调用次数不可超过一次2.2.4 onFulfilled和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用2.2.5 onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）2.2.6 then 方法可以被同一个 promise 调用多次2.2.6.1 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调2.2.6.1 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调2.2.7 then 必须返回一个 promise1promise2 = promise1.then(onFulfilled, onRejected); 2.2.7.1 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[Resolve]2.2.7.2 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e2.2.7.3 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值2.2.7.4 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因2.3 Promise 解决过程 注释：这里是描述的是Promise.then() 执行以后返回什么内容，其实Promise.then()一定会返回一个新的Promise，但是具体是什么内容，是和then里的回调函数的返回值有关，下面的x就是then的回调函数的返回值。可以再看一眼上面2.2.7的内容 Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [[Resolve]](promise, x)，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。 这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。 运行 [[Resolve]](promise, x)需遵循以下步骤： 2.3.1 x 与 promise 相等如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise123456789101112var p = new Promise(function(resolve, reject) &#123; resolve(123);&#125;);/* then的回调函数返回了p2, 和promise是同一个变量，那么就会返回一个错误 */var p2 = p.then((data) =&gt; &#123; return p2;&#125;);&gt;&gt; Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt; 2.3.2 x 为 Promise如果 x 为 Promise ，则使 promise 接受 x 的状态 2.3.2.1 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝2.3.2.2 如果 x 处于执行态，用相同的值执行 promise2.3.2.3 如果 x 处于拒绝态，用相同的据因拒绝 promise 这里其实是我们经常会用到的一个特性，就是promise链式调用,这里就不多解释了 123456getUserInfo().then((userInfo) =&gt; &#123; return getCompanyInfo();&#125;).then((companyInfo) =&gt; &#123; return getCityInfo();&#125;).then((cityInfo) =&gt; &#123;&#125;) 2.3.3 x 为对象或函数2.3.3.1 把 x.then 赋值给 then 这里相当于创建了一个新的变量then，类似 var then = x.then;, 作用其实和我们平常的这样做的方式差不多，方便后面的使用。 2.3.3.2 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise123456789101112131415161718function objFactory() &#123; var obj = &#123;&#125;; Object.defineProperty(obj, &quot;then&quot;, &#123; get: function() &#123; throw Error(&apos;then error&apos;); &#125; &#125;); return obj;&#125;var a = new Promise((resolve) =&gt; &#123; resolve();&#125;);a.then(() =&gt; &#123; return objFactory()&#125;);// Uncaught (in promise) Error: then error 2.3.3.3 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise:123456// 类似这个代码var then = x.then;if (typeof then === &apos;function&apos;) &#123; then.call(x, resolvePromise, rejectPromise);&#125; 2.3.3.3.1 如果 resolvePromise 以值 y 为参数被调用，则运行 [Resolve]1234567891011121314151617181920212223function objFactory() &#123; var obj = &#123;&#125;; Object.defineProperty(obj, &quot;then&quot;, &#123; get: function() &#123; return function(resolvePromise, rejectPromise) &#123; resolvePromise(&apos;resolve_y&apos;); &#125; &#125; &#125;); return obj;&#125;var a = new Promise((resolve) =&gt; &#123; resolve();&#125;);var c = a.then(() =&gt; &#123; return objFactory()&#125;);c.then((data) =&gt; &#123; console.log(data); // &quot;resolve_y&quot;&#125;) 2.3.3.3.2 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise123456789101112// 类似 2.3.3.3.1function objFactory() &#123; var obj = &#123;&#125;; Object.defineProperty(obj, &quot;then&quot;, &#123; get: function() &#123; return function(resolvePromise, rejectPromise) &#123; rejectPromise(&apos;resolve_y&apos;); &#125; &#125; &#125;); return obj;&#125; 2.3.3.3.3 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 这个就不给例子了，表述也很直接了 2.3.3.3.4 如果调用 then 方法抛出了异常 e：2.3.3.3.4.1 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之123456789101112131415161718192021222324function objFactory() &#123; var obj = &#123;&#125;; Object.defineProperty(obj, &quot;then&quot;, &#123; get: function() &#123; return function(resolvePromise, rejectPromise) &#123; resolvePromise(&apos;resolve_y&apos;); console.log(test); &#125; &#125; &#125;); return obj;&#125;var a = new Promise((resolve) =&gt; &#123; resolve();&#125;);var c = a.then(() =&gt; &#123; return objFactory()&#125;);c.then((data) =&gt; &#123; console.log(data); // &quot;resolve_y&quot;&#125;) 2.3.3.3.4.2 否则以 e 为据因拒绝 promise12345678910111213141516171819202122function objFactory() &#123; var obj = &#123;&#125;; Object.defineProperty(obj, &quot;then&quot;, &#123; get: function() &#123; return function(resolvePromise, rejectPromise) &#123; console.log(test); resolvePromise(&apos;resolve_y&apos;); &#125; &#125; &#125;); return obj;&#125;var a = new Promise((resolve) =&gt; &#123; resolve();&#125;);var c = a.then(() =&gt; &#123; return objFactory()&#125;);// VM1124:6 Uncaught (in promise) ReferenceError: test is not defined 2.3.3.3.5 如果 then 不是函数，以 x 为参数执行 promise123456789101112131415161718192021function objFactory() &#123; var obj = &#123;&#125;; Object.defineProperty(obj, &quot;then&quot;, &#123; get: function() &#123; return &apos;test&apos;; &#125; &#125;); return obj;&#125;var a = new Promise((resolve) =&gt; &#123; resolve();&#125;);var c = a.then(() =&gt; &#123; return objFactory()&#125;);c.then((data) =&gt; &#123; console.log(data); // object &#123;then: &quot;test&quot;&#125;&#125;) 2.3.3.4 如果 x 不为对象或者函数，以 x 为参数执行 promise1234567891011var a = new Promise((resolve) =&gt; &#123; resolve();&#125;);var c = a.then(() =&gt; &#123; return &quot;test&quot;&#125;);c.then((data) =&gt; &#123; console.log(data); // &quot;test&quot;&#125;) 未完待续","tags":[]},{"title":"charles-https-proxy","date":"2017-11-23T11:55:21.000Z","path":"2017/11/23/charles-https-proxy/","text":"使用mac作为开发工具的web相关的开发同学，相信都有用过一个很好用的代理截包工具—charles 这两年，随着google对https的大力推动和越来越多的公司认识到https对于网络安全的重要性，越来越多的项目已经使用上https了。 这使得以前相对比较简单的截包设置来说，多了一些步骤。这里主要记录一下关于ios的截包设置。对于charles端的设置，相对来说网上也有很多的教程了。这边就简单提一下。 需要在help 的 SSL Proxying 选项中点击install Charles Root Certificate 在钥匙串中点击添加 设置证书为信任 在Charles的Proxy中选中SSL Proxying Settings, 在里面增加你需要解析的https 接下来，我们将我们ios设备连接上Charles的代理（这个网上教程很多了） 然后在safari中打开https://chls.pro/ssl，添加证书，然后你就可以再safari中访问https的网站，并看到请求的具体信息了。 但是很多时候我们更多的是需要查看APP中的信息，那么你还需要下面一步 在ios大于10.3的版本中，你需要打开设置-&gt; 通用-&gt; 关于本机-&gt; 证书信任设置，在这里，将Charles的证书设置为完全信任，那么我们在ios设备上的任何地方访问的https请求都可以被解析看到了。 具体的信息可以查看Charles的官方文档","tags":[]},{"title":"requirejs和react的动态模块加载","date":"2017-09-25T06:57:06.000Z","path":"2017/09/25/requirejs-async-module-loader/","text":"requirejs是当前比较好的AMD规范的实现，所有的JS文件会被打包成一个js文件，减少请求数量，同时比较方便的实现了SPA的模式。但是随着项目的推进，SPA的首屏加载问题就会越来越明显。针对这个问题，webpack在v1版本中通过require.ensure，在v2版本中通过dynamic-imports来解决这个问题，不过实现最重要的就是在代码运行过程中动态加载其他的js文件（模块）。在requirejs的官方文档中，我们可以看到在模块中，也是可以随时使用require来加载新的模块，如下 123456789require([&quot;require&quot;, &quot;alpha&quot;, &quot;beta&quot;], function(require, alpha, beta) &#123; setTimeout(function() &#123; require([&quot;omega&quot;], function(omega) &#123; console.log(&quot;load omega finish&quot;); &#125; ); &#125;, 100);&#125;); 不过我们在上面的代码中看到了很常见的回调地狱的问题，同时也会有一些异常处理的问题，所以我们首先先使用promise封装一下require的文件加载 12345678910111213141516171819202122232425/** * [asyncModule description] * @param &#123;[type]&#125; paths [传入一个模块路径的数组] * @return &#123;[type]&#125; [Promise] */function asyncModule(paths) &#123; return new Promise((resolve, reject) =&gt; &#123; if (!(paths instanceof Array)) &#123; reject(&apos;paths should be a array&apos;); return false; &#125; /** * [paths description] * @type &#123;[type]&#125; */ paths = paths.map((path) =&gt; &#123; path = manifest[path] || path; let url = require.toUrl(path).slice(1); return url.slice(0, url.indexOf(&apos;?&apos;)); &#125;); require(paths, function callback(Module) &#123; resolve.apply(this, arguments); &#125;); &#125;);&#125; 上面有一段代码是path的处理，主要是搭配require来处理模块的路径: 1require.config(&#123; baseUrl: &apos;js/&apos;, waitSeconds: 60&#125;); 我们再通过react来封装一个”模块加载器”: 12345678910111213141516171819202122232425262728define([], () =&gt; class DynamicModuleLoader extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; log: &apos;module loading&apos;, module: undefined &#125;; &#125; componentDidMount() &#123; asyncModule([this.props.module]).then((module) =&gt; &#123; this.setState(&#123; module &#125;); &#125;).catch((e) =&gt; &#123; this.setState(&#123; log: &apos;module load error&apos; &#125;); &#125;); &#125; render() &#123; if (this.state.module) &#123; return &lt;this.state.module &#123;...this.props&#125; /&gt;; &#125; return ( &lt;div data-ilog=&#123;this.state.log&#125; /&gt; ); &#125;&#125;); 接下来我们在代码中以如下方式使用即可 123456789101112131415161718define([&apos;dynamic-module-loader&apos;], (DynamicModuleLoader) =&gt; class PageHome extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; ... &#125;; &#125; componentDidMount() &#123; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;DynamicModuleLoader module=&quot;module1/index.dynamic.js&quot; renderData=&#123;this.props&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); 除了代码层面的修改，还需要针对构建工具做修改, 首先我们将需要动态加载的js文件加上.dynamic.js的后缀，主要的问题在于，我们需要使用module1/index.dynamic.js来加载，但是实际上，我们还需要考虑版本的问题，所以真实的加载文件的路径可能是module1/index-f37e86f666.dynamic.js,所以需要考虑开发时的便利和生成环境的需求，这里我们使用了gulp，: 1234567891011const gulp = require(&apos;gulp&apos;);const babel = require(&apos;gulp-babel&apos;);const rev = require(&apos;gulp-rev&apos;);gulp.src(`$&#123;PROJECT_PATH&#125;/js/**/*.async.js`) .pipe(babel()) .pipe(uglifyJS()) .pipe(rev()) .pipe(gulp.dest(`$&#123;BUILD_PATH&#125;js/`)) .pipe(rev.manifest()) .pipe(gulp.dest(`$&#123;BUILD_PATH&#125;js/`)); 这里我们通过gulp-rev来重命名模块，并且生成了manifest.json。那我们只需要在上面function asyncModule()中拿到manifest.json,获取就可以查询得到真正的模块路径。 这里你可以通过ajax.get来获取manifest.json然后保存在全局变量。不过也可以通过gulp-repalce，在构建的时候直接将整个json插入到代码中，就不需要单独加载一个json了。","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"},{"name":"requirejs","slug":"requirejs","permalink":"http://wangyuekai.com/tags/requirejs/"}]},{"title":"sock5代理node实现(3)","date":"2017-08-01T12:36:59.000Z","path":"2017/08/01/node-socks-proxy-3/","text":"在前两篇两次握手信息之后，我们这次终于可以到获取数据这一步了。 在客户端收到我们上一篇数据的密码验证成功的信息后，客户端会向服务端发出需要访问的地址，它可能是IP(Ipv4或者Ipv6)和端口号，也有可能是域名和端口号。 具体的数据格式类似下面 +—-+—–+——-+——+———-+———-+|VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT |+—-+—–+——-+——+———-+———-+| 1 | 1 | X’00’ | 1 | Variable | 2 |+—-+—–+——-+——+———-+———-+ 第一个参数VER表示使用的协议版本号 第二个参数CMD表示需要使用的链接方式 0x01 表示CONNECT，比如我们常见的http请求 0x02 表示BIND，比如FTP等请求 0x03 表示UDP。 第三个参数RSV表示单词RESERVED，也就是字面意思保留字段，暂时没有用 第四个参数ATYP表示address type，就是使用的地址类型 0x01 IP V4地址 0x03 域名 0x04 IP V6地址 第五个参数DST.ADDR，表示目标主机的地址 第六个参数DST.PORT，表示目标主机的端口 在我们拿到地址和端口后，我们可以尝试连接目标主机，在我们连接成功后，返回给客户端类似下面的数据 +—-+—–+——-+——+———-+———-+|VER | REP | RSV | ATYP | BND.ADDR | BND.PORT |+—-+—–+——-+——+———-+———-+| 1 | 1 | X’00’ | 1 | Variable | 2 |+—-+—–+——-+——+———-+———-+ 字段内容和上面基本一样BND.ADDR就是DST.ADDR,BND.PORT就是DST.PORT。 唯一不同的就是REP，这个表示服务端去连接目标主机的结果 X’00’ 成功 X’01’ 普通的SOCKS服务器请求失败 X’02’ 现有的规则不允许的连接 X’03’ 网络不可达 X’04’ 主机不可达 X’05’ 连接被拒 X’06’ TTL超时 X’07’ 不支持的命令 X’08’ 不支持的地址类型 X’09’ – X’FF’ 未定义 客户端接下来就会把原来的请求完整的发给服务端，服务端直接转发给目标主机就好，其实在我们服务端和客服端相互认证并且服务端与目标主机连接上以后，服务端接下来的任务就相当于在客户端与目标主机充当搬运工的职责，只是负责包客户端的请求内容一样的发给目标主机，再把目标主机的内容发给客户端。 下面是对应的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const net = require(&apos;net&apos;);// 用来解析地址信息const ReqInfo = require(&apos;./reqinfo.js&apos;);async function receiveRequest(chunk) &#123; let socket = this; // 获取到地址信息 let reqinfo = await ReqInfo(chunk); let resp = new Buffer(chunk.length); // 上面提到的两个数据格式基本一样，只是有一个字段不一样而已，所以为了方便就复制一份 chunk.copy(resp); resp[0] = 0x05; // 不代理本地地址 if (reqinfo.dest === &apos;127.0.0.1&apos; || reqinfo.dest === &apos;localhost&apos;) &#123; resp[1] = 0x02; socket.write(resp); return false; &#125; try &#123; // 尝试连接目标主句 let req = net.createConnection(reqinfo.port, reqinfo.dest, (s) =&gt; &#123; log(&apos;createConnection success&apos;); // 要在保证连接上目标服务器返回成功数据 resp[1] = 0x00; socket.write(resp); // 在客户端接受到连接上服务器的信息，则会发送完整的请求内容，直接转发给req socket.pipe(req); req.pipe(socket); &#125;); // 设置连接目标主机的超时时间 req.setTimeout(60 * 1000); // 连接超时 req.on(&apos;timeout&apos;, () =&gt; &#123; resp[1] = 0x06; socket.write(resp); req.destroyed || req.destroy(); &#125;); // 连接目标主机失败 req.on(&apos;error&apos;, () =&gt; &#123; resp[1] = 0x05; socket.write(resp); &#125;); &#125; catch (e) &#123; console.error(&apos;未捕捉错误: net.createConnection&apos;); socket.emit(&apos;error&apos;, e); &#125;&#125;module.exports = receiveRequest; 细心的人肯定看到了，我这边使用了async和await，主要是在解析目标主机地址时用到了，主要原因是因为我在写这段代码，调试的时候不知道为什么google就是连接不上，其他的网站都可以，后来发现原来，我所在的地方DNS被劫持了，google.com域名返回的是百度的ip，结果因为https的安全问题(相当于给百度发了google.com的证书)，导致一直访问错误。 所以就把DNS放在服务端了，DNS的解析是异步的，所以这里使用async和await来解决异步的问题。不过这样会增加服务端的压力，不过这个设置可以在客户端配置。另外肯定也看到了，我这里并没有贴出const ReqInfo = require(&#39;./reqinfo.js&#39;);的具体代码，具体代码请移步github socks-proxy看吧，这里就不具体解释了。 至此socks5代理的服务端就基本完成了，当然这个只是一个很简单的版本，还需要很多的异常需要处理，仅供娱乐吧。 sock5代理node实现(1)sock5代理node实现(2)","tags":[{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"},{"name":"socks","slug":"socks","permalink":"http://wangyuekai.com/tags/socks/"},{"name":"proxy","slug":"proxy","permalink":"http://wangyuekai.com/tags/proxy/"}]},{"title":"sock5代理node实现(2)","date":"2017-07-31T15:10:17.000Z","path":"2017/07/31/node-socks-proxy-2/","text":"上一篇我们已经完成了socks5客服端和服务端的第一次握手认证，相互确认了socks协议的版本号，认证的方式，现在认证方式定为用户名和密码认证，接下来我们马上就来认证。 RFC的socks5文档中并没有写用户名和密码认证的认证细节，而是写在另一篇文档中。 客户端在接收到上一篇最后发出的数据后，会发出下面这个格式的数据 +—-+——+———-+——+———-+|VER | ULEN | UNAME | PLEN | PASSWD |+—-+——+———-+——+———-+| 1 | 1 | 1 to 255 | 1 | 1 to 255 |+—-+——+———-+——+———-+ 第一个参数VER表示当前的账号密码认证的协议版本号（注意这个不是socks的版本号），暂时只有0x01。 第二个参数带ULEN为用户名的长度，从这里可以看到用户名最长为255位。 第三组参数ULEN就是用户名，长度就是ULEN。 第四个参数PLEN为密码长度，同样最长为255位。 第五组参数PLEN是密码，长度为PLEN。 而我们的服务端需要在获取到账号密码后返回以下格式的数据 +—-+——–+|VER | STATUS |+—-+——–+| 1 | 1 |+—-+——–+ 第一个参数VER表示当前的账号密码认证的协议版本号（注意这个不是socks的版本号），暂时只有0x01。 第二个参数STATUS表示是否认证成功，其中只有STATUS为0x00表示成功，其他都是表示错误。 下面是对应的Node代码实现: 12345678910111213141516171819202122232425262728// 这个后续会说明const receiveRequest = require(&apos;./receive-request.js&apos;);module.exports = function (data) &#123; const socket = this; let ver = data[0]; // 用户名长度 let ulen = parseInt(data[1], 10); // 用户名 let username = data.slice(2, 2 + ulen).toString(&apos;utf8&apos;); // 密码长度 let plen = parseInt(data[1 + ulen + 1], 10); let passwordStartPostion = 1 + ulen + 2; // 密码 let password = data.slice(passwordStartPostion, passwordStartPostion + plen).toString(&apos;utf8&apos;); // status不是0x00就表示密码错误 let status = 0x01; // 这里我们账号密码暂时写死为abc 1234 if (username === &apos;abc&apos; &amp;&amp; password === &apos;1234&apos;) &#123; status = 0x00; &#125; let res = new Buffer([ver, status]); // 将结果返回给客户端 socket.write(res); // 监听下一次请求 socket.once(&apos;data&apos;, receiveRequest.bind(socket));&#125;; sock5代理node实现(1)sock5代理node实现(3)","tags":[{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"},{"name":"socks","slug":"socks","permalink":"http://wangyuekai.com/tags/socks/"},{"name":"proxy","slug":"proxy","permalink":"http://wangyuekai.com/tags/proxy/"}]},{"title":"sock5代理node实现(1)","date":"2017-07-30T15:37:37.000Z","path":"2017/07/30/node-socks-proxy-1/","text":"相信大家都使用过或者听说过shadowsocks, 它可以帮助我们访问一些“访问不到”的网站。在wiki上对于它的说明是“shadowsocks是一种基于Socks5代理方式的网络数据加密传输包”(百度上并没有这个词条了)。其实shadowsocks就是socks5协议的客户端和服务端的实现。接下来我们了解一下socks5的具体细节，并使用node来实现一个简单的服务端版本。 其中socks有socks4和socks5版本，socks5比socks4多了UDP、验证，以及IPv6的支持，所有socks5是socks4的升级版也支持了socks4所有的内容（我们下面说到的所有socks协议都是基于socks5版本）。同时socks协议位于表示层和传输层之间，而http和https位于应用层，所以使用socks协议来代理https可以不需要考虑https本身的安全限制。 关于socks5的协议，我们可以查看RFC的socks5说明。 需要注意的是socks5传输的都是16进制的数据。 创建服务器首先我们需要创建一个服务器来接收后面客服端传过来的数据。 下面是node的实现： 12345678910111213141516171819202122232425262728293031const net = require(&apos;net&apos;);// 第一次握手连接的数据处理，后面会实现。const shakehand = require(&apos;./shake-hand.js&apos;);function connectServer(socket) &#123; try &#123; // 监听socket的错误信息 socket.on(&apos;error&apos;, (e) =&gt; &#123; console.error(e); &#125;); // 设置超时并监听timeout事件 socket.setTimeout(60 * 1000); socket.on(&apos;timeout&apos;, () =&gt; &#123; socket.destroyed || socket.destroy(); &#125;); // 用于下面的握手连接 // 因为socks5的整个握手和认证需要传输多次数据，每次都不一样，所以这里只需要监听一次。 socket.once(&apos;data&apos;, shakehand.bind(socket)); &#125; catch (e) &#123; console.error(&apos;未捕捉错误&apos;); console.error(e); &#125;&#125;// 监听1080端口net.createServer(connectServer).listen(1080).on(&apos;error&apos;, (e) =&gt; &#123; console.error(e);&#125;); 第一次握手连接可以看到第一步是创建连接。首先是由客户端发起请求，这里我们还没有写socks5的客户端，我们暂时使用curl来代替socks5客户端。 我们第一次收到这样格式的数据。 +—-+———-+———-+|VER | NMETHODS | METHODS |+—-+———-+———-+| 1 | 1 | 1 to 255 |+—-+———-+———-+ 第一个VER表示客服端采用的socks版本，例如socks5版本就会是0x05。 第二个参数NMETHODS表示客户端支持的验证类型的数量。 第三个参数METHODS，每一位表示一个验证类型。 当前定义的方法有：· X’00’ 不需要认证· X’01’ GSSAPI· X’02’ 用户名/密码· X’03’ – X’7F’ 由IANA分配· X’80’ – X’FE’ 为私人方法所保留的· X’FF’ 没有可以接受的方法 而我们接收到客服端信息后，判断是否和自己支持的版本是否一样，同时选择一个验证方式，如果没有则传输0xFF。 下面是node的代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 密码验证处理，后面会实现const passwordVerity = require(&apos;./password-verify.js&apos;);// 暂时只写了三个验证方式const AuthMethods = &#123; NOAUTH: 0, // 不需要验证 GSSAPI: 1, // GSSAPI验证 USERPASS: 2, // 用户名/密码 验证&#125;;function shakehand(chunk) &#123; let socket = this; const VERSION = parseInt(chunk[0], 10); // 客户端支持的认证方式的数量 const NMETHODS = parseInt(chunk[1], 10); // 判断客户端socks的版本 if (VERSION !== 5) &#123; socket.destroyed || socket.destroy(); return false; &#125; // 获取客户端支持的所有的类型 socket.methods = []; for (let i = 1; i &lt;= NMETHODS; i++) &#123; socket.methods.push(chunk[1 + i]); &#125; // 判断是否支持用户名/密码 验证 let isSupportPassrod = socket.methods.find(method =&gt; method === AuthMethods.USERPASS); // 如果不支持就返回 没有可以接受的方法 if (typeof isSupportPassrod === &apos;undefined&apos;) &#123; let res = new Buffer([VERSION, 0xFF]); socket.write(res); socket.destroyed || socket.destroy(); return false; &#125; // 返回版本和需要账号密码来验证 let res = new Buffer([VERSION, AuthMethods.USERPASS]); socket.write(res); // 监听下一次的数据，来进行账号密码来验证 socket.once(&apos;data&apos;, passwordVerity.bind(socket)); return false;&#125;module.exports = shakehand; sock5代理node实现(2)sock5代理node实现(3)","tags":[{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"},{"name":"socks","slug":"socks","permalink":"http://wangyuekai.com/tags/socks/"},{"name":"proxy","slug":"proxy","permalink":"http://wangyuekai.com/tags/proxy/"}]},{"title":"(转载)坦然面对：应对前端疲劳","date":"2017-07-16T13:37:57.000Z","path":"2017/07/16/not-an-imposter-fighting-front-end-fatigue/","text":"本文转载自：众成翻译译者：学会微笑审校: huangxiaolu链接：http://www.zcfy.cc/article/3509原文：https://www.smashingmagazine.com/2016/11/not-an-imposter-fighting-front-end-fatigue/ 我最近和一个做后端开发的朋友讨论我在工作之余花了多长的时间去写码和学习写码。他给我看了Uncle Bob的《Clean Code》这本书中的一段话，它将音乐家们为准备音乐会而花费的时间与开发者让代码正确执行所用的练习时间进行了比较。 我喜欢这个类比，但是我不认为我完全认同它；首先这种想法会导致疲劳。我认为如果你想进一步磨练你的技术并扩大你的技能集，那么这是很好的，但是要一天中每个小时都这样做是很难持续的。 前端疲劳是非常真实的。 我看到过一些关于JavaScript疲劳的文章，但我认为问题远不止于这种特定的语言。 先澄清一下，这篇文章不是在抱怨前端疲劳如何糟糕，以及技术发展太快—— 我喜欢技术迅速发展。同样的，我可以感受到它是如何的势不可挡，也会时不时地感觉自己要落伍了。 据我所知，这是一把双刃剑。 首先作为一个前端开发者，你认为你的技能树里应当有以下所有的技能: HTML (整洁代码，语义化标签) CSS (模块化，可伸缩) CSS 方法 (BEM, SMACSS, OOCSS) CSS 预处理器 (像LESS, SCSS, PostCSS) 现代 CSS (Flexbox, Grid) JS 现代 JS (ES6, Typescript) JS 框架 (Angular, React, Vue [更多的之后在此插入]） JS 方法 (函数式编程, 面向对象) JS 库 (Immutable, Ramda, Lodash) 响应式设计原则 测试 (TDD) 测试框架 (Jasmine, Karma) SVG WebGL 动画技术 可访问性 可用性 性能 构建工具 (Grunt, Gulp, NPM 脚本) 资源打包工具 (WebPack, Browserify) NPM 生态系统 了解不同浏览器的怪癖 敏捷方法 版本控制 (通常是 Git) 视觉设计基础 软技能，时间管理 对使用的后端语言有基本的了解。 此外，你还要涉足或展望这些技术： Service workers Progressive Web Apps (PWA) Web组件化 其次，你的日常工作可能不会完全覆盖这些技能，或者不会让你有时间去学所有技术，因此怎样才能在你的控制下去保证会所有的技能？ 开发人员听见“Progressive Web Apps” 这种术语可能会感到畏惧。新的方法和技巧导致疲劳感 —— 前端疲劳。 (图片来源) 现在作为这些技术的消费者，你可能要做的是： 订阅一打不同的开发者周刊简报 添加Twitter订阅 参加每周赶工作的前端团队 在工作之外有轻松的渠道能和一些开发者交流 按照网上的教程 (希望不是过时的) 使用视频课程培训网站像 Frontend Masters 买web开发的书 (希望不是过时的) 参加技术聚会 参加会议 参加培训课程 而作为一个贡献者，你可能要做的是： 写博客/杂志文章 演讲 直播 贡献开源项目 做自己的业余项目 最近我发现我的注意力被分散到三件事情上，我用三分之一的精力写着代码，同时戴着耳机一边听别人讨论代码，一边在Slack上跟别人聊代码。我决定适可而止——我的全部注意力都被代码所占据。我已经精疲力竭了。 虽然这肯定是极端情况，但我相信其他人也经历过类似的事情。最重要的是，你可能有一份全职工作，家庭，朋友，业余爱好。难怪我们中有那么多人感觉力不从心并且怀疑我们是否做了正确的职业选择。 我的一些前端同事都表示想要打包走人，然后换一个可以在五点结束的工作。但我认为前端工作仍旧吸引着某些的人，而如果放弃这份工作，成为一个房地产经纪人，你仍然想尽你的可能成为最好的房地产经纪人。在你的空闲时间你还是会参加房地产会议和跟踪房价趋势。很多个月以前，我在金融业工作，晚上我还在学习，阅读相关资料，想成为我所选择领域中技能最佳的人。 并不是只有这个领域需要付出巨大的精力，许多职业需要投入大量的精力并且在工作之外学习。也许前端开发的特殊之处在于技术发展得如此迅速，以至于好像有人一直在移动目标岗位。这就像每隔一天我就会收到一封电子邮件，上面写着“XYZ”技术已死。我确定这不是真的，否则我们就没有技术可用了。 生态系统处于不断变化的状态，我认为这是一件好事。就我个人而言，我喜欢扮演一个可以不断地学习、发展和督促自己的角色，但这并不是说我不会偶尔感到不知所措。 考虑到这一点，我尝试记住这些事情用来阻止我殚精竭虑，同时也有一些避免疲劳的通用建议。 我们是一样的我认识的开发者，无论是在工作中还是工作外，都是我认识的最聪明的人。但他们全都会感到不知所措。大多数人都有一些希望学习的技术清单。可能有少数人知道所有技术，而且在所有事情上都处于领先地位，但我们大多数人的处境完全相同。 我们仍然依赖Google和Stack Overflow来度过我们的一天，打开了超多的选项卡，全部是关于Web相关问题的答案。不止你一个人是这样！ 要高兴地知道你不是一个糟糕的开发人员，你只是还没有尝试过酷孩子们正在使用的东西。 是的，即使是“web名人”也有同样的困境… 你不可能知道所有的事情，而你在Twitter上追随的明星开发者在小部分的领域中表现得非常好。你会注意到，他们出名的领域恰好是他们所熟知的领域。可能也会有例外，但他们和我们一样也只是个普通人。:) 冒充者综合征是真实的，我们都有我知道有有些优秀的前端开发人员不会申请职位，因为他们在不知道工作描述要求上的所有东西的情况下，就觉得自己是个骗子。引用其中一个： “我看到的90%的JDs，会让我感觉“啊，我太落后！” 。事实上，这让我很困扰，我想留在我现在的职位，试图赚更多的钱，只是因为这样让我觉得我已经“摆脱它”。” 事实上，大部分的工作说明都是闹剧。我的朋友Bård把这些说明放在一张大的图片，来展示出前端工作要求和它们的真正含义之间的区别。 招聘广告的解释 (图片来源) (图片来源) 只要记住，会变好的。我所做的每一项工作，我都觉得自己不够深入，但最终你会习惯他们的工具和工作流程，你会学习并成为一个更好的开发人员。 不要害怕在工作中学习，掌握新技能的最佳方法是每天使用它们。 如果你有冒充者综合征，可能你是个正派的开发者，否则你就不会自觉地意识到它。 巩固基础人们很容易被耀眼的新事物分心，但是如果你的基础还不牢固，那么你所建造的东西将经受不住时间的考验。 就像我的一个好朋友曾经对我说的： “专注于基础一直是我的口头禅。你能建立良好的项目（SH！T）和解决问题，这才是最重要的，而你如何解决它们（所使用的工具）已经并将永远改变。” 例如，当react一跃成名，它似乎总是和ES6捆绑在一起，我把重点放在语言的那些改变和新特性上而不是框架本身的细微差别。一旦react不火了，我从最新的JavaScript上学到的知识将继续存在下去。你可以在原生chrome玩很多特性，而不用引入Babel陷入依赖地狱。 不用学所有的这真的很关键。我认为正在扼杀我们的不是新框架、库和模块，而是我们自己必须把它们全部学会的信念。 通过学习我发现最好的办法是专注——此刻我正在钻研ES6中的JavaScript函数式编程。 我的清单上还有很多我想学的东西，但我尽量不分心。例如，我喜欢温习我会的知识，玩Polymer，钻研一些最新的CSS技术，比如Grid，但是如果我一次开始阅读太多不同的领域，我得不到所有的信息。这些别的东西哪儿也去不了，再次看到的时候就能联想到他们。 避免在某一主题上匆忙尝试使用一切。 慢慢来，确保你完全理解它。 如果你像我一样，你会有一个不断增长的清单，但不要害怕从中剔除项目。并不是所有的事情都值得投入时间，你应该试着去认识哪些是值得学习的，哪些可能在几年内消失。花时间来学习编程的设计模式和架构技术，相比于投入在当前火的框架，在长远上来看，总是更有益的。脱离成长轨迹，过不了多久你就会迷失在追逐玩流行语的过程中。 大多数公司没有使用尖端技术现在有很多新的东西出现，web正在以惊人的速度发展，但通常企业真正在业务中开始采用这些新技术，需要很长的时间。大多数公司会等一段时间待技术成熟，并看到它在领域中被认可。 Angular 是六年前创建的，我刚开始在一家初创公司工作，他认为这是三年前的框架。Reactjs 已经有大约三年的历史了，我现在的公司仅在今年圣诞节前才开始使用它。我确信有很多其他的框架在同一时间出现或者消失。如果所有的我都要去研究，我会发疯的。 在CSS领域，flexbox在2010年就可以用了——六年前！但是浏览器到现在支持仍然有限。我们今年早些时候开始在生产环境中使用它，而且我也不认为它在其他地方被广泛使用。 我的意思是，不必急于学习所有的东西，虽然技术可能会很快发展，但你的潜在雇主正在以较慢的速度前进。你不必走在曲线的前面，只是要确保你在观察它的轨迹。 你学的越多，你会发现你不知道的也越来越多，这没关系这是完全正常的。当你刚开始的时候，你不知道你不知道什么。然后你会学习一些东西并且认为你是一个天才。然后，渐渐地，这种幻觉被打破，你开始理解事实上在这之外你有多少东西不知道。 从本质上说，你得到的经验越多，你进入的空虚就越深。你需要跟这个和平相处，否则它会消耗你。如果有的话，这种感觉会让你相信你正朝着正确的方向前进。在我们选择的职业中，你永远不会舒舒服服地学会所有前端知识。 不要把你所有的业余时间都花在学习上你很容易就感觉到你远远落后，需要每分钟都去编码和学习。这是一张通往职业疲倦的单程票。留一些时间来发展你的技能，看看你是否可以与你的老板协商一些时间来保证你的学习时间，然后用剩下的时间来做你爱做的事。 我已经分出一点写代码的时间在健身房。锻炼对你的身心都是极其重要的。尝试每天至少做20到30分钟，可以保持头脑清醒，防止疲劳。 给你的家人和朋友留出时间，尽量不要和他们谈工作！ 现在是开发者的市场目前不要担心找不到工作。此时我们正处于一个非常幸运的点，等待填充的岗位远比开发者要多。我不知道这将持续多久，但现在好好把握它！ 你可以在不知道所有技术的情况下得到一份工作。我发现，在我面试过的人中，99%的人完全是在吹牛。 最坏的情况，记住遗留代码中有黄金。如果你是一个喜欢老方式的开发人员，总是会有一些公司依赖于传统技术，需要开发人员在他们的软件上工作。 结论我希望其中的一些点有助于减轻你可能感到的一些挫折。你能做的最糟糕的事就是到达边缘，完全被烧尽，因为一旦你这样，很难恢复你对你所做的事情的热情，以及你这么做的初衷。 撸码愉快！ (aa, il)","tags":[{"name":"前端","slug":"前端","permalink":"http://wangyuekai.com/tags/前端/"}]},{"title":"让你备受刮目相看的8个npm技巧","date":"2017-07-06T02:56:33.000Z","path":"2017/07/06/npm-skills/","text":"本文转载自：众成翻译译者：liuhui_is_me链接：http://www.zcfy.cc/article/3362原文：https://medium.freecodecamp.com/8-npm-tricks-you-can-use-to-impress-your-colleagues-dbdae1ef5f9e 你观看一个同事编码时候，你会看到一些速记和技巧被应用，有些方式你并不熟悉，那你就被鄙视了，这种事情在我们每一个一生都会发生的。 在这篇文章中，我将介绍一些很有用的npm技巧，还有很多这里并不能全收录，我们只关注那些相关的并且有益于我们每天的工作和开发的技巧。 基本的速记为了让大家的对npm有一个一致的理解，尤其是我们的新人，让我们快速了解基本的速记和确保没有错过任何细节。 安装安装包常规: npm install pkg, 速记: npm i pkg. 全局安装包:常规: npm i --global pkg, 速记: npm i -g pkg. 安装包并包含在依赖中:常规: npm i --save pkg, 速记: npm i -S pkg. 安装包并包含在开发依赖中:常规: npm i --save-dev pkg, 速记: npm i -D pkg. 其他的npm速记阅读npm博客 速记表. 下面开始有趣的内容。 1. 初始化一个新包我们都知道npm init，用来创建一个新的包。 但是，所有的问题都是匿名的，我们无论如何都会修改它的，那么怎么避免发生呢？ 使用npm init -y 和 npm init -f回到初始化！ 2. 运行测试命令另一个命令就是npm test,我们可能每天使用依次或者一天使用好几次。 如果我告诉你可以使用少于40%的字符去完成这个功能？我们经常使用，应该这样。 幸运的是，我们可以使用npm t，它就可以胜任 3. 枚举可用的脚本我们开始一个新项目，我们想知道如何开始。我们通常会问自己这样的问题：我们如何运行它？哪些脚本可用？ 一个方法是打开package.json文件并检查scripts部分。 我们可以做的更好，当然，我们只是运行npm run得到一个的所有可用的脚本的列表。 另外的可以选择是安装ntl (npm i -g ntl)，然后运行ntl在项目文件夹中。它也可以运行脚本，也很方面。 4. 枚举已经安装的包类似于可用的脚本，有时我们会问自己我们的项目中有哪些依赖项。 我们可以再次打开package.json文件和检查，但是我们已经做的更好了。 使用 npm ls --depth 0. 枚举全局安装包，使用npm ls -g --depth 0 5. 运行本地安装的可执行文件我们安装了一个包在我们的项目中，它是一个可执行的，但我们只能运行它通过一个新的脚本。你想知道为什么，或者如何克服它？ 首先，让我们了解为什么——当我们在终端中执行命令时，实际发生的是它在PATH环境变量中列出的所有路径中查找一个具有相同名称的可执行文件。这就是他们如何神奇地从任何地方都可以执行。本地安装的软件包登记他们的可执行文件在本地，所以他们不在我们的PATH路径中将不会被发现。 当我们运行这些可执行文件通过一个新脚本，它是如何工作的呢？你可能会问？很好的问题！这是因为这种方式运行时，NPM做了一点技巧和增加了一个额外的文件夹到PATH，/node_modules/.bin中。你可以看到它的运行npm run env | grep &quot;$PATH&quot;。你也可以运行只是npm run env 查看所有可用的环境变量，npm增加了一些更有趣的东西。/node_modules/.bin，如果你不知道，正是在本地安装的软件包放置可执行文件的地方。 我们可以运行 ./node_modules/.bin/mocha 在我们的项目中，看看将会发生什么. 很简单, 对吧? 仅仅运行 ./node_modules/.bin/ ，无论什么时候你想要运行本地已安装的可执行文件。 6. 在网上查找你想要的包你可能看到了repository这个入口在package.json文件中，疑问“这有什么好处？” 为了问答这个问题，仅仅运行npm repo然后在你的浏览器中查看。 与之类似,npm home命令进入主页。 如果你想打开你的包的主页npmjs.com，那是一个不错的速记，npm docs。 7. 在其他脚本前后运行脚本您可能熟悉诸如pretest之类的脚本，它允许您定义在test脚本之前运行的代码。 您可能会惊讶地发现，您可以为每个脚本配置或有或后的脚本，包括您自己的自定义脚本！ 对于项目中，你使用NPM作为您的构建工具，有很多脚本，你需要自己总结使用。 8. 修改包的版本你开发一个安装包，你使用semver作为版本管理工具，修改一个新版本。 通过这种方式，你需要手动的修改package.json文件，我们不推荐这样做。 更容易的方式是运行npm version 通过 major, minor 或者 patch 这就是这期的所有。 我希望你学到新的东西，发现在这些技巧用，并在你的日常工作流程中使用。最好的就是你对npm有一个新的了解，在你的工作中更好的使用它。 给同事留下深刻印象是很好的，但是不断学习新事物并且更专业更好！ 如果你知道更多有用的技巧，请在评论中分享！","tags":[{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"}]},{"title":"ES6展开运算符（扩展运算符）的使用技巧","date":"2017-07-04T09:04:20.000Z","path":"2017/07/04/es6-spread-syntax/","text":"在ES6中，我们有了一个新的运算符–展开运算符，它可以使我们的代码的数量有一定的减少，有时候甚至有很有用的作用，我们来举几个常用的例子，同时通过例子来了解展开运算符的使用。1.apply中的使用 当我们的函数有多个变量的时候（特别是当我们不知道变量的数量的时候），有时候会通过将变量保存在数组中，并通过call来执行函数，有了展开运算符后则有了更好的方式（毕竟使用call需要手动指定this，有时候会不是很方便很准确） 1234567// 一般function a(x, y, z) &#123; &#125;var args = [0, 1, 2];a.call(null, args);// 展开运算符a(...args); 除此之外还可以 1234567// 需要传入不定数量的参数，同时最后一个参数为需要指定的值function b() &#123; console.log(arguments.length); console.log(arguments[arguments.length -1]);&#125;var args = [0, 1, 2];b(...args, -2) 总的来说，使多参数的函数调用有了新的方式, 而且避免的作用域的问题。 2.数组中的使用 数组的合并 12var a = [1, 2];var b = [0, ...a, 3] 数组的分割 12var [a, ...b] = [0, 1, 2];console.log(b) // [1, 2] 数组的拷贝 12var a = [1, 2];var b = [...a]; 3.对象中的使用这里的对象是指类似{a:1}这样的对象，因为数组，函数也是对象中的一种。 12let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;console.log(z) // &#123;a: 3, b: 4&#125; 这个在函数的参数中也有很好的用处 12345function test(...args) &#123; console.log(args);&#125;test(&apos;wang&apos;, &apos;23&apos;, &apos;man&apos;); 可能会有人说arguments本身就可以啊，但是arguments本身并不是数组，所以无法直接对arguments进行数组操作。 类外，在Node中有很多的回调函数都是以error为第一返回值，其实很多接口都是那么设计的。那么我们可以很方便的分离error和其他参数 1234request.get(&apos;./demo&apos;, (e, ...data) =&gt; &#123; console.log(e); console.log(data);&#125;) 不过现在的ES6中还不支持在对象中使用扩展运算符，这个还在ES7的草案中，不过我们可以使用babel来处理。 最后写一个例子吧，在github上有这个一个库https://github.com/sindresorhus/pify用于将回调的函数改为promise形式 123456789101112131415161718192021const fs = require(&apos;fs&apos;);const pify = function(fn) &#123; return function(...args) &#123; return new Promise((resolve) =&gt; &#123; fn(...args, (...res) =&gt; &#123; resolve(res); &#125;) &#125;) &#125;&#125;;// fs.readFilepify(fs.readFile)(&apos;./package.json&apos;, &apos;utf8&apos;).then(([err, data]) =&gt; &#123; console.log(data);&#125;)// ajaxpify(request)(&apos;http://demo.api.com&apos;).then(([err, data]) =&gt; &#123; console.log(data)&#125;)","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"js数组去重","date":"2017-06-09T07:04:16.000Z","path":"2017/06/09/js-array-remove-duplication/","text":"数组的去重在日常的开发中经常碰到的需求，虽然我们真实开发过程中会有lodash，Jquery等框架帮助我们。但是，很多时候我们也需要自己来实现这个简单的功能 框架12345678910var arr = [1, 2, 3, 4, 5, 5, 5, 5];// Jquery$.unique(arr);// lodash_.uniq(arr);// underscore_.uniq(arr); 方法-1234567var arr = [1, 2, 3, 4, 5, 5, 5, 5];var res = [];arr.forEach((d) =&gt; &#123; if(res.indexOf(d) === -1) &#123; res.push(d) &#125;&#125;); 方法二1234var arr = [1, 2, 3, 4, 5, 5, 5, 5];var res = arr.filter((d, i) =&gt; &#123; return arr.indexOf(d) === i;&#125;) 方法三如果你的数组里面都是字符串类型，那么可以使用对象KEY的唯一性来实现数组的去重 123456var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos; , &apos;a&apos;, &apos;c&apos;, &apos;d&apos;];var resObject = &#123;&#125;;arr.forEach((d) =&gt; &#123; resObject[d] = (resObject[d] || 1) + 1;&#125;);var res = Object.keys(resObject); 因为Object的键值必须要是字符串，所以当数组里面有数字，undefined，bool等类型时，就没有作用了，但是这个方法不但可以对字符串数组去重，同时也可以统计每个字符串出现的次数 方法四当我们在往数组里面push的时候，如果数组本身就可以保持不重复就好了，在ES5中我们没有办法做到，但是在ES6中，我们有了一个新的数据结构Set set并不是一个新的数据类型，是属于js基本类型的Object类型下面的 关于set的说明MDN有如下说明 The Set object lets you store unique values of any type, whether primitive values or object references. 这正是我们需要的，而且set还可以根传入数组来初始化，而set也可以很方便的转回数组 12let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos; , &apos;a&apos;, &apos;c&apos;, &apos;d&apos;];let res = Array.from(new Set(arr));","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"node中require的循环使用","date":"2017-06-01T12:45:58.000Z","path":"2017/06/01/node-circular-require/","text":"我们在Node中可以通过require来很方便的引入一个模块，而且我们一直到require模块是一个同步的过程，那么当一个两个模块相互引用的时候，Node会如何处理呢？ 在Node的官方文档中我们看到了如下的描述 When main.js loads a.js, then a.js in turn loads b.js. At that point, b.js tries to load a.js. In order to prevent an infinite loop, an unfinished copy of the a.js exports object is returned to the b.js module. b.js then finishes loading, and its exports object is provided to the a.js module. 当 main.js 加载 a.js 时，a.js 又加载 b.js。 此时，b.js 会尝试去加载 a.js。 为了防止无限的循环，会返回一个 a.js 的 exports 对象的 未完成的副本 给 b.js 模块。 然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。 那么这里的副本指的是什么呢？ 我们通过下面这个例子输出exports 对象 a.js 123456const b = require(&apos;./b.js&apos;);console.log(b.name);console.log(b);exports.name = &apos;a.js&apos;;console.log(b.name); b.js 12345const a = require(&apos;./a.js&apos;);console.log(a.name);console.log(a);exports.name = &apos;b.js&apos;;console.log(a.name); 当我们执行node a.js的时候输出 12345undefined&#123;&#125;undefinedb.jsb.js 所以我们可以看到Node会按照require模块的顺序，倒序加载模块，如果当前模块中出现了还未加载过的且依赖于当前模块，则将需要的模块的exports 对象默认为{}(空对象)来防止循环加载的问题。","tags":[{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"}]},{"title":"js中递归导致的堆栈溢出","date":"2017-05-23T10:10:50.000Z","path":"2017/05/23/js-recursion-stackoverflow/","text":"在编程中递归是一个很常见的操作，但在js中使用递归很容易一不小心导致堆栈溢出，原因也很简单，是因为我们最常用的闭包，如下例子 12345678910111213function isEven (num) &#123; if (num === 0) &#123; return true; &#125; if (num === 1) &#123; return false; &#125; return isEven(Math.abs(num) - 2);&#125;isEven(100); 因为递归所以导致每一层的isEven函数都保留了之前所有层的函数空间","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"Lamp环境搭建(linux apache mysql php)","date":"2017-05-19T10:14:17.000Z","path":"2017/05/19/linux-install-lamp/","text":"From: https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-centos-6 About LAMPLAMP stack is a group of open source software used to get web servers up and running. The acronym stands for Linux, Apache, MySQL, and PHP. Since the server is already running CentOS, the linux part is taken care of. Here is how to install the rest. Set UpThe steps in this tutorial require the user on the virtual private server to have root privileges. You can see how to set that up in the Initial Server Setup Tutorial in steps 3 and 4. Step One—Install ApacheApache is a free open source software which runs over 50% of the world’s web servers. To install apache, open terminal and type in this command: sudo yum install httpd Once it installs, you can start apache running on your VPS: sudo service httpd start That’s it. To check if Apache is installed, direct your browser to your server’s IP address (eg. http://12.34.56.789). The page should display the words “It works!” like this. How to find your Server’s IP addressYou can run the following command to reveal your server’s IP address. ifconfig eth0 | grep inet | awk &apos;{ print $2 }&apos; Step Two—Install MySQLMySQL is a powerful database management system used for organizing and retrieving data on a virtual server To install MySQL, open terminal and type in these commands: sudo yum install mysql-server sudo service mysqld start During the installation, MySQL will ask you for your permission twice. After you say Yes to both, MySQL will install. Once it is done installing, you can set a root MySQL password: sudo /usr/bin/mysql_secure_installation The prompt will ask you for your current root password. Since you just installed MySQL, you most likely won’t have one, so leave it blank by pressing enter. Enter current password for root (enter for none): OK, successfully used password, moving on... Then the prompt will ask you if you want to set a root password. Go ahead and choose Y and follow the instructions. CentOS automates the process of setting up MySQL, asking you a series of yes or no questions. It’s easiest just to say Yes to all the options. At the end, MySQL will reload and implement the new changes. By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? [Y/n] y ... Success! Normally, root should only be allowed to connect from &apos;localhost&apos;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? [Y/n] y ... Success! By default, MySQL comes with a database named &apos;test&apos; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success! Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? [Y/n] y ... Success! Cleaning up... All done! If you&apos;ve completed all of the above steps, your MySQL installation should now be secure. Thanks for using MySQL! Step Three—Install PHPPHP is an open source web scripting language that is widely used to build dynamic webpages. To install PHP on your virtual private server, open terminal and type in this command: sudo yum install php php-mysql Once you answer yes to the PHP prompt, PHP will be installed. PHP ModulesPHP also has a variety of useful libraries and modules that you can add onto your server. You can see the libraries that are available by typing: yum search php- Terminal then will display the list of possible modules. The beginning looks like this: php-bcmath.x86_64 : A module for PHP applications for using the bcmath library php-cli.x86_64 : Command-line interface for PHP php-common.x86_64 : Common files for PHP php-dba.x86_64 : A database abstraction layer module for PHP applications php-devel.x86_64 : Files needed for building PHP extensions php-embedded.x86_64 : PHP library for embedding in applications php-enchant.x86_64 : Human Language and Character Encoding Support php-gd.x86_64 : A module for PHP applications for using the gd graphics library php-imap.x86_64 : A module for PHP applications that use IMAP To see more details about what each module does, type the following command into terminal, replacing the name of the module with whatever library you want to learn about. yum info _name of the module_ Once you decide to install the module, type: sudo yum install _name of the module_ You can install multiple libraries at once by separating the name of each module with a space. Congratulations! You now have LAMP stack on your droplet! We should also set the processes to run automatically when the server boots (php will run automatically once Apache starts): sudo chkconfig httpd on sudo chkconfig mysqld on Step Four—RESULTS: See PHP on your ServerAlthough LAMP is installed on your virtual server, we can still take a look and see the components online by creating a quick php info page To set this up, first create a new file: sudo nano /var/www/html/info.php Add in the following line: &lt;?php phpinfo(); ?&gt; Then Save and Exit. Restart apache so that all of the changes take effect on your virtual server: sudo service httpd restart Finish up by visiting your php info page (make sure you replace the example ip address with your correct one): http://12.34.56.789/info.php It should look similar to this. See MoreAfter installing LAMP, you can go on to do more with MySQL (A Basic MySQL Tutorial), Create an SSL Certificate, or Install an FTP Server.","tags":[{"name":"linux","slug":"linux","permalink":"http://wangyuekai.com/tags/linux/"},{"name":"apache","slug":"apache","permalink":"http://wangyuekai.com/tags/apache/"},{"name":"mysql","slug":"mysql","permalink":"http://wangyuekai.com/tags/mysql/"},{"name":"php","slug":"php","permalink":"http://wangyuekai.com/tags/php/"}]},{"title":"转载一份清单：所有可以放进head标签的元素","date":"2017-05-18T14:05:34.000Z","path":"2017/05/18/head-element/","text":"本文转载自：众成翻译译者：msmailcode链接：http://www.zcfy.cc/article/2838原文：https://github.com/joshbuchea/HEAD?utm_source=statuscode&amp;utm_medium=medium HEAD可以在你文档的head标签中使用的所有内容的清单。 目录 Recommended Minimum Elements Meta Link Favicons Social Facebook Open Graph Facebook Instant Articles Twitter Cards Google+ / Schema.org OEmbed Browsers / Platforms Apple iOS Apple Safari Google Android Google Chrome Microsoft Internet Explorer Browsers (Chinese) 360 Browser QQ Mobile Browser UC Mobile Browser App Links Notes Performance Other Resources Related Projects Other Formats Translations Contributing Contributors Author License 推荐的最基本的下面是一个最简单的网站需要的最基本的标签。 12345&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;&lt;!-- 上面的三个标签 *必须* 在head标签的最前面；任何其他的标签必须在这三个标签的 *后面* --&gt;&lt;title&gt;Page Title&lt;/title&gt; Elements123456789101112131415161718&lt;!-- 文档标题 --&gt;&lt;title&gt;Page Title&lt;/title&gt;&lt;!-- 在文档中包含的所有相对 URL 的 Base URL --&gt;&lt;base href=&quot;https://example.com/page.html&quot;&gt;&lt;!-- 外部样式表 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;&lt;!-- 内部样式表 --&gt;&lt;style&gt; /* ... */&lt;/style&gt;&lt;!-- JavaScript --&gt;&lt;!-- JavaScript --&gt;``&lt;script src=&quot;script.js&quot;&gt;``&lt;/script&gt;&lt;noscript&gt;&lt;!--脚本未被执行时的替代内容--&gt;&lt;/noscript&gt; Meta1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 设置文档的字符编码 --&gt;&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;&lt;!-- 上面的三个标签 *必须* 在head标签的最前面；任何其他的标签必须在这三个标签的 *后面* --&gt;&lt;!-- 允许控制资源从何处加载 --&gt;&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;&quot;&gt;&lt;!-- 尽可能早的在文档中放置 --&gt;&lt;!-- 仅适用于此标签后的内容 --&gt;&lt;!-- Web应用程序名称（仅当网站作为应用程序时使用） --&gt;&lt;meta name=&quot;application-name&quot; content=&quot;Application Name&quot;&gt;&lt;!-- 页面的简短描述（限制为150个字符） --&gt;&lt;!-- 在 *部分* 情况下，这个描述被用作搜索结果中显示的片段的一部分。 --&gt;&lt;meta name=&quot;description&quot; content=&quot;A description of the page&quot;&gt;&lt;!-- 控制搜索引擎的抓取和索引行为 --&gt;&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;&lt;!-- All Search Engines --&gt;&lt;!-- 所有的搜索引擎 --&gt;&lt;meta name=&quot;googlebot&quot; content=&quot;index,follow&quot;&gt;&lt;!-- Google Specific --&gt;&lt;!-- 针对 Google --&gt;&lt;!-- 告诉 Google 不显示 [sitelinks](!https://en.wikipedia.org/wiki/Sitelink) 搜索框 --&gt;&lt;meta name=&quot;google&quot; content=&quot;nositelinkssearchbox&quot;&gt;&lt;!-- 告诉谷歌不要为这个页面提供翻译 --&gt;&lt;meta name=&quot;google&quot; content=&quot;notranslate&quot;&gt;&lt;!-- Google [Search Console](!https://developers.google.cn/webmaster-tools/) 身份验证 --&gt;&lt;meta name=&quot;google-site-verification&quot; content=&quot;verification_token&quot;&gt;&lt;!-- [Yandex Webmasters](!https://webmaster.yandex.com/) 身份验证 --&gt;&lt;meta name=&quot;yandex-verification&quot; content=&quot;verification_token&quot;&gt;&lt;!-- [Bing Webmaster Center](!https://www.bing.com/toolbox/webmaster/) 身份验证 --&gt;&lt;meta name=&quot;msvalidate.01&quot; content=&quot;verification_token&quot;&gt;&lt;!-- [Alexa Console](!http://www.alexa.com/) 身份验证 --&gt;&lt;meta name=&quot;alexaVerifyID&quot; content=&quot;verification_token&quot;&gt;&lt;!-- [Pinterest Console](!https://developers.pinterest.com) 身份验证 --&gt;&lt;meta name=&quot;p:domain_verify&quot; content=&quot;code from pinterest&quot;&gt;&lt;!-- [Norton Safe Web](!https://safeweb.norton.com/help/site_owners) 身份验证 --&gt;&lt;meta name=&quot;norton-safeweb-site-verification&quot; content=&quot;norton code&quot;&gt;&lt;!-- 用于命名构建网站的软件 (i.e. - WordPress, Dreamweaver) --&gt;&lt;meta name=&quot;generator&quot; content=&quot;program&quot;&gt;&lt;!-- 网站主题的简短描述 --&gt;&lt;meta name=&quot;subject&quot; content=&quot;your website&apos;s subject&quot;&gt;&lt;!-- 基于网站内容给出一般[年龄分级](!https://en.wikipedia.org/wiki/International_Age_Rating_Coalition) --&gt;&lt;meta name=&quot;rating&quot; content=&quot;General&quot;&gt;&lt;!-- 允许控制 referrer 信息如何传递 --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;!-- 禁用自动检测和格式化可能的电话号码 --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;&lt;!-- 通过设置为&quot;off&quot;完全关闭[ DNS 预读取](!https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching) --&gt;&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt;&lt;!-- 在客户端浏览器上存储cookie以进行用户识别 --&gt;&lt;meta http-equiv=&quot;set-cookie&quot; content=&quot;name=value; expires=date; path=url&quot;&gt;&lt;!-- 指定显示在特定框架中的页面 --&gt;&lt;meta http-equiv=&quot;Window-Target&quot; content=&quot;_value&quot;&gt;&lt;!-- 地理标签 --&gt;&lt;meta name=&quot;ICBM&quot; content=&quot;latitude, longitude&quot;&gt;&lt;meta name=&quot;geo.position&quot; content=&quot;latitude;longitude&quot;&gt;&lt;!-- 国家代码（ISO 3166-1）：强制性，州代码（ISO 3166-2）：可选；eg. content=&quot;US&quot; / content=&quot;US-NY&quot; --&gt;&lt;meta name=&quot;geo.placename&quot; content=&quot;city/town&quot;&gt;&lt;!-- eg. content=&quot;New York City&quot; --&gt; Google可以识别的meta标签 Meta扩展-WHATWG Wiki ICBM-维基百科 地理标签-维基百科 Link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!-- 指向一个CSS样式表 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://example.com/styles.css&quot;&gt;&lt;!-- 帮助解决内容重复收录 [Canonical link element](!https://en.wikipedia.org/wiki/Canonical_link_element) --&gt;&lt;link rel=&quot;canonical&quot; href=&quot;https://example.com/2010/06/9-things-to-do-before-entering-social-media.html&quot;&gt;&lt;!-- 之前用于包含 icon 链接，但已被废弃不再使用 --&gt;&lt;link rel=&quot;shortlink&quot; href=&quot;https://example.com/?p=42&quot;&gt;&lt;!-- 链接到当前文档的 [AMP HTML](!https://www.ampproject.org/) 版本 --&gt;&lt;link rel=&quot;amphtml&quot; href=&quot;https://example.com/path/to/amp-version.html&quot;&gt;&lt;!-- 链接到为web应用程序指定“安装”凭证的JSON文件 --&gt;&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt;&lt;!-- 链接到文档的作者 --&gt;&lt;link rel=&quot;author&quot; href=&quot;humans.txt&quot;&gt;&lt;!-- 链接到适用于链接上下文的版权声明 --&gt;&lt;link rel=&quot;copyright&quot; href=&quot;copyright.html&quot;&gt;&lt;!-- 给出文档的另一种语言的替代版本 [a-simple-guide-to-using-rel-alternate-hreflang-x](!https://searchenginewatch.com/sew/how-to/2232347/a-simple-guide-to-using-rel-alternate-hreflang-x) --&gt;&lt;link rel=&quot;alternate&quot; href=&quot;https://es.example.com/&quot; hreflang=&quot;es&quot;&gt;&lt;!-- 提供了关于作者或其他人的信息 --&gt;&lt;link rel=&quot;me&quot; href=&quot;https://google.com/profiles/thenextweb&quot; type=&quot;text/html&quot;&gt;&lt;link rel=&quot;me&quot; href=&quot;mailto:name@example.com&quot;&gt;&lt;link rel=&quot;me&quot; href=&quot;sms:+15035550125&quot;&gt;&lt;!-- 描述历史记录、文件或其他资料的集合的文档的链接。 --&gt;&lt;link rel=&quot;archives&quot; href=&quot;https://example.com/archives/&quot;&gt;&lt;!-- 层次结构中的顶级资源的链接 --&gt;&lt;link rel=&quot;index&quot; href=&quot;https://example.com/&quot;&gt;&lt;!-- 给出一个自我参考 - 当文档有多个可能的参考时非常有用 --&gt;&lt;link rel=&quot;self&quot; type=&quot;application/atom+xml&quot; href=&quot;https://example.com/atomFeed.php?page=3&quot;&gt;&lt;!-- 分别是一个系列文档的第一个、下一个、前一个以及最后一个文档 --&gt;&lt;link rel=&quot;first&quot; href=&quot;https://example.com/atomFeed.php&quot;&gt;&lt;link rel=&quot;next&quot; href=&quot;https://example.com/atomFeed.php?page=4&quot;&gt;&lt;link rel=&quot;prev&quot; href=&quot;https://example.com/atomFeed.php?page=2&quot;&gt;&lt;link rel=&quot;last&quot; href=&quot;https://example.com/atomFeed.php?page=147&quot;&gt;&lt;!-- 使用第三方服务维护博客时使用 --&gt;&lt;link rel=&quot;EditURI&quot; href=&quot;https://example.com/xmlrpc.php?rsd&quot; type=&quot;application/rsd+xml&quot; title=&quot;RSD&quot;&gt;&lt;!-- 当另一个WordPress博客链接到你的WordPress博客或帖子时，生成一个自动评论 --&gt;&lt;link rel=&quot;pingback&quot; href=&quot;https://example.com/xmlrpc.php&quot;&gt;&lt;!-- 当你在自己的页面上链接到一个 url 时通知它 --&gt;&lt;link rel=&quot;webmention&quot; href=&quot;https://example.com/webmention&quot;&gt;&lt;!-- 加载一个外部的 HTML 文件到当前 HTML 文件中 --&gt;&lt;link rel=&quot;import&quot; href=&quot;/path/to/component.html&quot;&gt;&lt;!-- 打开搜索 --&gt;&lt;link rel=&quot;search&quot; href=&quot;/open-search.xml&quot; type=&quot;application/opensearchdescription+xml&quot; title=&quot;Search Title&quot;&gt;&lt;!-- Feeds网络订阅 --&gt;&lt;link rel=&quot;alternate&quot; href=&quot;https://feeds.feedburner.com/example&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot;&gt;&lt;link rel=&quot;alternate&quot; href=&quot;https://example.com/feed.atom&quot; type=&quot;application/atom+xml&quot; title=&quot;Atom 0.3&quot;&gt;&lt;!-- 预读取，预加载，预浏览 --&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com/&quot;&gt;&lt;link rel=&quot;preconnect&quot; href=&quot;https://www.example.com/&quot;&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;https://www.example.com/&quot;&gt;&lt;link rel=&quot;prerender&quot; href=&quot;https://example.com/&quot;&gt;&lt;link rel=&quot;preload&quot; href=&quot;image.png&quot; as=&quot;image&quot;&gt;&lt;!-- 更多信息: https://css-tricks.com/prefetching-preloading-prebrowsing/ --&gt; Favicons1234567&lt;!-- IE 10 及以下版本 --&gt;&lt;!-- 将 favicon.ico 放在网站根目录中 - 不需要 link 标签 --&gt;&lt;!-- IE 11, Chrome, Firefox, Safari, Opera --&gt;&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=&quot;/path/to/favicon-16x16.png&quot;&gt;&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;/path/to/favicon-32x32.png&quot;&gt;&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;96x96&quot; href=&quot;/path/to/favicon-96x96.png&quot;&gt; 关于 Favicons (和 Touch Icons) Favicon 对照表 Social 社交媒体Facebook Open Graph123456789&lt;meta property=&quot;fb:app_id&quot; content=&quot;123456789&quot;&gt;&lt;meta property=&quot;og:url&quot; content=&quot;https://example.com/page.html&quot;&gt;&lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt;&lt;meta property=&quot;og:title&quot; content=&quot;Content Title&quot;&gt;&lt;meta property=&quot;og:image&quot; content=&quot;https://example.com/image.jpg&quot;&gt;&lt;meta property=&quot;og:description&quot; content=&quot;Description Here&quot;&gt;&lt;meta property=&quot;og:site_name&quot; content=&quot;Site Name&quot;&gt;&lt;meta property=&quot;og:locale&quot; content=&quot;en_US&quot;&gt;&lt;meta property=&quot;article:author&quot; content=&quot;&quot;&gt; Facebook Open Graph Markup Open Graph protocol Facebook Instant Articles12345678&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta property=&quot;op:markup_version&quot; content=&quot;v1.0&quot;&gt;&lt;!-- 你的文章的 Web 版本的 URL --&gt;&lt;link rel=&quot;canonical&quot; href=&quot;http://example.com/article.html&quot;&gt;&lt;!-- 本文使用的样式 --&gt;&lt;meta property=&quot;fb:article_style&quot; content=&quot;myarticlestyle&quot;&gt; Facebook Instant Articles: Creating Articles Instant Articles: Format Reference Twitter Cards1234567&lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot;&gt;&lt;meta name=&quot;twitter:site&quot; content=&quot;@site_account&quot;&gt;&lt;meta name=&quot;twitter:creator&quot; content=&quot;@individual_account&quot;&gt;&lt;meta name=&quot;twitter:url&quot; content=&quot;https://example.com/page.html&quot;&gt;&lt;meta name=&quot;twitter:title&quot; content=&quot;Content Title&quot;&gt;&lt;meta name=&quot;twitter:description&quot; content=&quot;Content description less than 200 characters&quot;&gt;&lt;meta name=&quot;twitter:image&quot; content=&quot;https://example.com/image.jpg&quot;&gt; Twitter Cards: Getting Started Guide Twitter Card Validator Google+ / Schema.org1234&lt;link href=&quot;https://plus.google.com/+YourPage&quot; rel=&quot;publisher&quot;&gt;&lt;meta itemprop=&quot;name&quot; content=&quot;Content Title&quot;&gt;&lt;meta itemprop=&quot;description&quot; content=&quot;Content description less than 200 characters&quot;&gt;&lt;meta itemprop=&quot;image&quot; content=&quot;https://example.com/image.jpg&quot;&gt; PinterestPinterest 让你阻止用户从你的网站上保存东西，查看 help center。 description 是可选的 1&lt;meta name=&quot;pinterest&quot; content=&quot;nopin&quot; description=&quot;Sorry, you can&apos;t save from my website!&quot;&gt; OEmbed123456&lt;link rel=&quot;alternate&quot; type=&quot;application/json+oembed&quot; href=&quot;http://example.com/services/oembed?url=http%3A%2F%2Fexample.com%2Ffoo%2F&amp;format=json&quot; title=&quot;oEmbed Profile: JSON&quot;&gt;&lt;link rel=&quot;alternate&quot; type=&quot;text/xml+oembed&quot; href=&quot;http://example.com/services/oembed?url=http%3A%2F%2Fexample.com%2Ffoo%2F&amp;format=xml&quot; title=&quot;oEmbed Profile: XML&quot;&gt; oEmbed format Browsers浏览器 / Platforms平台Apple iOS1234567891011121314151617181920212223&lt;!-- Smart App Banner 智能 App 广告条 --&gt;&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=APP_ID,affiliate-data=AFFILIATE_ID,app-argument=SOME_TEXT&quot;&gt;&lt;!-- 禁止数字自动识别为电话号码 --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;&lt;!-- Add to Home Screen 添加到主屏幕 --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;App Title&quot;&gt;&lt;!-- Touch Icons --&gt;&lt;!-- 在大多数情况下，在head中一个180×180px的图标就足够了。 --&gt;&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/path/to/apple-touch-icon.png&quot;&gt;&lt;!-- 注意: iOS 7 的 Safari 不为图标添加效果。 --&gt;&lt;!-- 旧版本 Safari 不会为后缀名为 -precomposed.png 的 icon 文件添加效果 --&gt;&lt;!-- 启动画面 ( 弃用 ) --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/path/to/startup.png&quot;&gt;&lt;!-- iOS 应用深度链接 --&gt;&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=APP-ID, app-argument=http/url-sample.com&quot;&gt;&lt;link rel=&quot;alternate&quot; href=&quot;ios-app://APP-ID/http/url-sample.com&quot;&gt; Apple Meta Tags Apple Safari12&lt;!-- 固定书签页 --&gt;&lt;link rel=&quot;mask-icon&quot; href=&quot;/path/to/icon.svg&quot; color=&quot;red&quot;&gt; Google Android123456789&lt;meta name=&quot;theme-color&quot; content=&quot;#E64545&quot;&gt;&lt;!-- 添加到主屏幕 --&gt;&lt;meta name=&quot;mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;&lt;!-- 更多信息: https://developer.chrome.com/multidevice/android/installtohomescreen --&gt;&lt;!-- Android 应用深度链接 --&gt;&lt;meta name=&quot;google-play-app&quot; content=&quot;app-id=package-name&quot;&gt;&lt;link rel=&quot;alternate&quot; href=&quot;android-app://package-name/http/url-sample.com&quot;&gt; Google Chrome1234&lt;link rel=&quot;chrome-webstore-item&quot; href=&quot;https://chrome.google.com/webstore/detail/APP_ID&quot;&gt;&lt;!-- 禁用翻译提示 --&gt;&lt;meta name=&quot;google&quot; value=&quot;notranslate&quot;&gt; Google Chrome Mobile (只针对 Android)从 Chrome 31 开始, 你可以像 Safari 一样设置你的 Web 应用为“app mode” 。 123456789&lt;!-- 链接到一个 manifest 并定义 manifest 的元数据。 --&gt;&lt;!-- manifest.json的例子可以在下面的链接中找到。 --&gt;&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt;&lt;!-- 将你的网页定义为 Web 应用 --&gt;&lt;meta name=&quot;mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;&lt;!-- 主屏幕图标 --&gt;&lt;link rel=&quot;icon&quot; sizes=&quot;192x192&quot; href=&quot;highres-icon.png&quot;&gt; Google Developer Microsoft Internet Explorer123456789101112131415161718192021&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;meta name=&quot;skype_toolbar&quot; content=&quot;skype_toolbar_parser_compatible&quot;&gt;&lt;!-- IE10: 禁用点击时链接高亮 (https://blogs.windows.com/buildingapps/2012/11/15/adapting-your-webkit-optimized-site-for-internet-explorer-10/) --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;&lt;!-- 固定网页 (https://msdn.microsoft.com/en-us/library/dn255024(v=vs.85).aspx) --&gt;&lt;meta name=&quot;application-name&quot; content=&quot;Sample Title&quot;&gt;&lt;meta name=&quot;msapplication-tooltip&quot; content=&quot;A description of what this site does.&quot;&gt;&lt;meta name=&quot;msapplication-starturl&quot; content=&quot;http://example.com/index.html?pinned=true&quot;&gt;&lt;meta name=&quot;msapplication-navbutton-color&quot; content=&quot;#FF3300&quot;&gt;&lt;meta name=&quot;msapplication-window&quot; content=&quot;width=800;height=600&quot;&gt;&lt;meta name=&quot;msapplication-task&quot; content=&quot;name=Task 1;action-uri=http://host/Page1.html;icon-uri=http://host/icon1.ico&quot;&gt;&lt;meta name=&quot;msapplication-task&quot; content=&quot;name=Task 2;action-uri=http://microsoft.com/Page2.html;icon-uri=http://host/icon2.ico&quot;&gt;&lt;meta name=&quot;msapplication-badge&quot; value=&quot;frequency=NUMBER_IN_MINUTES;polling-uri=http://example.com/path/to/file.xml&quot;&gt;&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#FF3300&quot;&gt;&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;/path/to/tileimage.jpg&quot;&gt;&lt;meta name=&quot;msapplication-config&quot; content=&quot;http://example.com/browserconfig.xml&quot;&gt;&lt;meta name=&quot;msapplication-notification&quot; content=&quot;frequency=60;polling-uri=http://example.com/livetile;polling-uri2=http://example.com/livetile2&quot;&gt;&lt;meta name=&quot;msapplication-task-separator&quot; content=&quot;1&quot;&gt; App Links 应用关联1234567891011&lt;!-- iOS --&gt;&lt;meta property=&quot;al:ios:url&quot; content=&quot;applinks://docs&quot;&gt;&lt;meta property=&quot;al:ios:app_store_id&quot; content=&quot;12345&quot;&gt;&lt;meta property=&quot;al:ios:app_name&quot; content=&quot;App Links&quot;&gt;&lt;!-- Android --&gt;&lt;meta property=&quot;al:android:url&quot; content=&quot;applinks://docs&quot;&gt;&lt;meta property=&quot;al:android:app_name&quot; content=&quot;App Links&quot;&gt;&lt;meta property=&quot;al:android:package&quot; content=&quot;org.applinks&quot;&gt;&lt;!-- Web Fallback Web替代显示资源文件 --&gt;&lt;meta property=&quot;al:web:url&quot; content=&quot;http://applinks.org/documentation&quot;&gt;&lt;!-- 更多信息: http://applinks.org/documentation/ --&gt; App Links Docs Browsers (Chinese)360 浏览器12&lt;!-- [按指定顺序选择渲染引擎](!http://se.360.cn/v6/help/meta.html) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt; QQ 手机浏览器123456&lt;!-- 将屏幕锁定为指定方向 竖屏/横屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;landscape/portrait&quot;&gt;&lt;!-- 设置页面全屏显示 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- 开启网页应用模式 (全屏,etc.) --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; QQ手机浏览器 UC 手机浏览器1234567891011121314&lt;!-- 强制页面横屏/竖屏显示 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;landscape/portrait&quot;&gt;&lt;!-- 设置页面全屏显示 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- 即使是无图模式UC浏览器仍会显示图片 --&gt;&lt;meta name=&quot;imagemode&quot; content=&quot;force&quot;&gt;&lt;!-- 调用应用模式(全屏,禁止手势, etc.) --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- 禁用 UC浏览器的夜间模式 --&gt;&lt;meta name=&quot;nightmode&quot; content=&quot;disable&quot;&gt;&lt;!-- 简化页面的处理，使得页面内容更适合进行页面阅读、节省流量及响应更快 --&gt;&lt;meta name=&quot;layoutmode&quot; content=&quot;fitscreen&quot;&gt;&lt;!-- 禁用UC浏览器的特性:“当页面文字多时，放大字体”。 --&gt;&lt;meta name=&quot;wap-font-scale&quot; content=&quot;no&quot;&gt; UC浏览器文档 最新版UC浏览器文档 注释性能Moving the href attribute to the beginning of an element improves compression when GZIP is enabled, because the href attribute is used in a, base and link tags.当启用 GZIP 时，将 href 属性移动到元素的开始可以提高压缩，因为 href 属性 在 a, base and link 标签中使用。 例子: 1&lt;link href=&quot;https://fonts.googleapis.com/css?family=Open+Sans:400,700&quot; rel=&quot;stylesheet&quot;&gt; 其它资源 HTML5 Boilerplate Docs: The HTML HTML5 Boilerplate Docs: Extend and customize 相关项目 Atom HTML Head Snippets - Atom package for HEAD snippets Sublime Text HTML Head Snippets - Sublime Text package for HEAD snippets head-it - CLI interface for HEAD snippets vue-head - Manipulating the meta information of the HEAD tag for Vue.js","tags":[{"name":"转载","slug":"转载","permalink":"http://wangyuekai.com/tags/转载/"},{"name":"html","slug":"html","permalink":"http://wangyuekai.com/tags/html/"}]},{"title":"Node.js EventEmitter 学习","date":"2017-05-17T12:35:05.000Z","path":"2017/05/17/events-learn/","text":"说起Node中几个最重要的模块，那么events模块一定在其中，在Node中很多很多的其他模块都是基于或者依赖于events模块。 那么我们来了解一下什么是events模块和events模块的使用，和一些注意点 我们参看的Node v6.10.3文档， 对于EventEmitter的方法我们不解释，相对比较简单，官方也给出了较多的例子，完全可以参看官方的文档，这里就说明一些注意点 EventEmitter实例化首先很多的教程里面会写以下的代码来实例化一个EventEmitter 12var events = require(&apos;events&apos;);var emitter = new events.EventEmitter(); 但是官方给出的例子却是 12345const EventEmitter = require(&apos;events&apos;);class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter(); 在REPL中输出const EventEmitter = require(&#39;events&#39;);中的EventEmitter 1234567EventEmitter&#123; [Function: EventEmitter] EventEmitter: [Circular], // 循环引用 usingDomains: true, defaultMaxListeners: [Getter/Setter], init: [Function], listenerCount: [Function] &#125; 同时在翻看源码之后看到 1234module.exports = EventEmitter;// Backwards-compat with node 0.10.xEventEmitter.EventEmitter = EventEmitter; 所以，两种方式都是可以的，但是感觉按照官方的方式会更好。 error事件当 EventEmitter 实例中发生错误时，会触发一个 ‘error’ 事件。 这在 Node.js 中是特殊情况。 如果 EventEmitter 没有为 ‘error’ 事件注册至少一个监听器，则当 ‘error’ 事件触发时，会抛出错误、打印堆栈跟踪、且退出 Node.js 进程。 123const myEmitter = new MyEmitter();myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;));// 抛出错误，并使 Node.js 奔溃 所以应该始终为 ‘error’ 事件注册监听器。123myEmitter.on(&apos;error&apos;, (err) =&gt; &#123; console.error(&apos;有错误&apos;);&#125;); 另外提一句为了防止 Node.js 进程崩溃，可以在 process 对象的 uncaughtException 事件上注册监听器。 1234567const myEmitter = new MyEmitter();process.on(&apos;uncaughtException&apos;, (err) =&gt; &#123; console.error(&apos;有错误&apos;);&#125;);myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;)); this作用域在ES6加入后，有了箭头函数，有时候会导致监听器的this作用域的不同，这里需要稍微注意一下 1234567891011const myEmitter = new MyEmitter();myEmitter.on(&apos;event&apos;, function(a, b) &#123; console.log(a, b, this); // 打印: // a b MyEmitter &#123; // domain: null, // _events: &#123; event: [Function] &#125;, // _eventsCount: 1, // _maxListeners: undefined &#125;&#125;);myEmitter.emit(&apos;event&apos;, &apos;a&apos;, &apos;b&apos;); 箭头函数版本123456const myEmitter = new MyEmitter();myEmitter.on(&apos;event&apos;, (a, b) =&gt; &#123; console.log(a, b, this); // 打印: a b &#123;&#125;&#125;);myEmitter.emit(&apos;event&apos;, &apos;a&apos;, &apos;b&apos;); 相信了解过箭头函数的原理的都应该可以理解。 on() 和 addListener() 的区别没有区别 1EventEmitter.prototype.on = EventEmitter.prototype.addListener;","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"}]},{"title":"word-wrap word-break 和 white-space","date":"2017-05-15T15:59:09.000Z","path":"2017/05/15/word-wrap-word-break-white-space/","text":"这三个在对于文本的换行与否和如何换行时，经常被使用，我们来仔细了解一下三个属性的内容。 white-space顾名思义就是“空格”,其实这个属性就是对于空格和换行符的控制 white-space:normal连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 在这里的换行生效了,但是换行后的空格也被合并了，所以每一行都是直接显示在在文本最前面 white-space:nowrap 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。 在这里的换行没有生效,换行后的空格也被合并了，所以每一行都是直接显示在在文本最前面（依旧会导致换行） white-space:pre连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素时才会换行。 换行生效了，且空格没有合并 #### white-space:pre-wrap 连续的空白符会被保留。在遇到换行符或者``元素，或者需要为了填充line盒子时才会换行。 white-space:pre-line连续的空白符会被合并。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时会换行。 换行符 空格和制表符 文字转行 normal 合并 合并 转行 nowrap 合并 合并 不转行 pre 保留 保留 不转行 pre-wrap 保留 保留 转行 pre-line 保留 合并 转行 word-wrap word-break首先我在MDN上并没有找到word-wrap，原来word-wrap属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”。 稳定的谷歌 Chrome 和 Opera 浏览器版本支持这种新语法。","tags":[{"name":"css","slug":"css","permalink":"http://wangyuekai.com/tags/css/"}]},{"title":"-转载-自定义组合字体","date":"2017-05-14T05:43:25.000Z","path":"2017/05/14/combining-fonts/","text":"本文转载自：众成翻译译者：为之漫笔链接：http://www.zcfy.cc/article/2767原文：https://jakearchibald.com/2017/combining-fonts/ 我喜欢字体Just Another Hand，我经常在我分享中的图示里用它： (字体转图片了。——译者注)问题在于，我不喜欢连字号和等号的字形…… (字体转图片了。——译者注) 它们的位置让人看着不舒服，位置太高了。 好在CSS支持合并字体，因而我可以创造一个类似于Just Another Hand的字体族，不同在于其中的连字符和等于号来自另一款字体： Architects Daughter。 (字体转图片了。——译者注) 怎么做到像往常一样定义@font-face： @font-face { font-family: &apos;Just Another Hand Fixed&apos;; font-style: normal; font-weight: 400; src: local(&apos;Just Another Hand&apos;), local(&apos;JustAnotherHand-Regular&apos;), url(&apos;https://fonts.gstatic.com/…woff2&apos;) format(&apos;woff2&apos;), url(&apos;https://fonts.gstatic.com/…woff&apos;) format(&apos;woff&apos;); } 然后再添加一个同名的@font-face，只加入连号和等于号： @font-face { font-family: &apos;Just Another Hand Fixed&apos;; src: local(&apos;Architects Daughter&apos;), local(&apos;ArchitectsDaughter&apos;), url(&apos;https://fonts.gstatic.com/l/…&apos;) format(&apos;woff2&apos;), url(&apos;https://fonts.gstatic.com/l/…&apos;) format(&apos;woff&apos;); unicode-range: U+2d, U+3d; } 关键是unicode-range描述符。它指定上面的src只能用于连字号（U+2d）和等于号（U+3d）的码点。用以下方式可以把Unicode字符转换为码点： &apos;=&apos;.codePointAt(0).toString(16); // &quot;3d&quot; 我还使用了Google fonts’ text parameter取得“Architects Daughter”字体的子集，其中只包含连字号和等于号，把体积减至最小。woff2版只有500字节，不错！ 这样就行了。然后就可以这样用： .whatever { font-family: &apos;Just Another Hand Fixed&apos;; } ……此时用的就是组合后的字体了！ 更新：不需要用unicode-rangle吗？Twitter和评论中有几位朋友说，不需要unicode-range，只要这样即可： /* Subsetted font */ @font-face { font-family: &apos;Just Another Hand Fixed&apos;; src: url(&apos;https://fonts.gstatic.com/l/…&apos;) format(&apos;woff2&apos;) …; } /* Main font */ @font-face { font-family: &apos;Just Another Hand Fixed&apos;; src: url(&apos;https://fonts.gstatic.com/…woff2&apos;) format(&apos;woff2&apos;) …; } 表面上可行，但性能不好。 万一浏览器先下载了子集化的字体（Subsetted font），发现这个字体缺少它需要的字形，就会下载主字体（Main font）。字体是一个一个下载。 Live demo.Network waterfall. 而使用unicode-range，浏览器预先知道自己先需要什么，因此可以并行下载字体。 Live demo.Network waterfall. 而且，如果你根本没有用到子集化字体中字形，浏览器知道自己根本不用下载它！ Live demo.Network waterfall.","tags":[{"name":"css","slug":"css","permalink":"http://wangyuekai.com/tags/css/"}]},{"title":"js浮点运算精度问题和IEEE754","date":"2017-05-14T05:34:37.000Z","path":"2017/05/14/ieee754-and-js-float-point-calculation/","text":"当我们使用一段时间的JS之后会遇到下面这个问题 10.1 + 0.2 === 0.3 // false 我们可以在控制台里面看到0.1+0.2输出的并不是0.3而是0.30000000000000004。那么为什么出现这样的问题呢。其实出现这样的问题在于js使用了IEEE754二进制浮点数算术标准，这个标准对于1/2, 1/4, 1/8等数字有很好的支持，其实这个标准也是现在大多数语言,CPU和浮点计算器选择的浮点数算术标准。 因为IEEE754是二进制的规则，所以可以看做用n*2^m这样的表示方式,这样的表达式在有限的存储空间下无法表示n*10^m类型数字，所以很简单的0.1无法被准确的表示。 但是类似Java等很多语言在底层会对浮点预算有处理，所以看上去好像没有遇到JS中的问题 有人认为， JavaScript 应该采用一种可以精确呈现数字的实现方式。 一直以 来出现过很多替代方案，只是都没能成为标准，以后大概也不会。这个问题 看似简单，实则不然，否则早就解决了。 为什么说在有限的存储空间下无法准确表示呢，那么让我们来了解一下IEEE754是如何来表示一个数字的吧。 关于IEEE754有单精度和双精度两种方式，两个方式的计算规则都是一样的，只是单精度使用32位来存储一个数字，而双精度使用64位来存储，只是用于存储的位数的大小。 关于IEEE754每位表示的意思，这里不详细说明，详细可以查看wiki IEEE 754 简单来说就是IEEE754对于数字的表达方式是1n = (-1)^s * 2^(e-127) * (1 + f) (右边为第0位)单精度 s : 第31位 e : 第30至23位 f : 第22指0位 单精度 s : 第63位 e : 第62至52位 f : 第51指0位 我们举一个例子来说明IEEE的表达方式 s e f 0 0111 1110 1100 0000 0000 0000 0000 000 在这里s = 0，e转为10进制是126， f中左数第一位表示 1 / 2^1,第二位表示1 / 2^2,依次类推，所以在这里f = 1 / 2^1 + 1 / 2^2 = 0.75; 所以 n = (-1)^0 * 2^(126-127) * (1+0.75) = 0.875; 倒过来，如果我们给到的数字是23.56，那么首先我们先用二进制表示这个数字，为10111.1000111101011100001,然后我们将小数点移到前面只有一位数字，这里我们左移了4位变成1.01111000111101011100001，然后除去第一位的01111000111101011100001填入22-0位，因为是正数，所以第31位为0，然后我们左移了4位，所以说明(e-127) = 4，所以e=131，转为二进制，所以第30至23位为1000 0011,从而得到了结果。 下面我们来看一下ieee754中那个无法准确表达的0.1。首先将0.1转为二进制，10进制转二进制可以在网上查到，在如果不考虑存储的话，应该是0.000110001100011…,可以看到是00011的无限循环，其实如果在存储长度没有限制的情况下，通过简单的计算我们可以看到这个无限循环就是等于0.1。 000011 = 3 2 / (1 / 2^4), 等式为 3 2 ( 1/2^4 + 1/2^8 … 1/2^4n)。通过等比数列运算 s = 3 2 (1/2^4) (1- (1/2^4)^n) / (1 - 1 /2^4) = 3 2 * 1 / 15 = 0.1 那么我们有什么办法可以在js中安全的使用浮点运算呢，可能说没有有完美的解决办法 但是还是有一些简单的处理办法。 对于计算，我们可以使用toFixed来处理toFixed是用来强制保留小数点后面的位数，可以用于大多数精度要求不是非常高的计算中 1(0.1 + 0.2).toFixed(2) // 0.30 最常见的方法是设置一个误差范围值， 通常称为“机器精度”（machine epsilon） ， 对JavaScript的数字来说，这个值通常是 2^-52 (2.220446049250313e-16) 。 从 ES6 开始， 该值定义在 Number.EPSILON中， 我们可以直接拿来用， 也可以为 ES6 之前 的版本写 polyﬁll： 123if (!Number.EPSILON) &#123; Number.EPSILON = Math.pow(2,-52);&#125; 可以使用 Number.EPSILON来比较两个数字是否相等（在指定的误差范围内）： 123456789function numbersCloseEnoughToEqual(n1,n2) &#123; return Math.abs( n1 - n2 ) &lt; Number.EPSILON;&#125;var a = 0.1 + 0.2;var b = 0.3;numbersCloseEnoughToEqual( a, b ); // truenumbersCloseEnoughToEqual( 0.0000001, 0.0000002 ); // false","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"for-timeout","date":"2017-05-13T02:44:12.000Z","path":"2017/05/13/for-timeout/","text":"最近在网上看到一篇关于for循环的面试题，可以让自己回顾一下作用域的基础知识。 不多说，题目如下: 下面的代码输出的是什么 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function()&#123; console.log(i) &#125;, 1000)&#125; 相信稍微了解过一些作用域相关知识的，都可以很快回答出，会打印出5个5，而且是在1s后同时打印出来。 其实这段代码相当于 123456var i = 0for (; i &lt; 5; i++) &#123; setTimeout(function()&#123; console.log(i) &#125;, 1000)&#125; 关键在于var创建了一个全局的变量，而不是一个for循环内的块作用域内的变量。 那么我们要怎么修改让输出改为每隔1s输出，且输出0-4呢。 既然块作用域解决不了我们的问题，那么我们可以创建一个函数作用域来保存我们的变量，创建一个函数作用域，很明显需要一个函数 123456789function timeOutPrint(i) &#123; setTimeout(function()&#123; console.log(i) &#125;, 1000 * i)&#125;for (var i = 0; i &lt; 5; i++) &#123; timeOutPrint(i);&#125; 当然我们也可以使用IIFE 1234567for (var i = 0; i &lt; 5; i++) &#123; (function(i)&#123; setTimeout(function()&#123; console.log(i) &#125;, 1000 * i) &#125;)(i)&#125; 不过从代码的角度来说上面将函数封装起来可以更加便于阅读 我们换一个角度去看这个问题，其实我们是出现了一个异步的代码，那么处理异步的其中一个方法就是使用promise。 1234567891011121314151617function timeOutPrint(i) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) resolve(); &#125;, i * 1000); &#125;);&#125;var tasks = [];for (var i = 0; i &lt; 5; i++) &#123; tasks.push(timeOutPrint(i));&#125;Promise.all(tasks).then(()=&gt;&#123; console.log(&apos;end&apos;);&#125;) 我们换一个角度，其实当我们一开始写这段代码，心里其实是希望，for循环可以暂停，然后隔1s进入下一个循环，那么如果按照这个思路去改写呢 使用promise可以解决这个问题，但是因为js的事件循环，会导致Promise.resolve也会在for循环之后执行，所以不可以直接传入i，这个用了resolve传值得办法 123456789101112131415function timeOutPrint(i) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) resolve(i); &#125;, 1000); &#125;);&#125;var state = Promise.resolve(-1);for (var i = 0; i &lt; 5; i++) &#123; state = state.then((value) =&gt; &#123; return timeOutPrint(++value); &#125;)&#125; 其实如果使用let就可以有比较好的效果12345678910111213141516function timeOutPrint(i) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) resolve(i); &#125;, 1000); &#125;);&#125;var state = Promise.resolve(true);for (var i = 0; i &lt; 5; i++) &#123; let j = i; state = state.then(() =&gt; &#123; return timeOutPrint(j); &#125;)&#125; 这里我们看到了let的使用，后面我们会再次用到这个ES6的语法。 我们通过生成一系列顺序执行的Promise来实现，但是并没有真正的使for循环中断，而使代码中断的语法则可以使用ES6中的Generator和yield。 12345678910111213141516171819202122232425262728293031323334353637383940function isPromise(obj) &#123; return &apos;function&apos; == typeof obj.then;&#125;var loop = function(gen) &#123; var g = gen(); var run = function() &#123; console.log(g); var r = g.next(); if(r.done) &#123; return; &#125; if(isPromise(r.value)) &#123; r.value.then(()=&gt; &#123; run(g); &#125;) &#125; else &#123; run(g); &#125; &#125;; run();&#125;function timeOutPrint(i) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) resolve(i); &#125;, 1000); &#125;);&#125;function *main() &#123; for (var i = 0; i &lt; 5; i++) &#123; yield timeOutPrint(i); &#125;&#125;loop(main); 这里我们写了一个简单的Generator的执行函数loop。 Generator可以很好的实现代码暂停的功能，但是不可以执行像普通函数一样fn()，而是需要搭配一个执行函数来执行.next()方法。 那么是否有更好的方案，async和await出现了 1234567891011121314function timeOutPrint(i) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) resolve(i); &#125;, 1000); &#125;);&#125;async function main() &#123; for (var i = 0; i &lt; 5; i++) &#123; await timeOutPrint(i); &#125;&#125;main(); 或者 123456789101112var sleep = (time) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve, time);&#125;)async function main() &#123; for (var i = 0; i &lt; 5; i++) &#123; await sleep(1000); console.log(i); &#125;&#125;main(); 还记得上面我们用过的let么12345for ( let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;，i*1000 );&#125; 说明可以参看块级作用域和let","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"js中类的实现方式","date":"2017-05-11T14:47:25.000Z","path":"2017/05/11/class-in-js/","text":"构造函数方法类的定义123456789var Animal = function(name) &#123; this.name = name;&#125;Animal.prototype.say = function() &#123; console.log(&apos;say&apos;);&#125;var a = new Animal(&apos;xiao&apos;);a.say(); // &quot;say&quot; 类的继承12345678910111213141516171819202122232425function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125;var Cat = function(name, age) &#123; this.name = name; this.age = age;&#125;extend(Cat, Animal);Cat.prototype.eat = function() &#123; console.log(&apos;eat&apos;);&#125;var gaffey = new Cat(&apos;gaffey&apos;, 5);gaffey.say() // &quot;say&quot;gaffey.eat() // &quot;eat&quot; 对象方法（非构造函数）这个方法主要是使用了es5的Object.create()函数 Object.create()函数的作用类似下面,但是真实的Object.create()要复杂的多，具体可以参看MDN关于Object.create()的Polyfill 其实和上面构造函数的原理是一样的，但是上面的方式需要用到prototype，this等知识，相对复杂，所以es5出现了Object.create(); 12345Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;; 类的定义12345678var Animal = &#123; name: &quot;&quot;, say: function() &#123; console.log(&quot;say&quot;) &#125;&#125;var a = Object.create(Animal) 类的继承123456789101112131415var Cat = &#123; eat: function() &#123; console.log(eat); &#125;&#125;function extend(Child, Parent) &#123; Object.setPrototypeOf(Child, Parent);&#125;extend(Cat, Animal);var gaffey = Object.create(Cat)gaffey.say() // &quot;say&quot;gaffey.eat() // &quot;eat&quot; ES6的class类的定义1234567891011class Animal &#123; constructor(name) &#123; this.name = name; &#125; say() &#123; console.log(&quot;say&quot;); &#125;&#125;var a = Animal(&apos;xiao&apos;); 类的继承123456789101112class Cat extends Animal &#123; constructor(name, age) &#123; super(name); // 调用父类的constructor(name) this.age = age; &#125; eat() &#123; console.log(&apos;eat&apos;); &#125;&#125;var gaffey = new Cat(&apos;gaffey&apos;, 5);console.log(gaffey);","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"css中的垂直居中","date":"2017-05-09T15:21:36.000Z","path":"2017/05/09/vertical-center/","text":"absolute + margin-top在子元素高度不变的情况下，可采用绝对定位和margin-top来实现12345678910111213141516171819.demo-wapper-1 &#123; border: 1px solid #ccc; height: 300px; position: relative;&#125;.demo-content-1 &#123; background-color: gray; height: 100px; width: 200px; position: absolute; top: 50%; margin-top: -50px; // 同时保持水平居中 left: 50%; margin-left: -100px;&#125;&lt;div class=&quot;demo-wapper-1&quot;&gt; &lt;div class=&quot;demo-content-1&quot;&gt;&lt;/div&gt;&lt;/div&gt; .demo-wapper-1{border:1px solid #ccc;height:300px;position:relative}.demo-content-1{background-color:gray;height:100px;width:200px;position:absolute;top:50%;margin-top:-50px;left:50%;margin-left:-100px} line-height当子元素为单行文本时，可以设置父元素的行高来保持垂直居中1234567891011121314.demo-wapper-2 &#123; border: 1px solid #ccc; height: 200px; line-height: 200px; text-align: center&#125;.demo-content-2 &#123; background-color: gray; display: inline&#125;&lt;div class=&quot;demo-wapper-2&quot;&gt; &lt;div class=&quot;demo-content-2&quot;&gt;&lt;/div&gt;&lt;/div&gt; .demo-wapper-2{border:1px solid #ccc;height:200px;line-height:200px;text-align:center}.demo-content-2{background-color:gray;display:inline} 12345 vertical-align方法一使用table和td来实现 1234567891011121314151617.demo-table &#123; border: 1px solid #ccc; height: 200px;&#125;.demo-table td &#123; text-align: center; vertical-align: middle;&#125;&lt;table class=&quot;demo-table&quot;&gt; &lt;tr&gt; &lt;td&gt; I&apos;m vertically centered multiple lines of text in a real table cell.&lt;br&gt; I&apos;m vertically centered multiple lines of text in a real table cell.&lt;br&gt; I&apos;m vertically centered multiple lines of text in a real table cell. &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; .demo-table{border:1px solid #ccc;height:200px}.demo-table td{text-align:center;vertical-align:middle} I’m vertically centered multiple lines of text in a real table cell.I’m vertically centered multiple lines of text in a real table cell.I’m vertically centered multiple lines of text in a real table cell. 方法二模仿上面的形式，手动使用display:table和table-cell来实现 1234567891011121314151617.demo-wapper-3 &#123; border: 1px solid #ccc; height: 200px; width: 100%; display: table;&#125;.demo-content-3 &#123; background-color: gray; height: 80px; width: 200px; text-align: center; display: table-cell; vertical-align: middle;&#125;&lt;div class=&quot;demo-wapper-3&quot;&gt; &lt;div class=&quot;demo-content-3&quot;&gt;1234&lt;br&gt;12345&lt;/div&gt;&lt;/div&gt; .demo-wapper-3{border:1px solid #ccc;height:200px;width:100%;display:table}.demo-content-3{background-color:gray;height:80px;width:200px;text-align:center;display:table-cell;vertical-align:middle} 123412345 absolute + tranfrom当我们不知道一个快块元素的高度时，可以使用tranfrom 1234567891011121314151617.demo-wapper-4 &#123; border: 1px solid #ccc; height: 200px; position: relative;&#125;.demo-content-4 &#123; background-color: gray; height: 80px; width: 200px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;&lt;div class=&quot;demo-wapper-4&quot;&gt; &lt;div class=&quot;demo-content-4&quot;&gt;&lt;/div&gt;&lt;/div&gt; .demo-wapper-4{border:1px solid #ccc;height:200px;position:relative}.demo-content-4{background-color:gray;height:80px;width:200px;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)} flex在可以使用flex的时候，flex可能是比较好的选择 123456789101112131415.demo-wapper-5 &#123; border: 1px solid #ccc; height: 200px; display: flex; justify-content: center; align-items: center;&#125;.demo-content-5 &#123; background-color: gray; height: 80px; width: 200px;&#125;&lt;div class=&quot;demo-wapper-5&quot;&gt; &lt;div class=&quot;demo-content-5&quot;&gt;&lt;/div&gt;&lt;/div&gt; .demo-wapper-5{border:1px solid #ccc;height:200px;display:flex;justify-content:center;align-items:center}.demo-content-5{background-color:gray;height:80px;width:200px} 参考文档Centering in CSS: A Complete Guide","tags":[{"name":"css","slug":"css","permalink":"http://wangyuekai.com/tags/css/"}]},{"title":"原型继承","date":"2017-05-07T17:53:32.000Z","path":"2017/05/08/prototype-chain-inheritance/","text":"在ES6中，js终于出现了正式的class关键字，对于js中类的实现和继承，似乎也给出了官方的方向，class也只是一种语法糖，实际还是使用了js的原型链来实现了类的继承功能。 所以了解原型链继承可以帮助我们更好的理解和学习JS中的类和继承，已经ES6中的class。 首先我们需要了解原型链是什么意思。 JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain) 首先js中的所有变量几乎都可以被看做对象，然后所有的对象都会有它的原型对象，而对象中有一个[[prototype]]来指向自己的原型对象。 这个设计感觉就像是子类和父类的关系，但是并不是完全相同。 而我们需要做的就是使下面这个等式成立 1childobj.[[prototype]] === parentObj","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"块级作用域和let","date":"2017-05-07T12:32:51.000Z","path":"2017/05/07/block-scope-and-let/","text":"在学习Javascript的一开始，我们就使用var来创建变量，随着ES6的发布，出现了一个一个新的创建变量的方式let，随着浏览器和node的快速支持以及babel的出现，我们已经可以正式使用let。在很多情况下用于比起使用var,let会更好，不只是在代码的稳定性还可以增加代码的可读性。 我们在学习let的时候，经常会看到对于let的定义 The let statement declares a block scope local variable，optionally initializing it to a value.(let语句声明一个块级作用域的本地变量，并且可选的赋予初始值。) — let MDN 显而易见的，let就是作用于块级作用域，那么我们首先来了解一下什么是块级作用域（block scope）。 对于块级作用域MDN的定义是 语句块 (或其他语言中的 复合语句) 用来组织零个或多条语句. 用一对花括号界定语句块. — block MDN 语法 123456[label:] &#123; statement_1; statement_2; ... statement_n;&#125; MDN对于语法的说明，给了我们一个说明，下面while (x &lt; 10)也是块级作用域的一部分。 123while (x &lt; 10) &#123; x++;&#125; 所以简单来说let在{}以内或者在类似while (x &lt; 10)的()中定义的变量，不会被外层的作用域访问到，如下的例子 1234if (true) &#123; let x = 2;&#125;console.log(x); // Uncaught ReferenceError: x is not defined 同时，我们看下面这个例子 12345678910&apos;use strict&apos;;let a = 1;&#123; let a = 2; console.log(a) // 2&#125;let a = 1; 这段代码也很好理解，我要说的是，我们一开始申明了&#39;use strict&#39;;，表示我们使用了严格模式，我们两次定义了a变量，但是代码正常执行了，说明了{}产生了新的块作用域，所以代码正常执行了。 另外对于let，我们可以看情况将其包裹在{}中，为变量显式声明块作用域，这样更加符合let的块级作用域的定义，也可以方便js的垃圾回收机制来判断是否需要回收，也可以增加代码的模块化和可读性，例子如下 1234567891011function process(data) &#123; // 在这里做点有趣的事情&#125;// 在这个块中定义的内容可以销毁了！&#123; let someReallyBigData = &#123; .. &#125;; process( someReallyBigData );&#125;// 做其他的事情 最后，我来解答一道网上经常看到的题目，题目和详细解答在我的另一篇文章中也有，我个人认为最好的答案是，只需要把var改为let,其实这道题目的本质在于var不是块级作用域，而我们的代码是写在块级作用域中的，所以我们需要一个块级作用域的变量声明，保证每个块级作用域都是不一样的变量，相互不影响，而let刚好。 1234567891011for ( let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;，i*1000 );&#125;// 相隔1s输出// 1// 2// 3// 4// 5","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"mysql绑定地址","date":"2017-05-05T07:52:25.000Z","path":"2017/05/05/mysql-bind-address/","text":"有时候需要将mysql运行在127.0.0.1上来保证只有内网访问，或者需要改到0.0.0.0来实现远程链接 1234vim /etc/mysql/my.cnf// 找到bind-address的配置，然后重启mysqlservice mysql restart","tags":[{"name":"mysql","slug":"mysql","permalink":"http://wangyuekai.com/tags/mysql/"}]},{"title":"front-end tips","date":"2017-05-03T07:33:19.000Z","path":"2017/05/03/js-tips/","text":"arguments转数组1let args = Array.prototype.slice.call(arguments); 判断是否是Generator1234// 来自于co,这里的判断前提是一个对象，所以传入的参数名是objfunction isGenerator(obj) &#123; return &apos;function&apos; == typeof obj.next &amp;&amp; &apos;function&apos; == typeof obj.throw;&#125; npm publishnpm publish 时会将.gitignore改为.npmignore 防止 Node.js 进程崩溃可以在 process 对象的 uncaughtException 事件上注册监听器。1234567const myEmitter = new MyEmitter();process.on(&apos;uncaughtException&apos;, (err) =&gt; &#123; console.error(&apos;有错误&apos;);&#125;);myEmitter.emit(&apos;error&apos;, new Error(&apos;whoops!&apos;)); min-height max-height heightheight会被min-height和max-height所影响，min-height和max-height不只是设置了高度的限制，logical-height由3个属性共同决定 0.5pxdemo html12345678910111213141516171819202122&lt;div class=&quot;example--border&quot;&gt;&lt;/div&gt;* Firefox: y* Safari: y* Chrome: n* Falls back to 1px for non-Retina (no need to wrap in a media query)## 0.5px box-shadow&lt;div class=&quot;example--box-shadow&quot;&gt;&lt;/div&gt;* Chrome: y* Firefox: y* Safari: n## linear-gradient&lt;div class=&quot;example--gradient&quot;&gt;&lt;/div&gt;* Chrome: y* Safari: y* Firefox: y css1234567891011121314151617[class^=&apos;example&apos;] &#123; margin: 1em 0; height: 1px;&#125;.example--box-shadow &#123; box-shadow: 0 0.5px 0 blue;&#125;.example--border &#123; border-top: 0.5px solid blue;&#125;.example--gradient &#123; background-image: linear-gradient(to bottom, blue 0%, blue 51%, transparent 51%); background-size: 100% 1px;&#125; css triangle principle Node Module Wapper123(function (exports, require, module, __filename, __dirname) &#123;// 你的模块代码实际上在这里&#125;);","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"ftp-in-docker-container","date":"2017-04-28T17:39:38.000Z","path":"2017/04/29/ftp-in-docker-container/","text":"在docker中安装vsftpd，在启动vsftpd服务的时候，会出现下面的错误 1&gt; vsftpd failed - probably invalid config 查了很多的资料，找到了如下的说明和解决方案 message “vsftpd failed - probably invalid config.” is received during boot.Yet the server started normally. This message is issued by /etc/init.d/vsftpd.This message is not issued on every boot, only occasionally. This appears to be a timing problem. The server is started asynchronouslyfrom this script. The script then immediately looks for the PID file; and ifit doesn’t find it issues the above error message. But the server may not yethave had time to create the PID file. Adding “sleep 1” between start-stop-daemon –start –background -m –oknodo –pidfile /var/run/vsftpd/vsftpd.pid –exec ${DAEMON} and _PID=”$(if [ -e /var/run/vsftpd/vsftpd.pid ]; then cat /var/run/vsftpd/vsftpd.pid; fi)” seems to fix the problem for me. 同时还有一个现成的解决的例子 其中的详细的代码","tags":[{"name":"docker","slug":"docker","permalink":"http://wangyuekai.com/tags/docker/"}]},{"title":"有趣的文章和网站","date":"2017-04-28T10:07:53.000Z","path":"2017/04/28/read-history/","text":"2017-07-05https://stateofdev.com/https://tutorialzine.com/ 2017-05-12人类一生存在的意义是什么？ 2017-05-09Vertical-Align: 你需要知道的所有事 2017-05-07[译]神马是AMD, CommonJS, UMD? 2017-05-05Git 工作流程HTTP 代理原理及实现（一） 2017-05-03YAML 语言教程RESTful API 设计指南 2017-04-29如何知道你该写什么 2017-04-28PHP vs Node.js","tags":[]},{"title":"那些语言","date":"2017-04-28T08:13:26.000Z","path":"2017/04/28/impressive-sentence/","text":"生而为人，对不起 — 《被嫌弃的松子的一生》","tags":[{"name":"other","slug":"other","permalink":"http://wangyuekai.com/tags/other/"}]},{"title":"查看Ubuntu版本","date":"2017-04-27T14:32:30.000Z","path":"2017/04/27/get-ubuntu-version/","text":"查看linux版本 方法一123456uname -a&gt; Linux LI 3.13.0-32-generic #57-Ubuntu SMP Tue Jul 15 03:51:12 UTC 2014 i686 athlon i686 GNU/Linux// 仅仅查看内核版本uname -r&gt; 3.13.0-32-generic 方法二12cat /proc/version &gt; Linux version 3.13.0-32-generic (buildd@roseapple) (gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) ) #57-Ubuntu SMP Tue Jul 15 03:51:12 UTC 2014 查看Ubuntu版本方法一12cat /etc/issue&gt; Ubuntu 14.04.2 LTS \\n \\l 方法二123456sudo lsb_release -a&gt; NO LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 14.04.2 LTS Release: 14.04 Codename: trusty 方法三：12345cat /etc/lsb-release&gt; DISTRIB_ID=Ubuntu DISTRIB_RELEASE=14.04 DISTRIB_CODENAME=trusty DISTRIB_DESCRIPTION=&quot;Ubuntu 14.04.2 LTS&quot;","tags":[]},{"title":"linux","date":"2017-04-27T14:31:32.000Z","path":"2017/04/27/linux/","text":"linux常用指令 链接查看Ubuntu版本 账户管理显示当前账户12whoami&gt; root 新增账户12adduser [username]# useradd kk //添加用户kk 切换账户1234su [usename]例子: su uftp su root su - root su 与 su -前者只是切换了root身份，但Shell环境仍然是普通用户的Shell；而后者连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误 关于su与sudo的区别 ，可以查看 apt-getubuntu 源地址 http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8 ubuntu 源地址修改 地址保存在/etc/apt/source.list中 建议备份 cp ./source.list ./source.list_back 端口查询1netstat -nat netstat详解","tags":[{"name":"linux","slug":"linux","permalink":"http://wangyuekai.com/tags/linux/"}]},{"title":"vim快捷键","date":"2017-04-27T14:30:02.000Z","path":"2017/04/27/vim-shortcut/","text":"#VIM 快捷键 全局:x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车) 插入模式 a → 在光标后插入o → 在当前行后插入一个新行O → 在当前行前插入一个新行cw → 替换从光标所在位置后到一个单词结尾的字符 移动光标 0 → 数字零，到行头^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）$ → 到本行行尾g_ → 到本行最后一个不是blank字符的位置。/pattern → 搜索 pattern 的字符串（如果搜索出多个匹配，可按n键到下一个） 拷贝/粘贴 P → 粘贴yy → 拷贝当前行当行于 ddP Undo/Redo u → undo\\ → redo jsc-f 格式化 ###NERDtreeK 到同目录第一个节点J 到同目录最后一个节点p 到上层目录s 横向打开文件m 显示文件系统菜单（添加、删除、移动操作）I 切换是否显示隐藏文件r 递归刷新选中目录R 递归刷新根结点cd 将 CWD 设为选中目录 ###NerdCommenter 在非插入模式中选中行后输入下列命令1、 \\cc 注释当前行和选中行2、 \\cn 没有发现和\\cc有区别3、 \\c&lt;空格&gt; 如果被选区域有部分被注释，则对被选区域执行取消注释操作，其它情况执行反转注释操作4、 \\cm 对被选区域用一对注释符进行注释，前面的注释对每一行都会添加注释5、 \\ci 执行反转注释操作，选中区域注释部分取消注释，非注释部分添加注释6、 \\cs 添加性感的注释，代码开头介绍部分通常使用该注释7、 \\cy 添加注释，并复制被添加注释的部分8、 \\c$ 注释当前光标到改行结尾的内容9、 \\cA 跳转到该行结尾添加注释，并进入编辑模式10、\\ca 转换注释的方式，比如： //和//11、\\cl \\cb 左对齐和左右对其，左右对其主要针对//12、\\cu 取消注释","tags":[{"name":"vim","slug":"vim","permalink":"http://wangyuekai.com/tags/vim/"}]},{"title":"mac蓝牙不可用","date":"2017-04-02T02:36:20.000Z","path":"2017/04/02/mac-bluetooth-disabled/","text":"mac开机以后有时候会出现蓝牙不可用的情况 解决办法方法一 断开所有的mac外接设备 重启mac 方法二这个办法主要是重置电源管理单元和系统NVRAM恢复出厂设置 关机 按下power键（开机键）,同时按住option+command+p+r,等待mac发出4声Duang~的开机音后松开，然后mac会正常开机 蓝牙可用","tags":[{"name":"mac","slug":"mac","permalink":"http://wangyuekai.com/tags/mac/"}]},{"title":"cluster","date":"2017-03-21T08:28:11.000Z","path":"2017/03/21/cluster/","text":"当我们去了解Cluster的时候，我们会在node的官方文档的一开始就会看到一个简单的例子 123456789101112131415161718192021222324252627// 这个例子是根据cpu的核数来生成对应的子进程数量，// 然后每个子进程都运行一个绑定到8000端口的http serverconst cluster = require(&apos;cluster&apos;);const http = require(&apos;http&apos;);const numCPUs = require(&apos;os&apos;).cpus().length;if (cluster.isMaster) &#123; console.log(`Master $&#123;process.pid&#125; is running`); // Fork workers. for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); &#125; cluster.on(&apos;exit&apos;, (worker, code, signal) =&gt; &#123; console.log(`worker $&#123;worker.process.pid&#125; died`); &#125;);&#125; else &#123; // Workers can share any TCP connection // In this case it is an HTTP server http.createServer((req, res) =&gt; &#123; res.writeHead(200); res.end(&apos;hello world\\n&apos;); &#125;).listen(8000); console.log(`Worker $&#123;process.pid&#125; started`);&#125; 我们可以看到创建子进程的方式就是很简单的一句cluster.fork(),接下来我们就来看一下这个函数做了什么样的事情。 首先我们打印了一下这个函数，可以看到函数如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function (env) &#123; cluster.setupMaster(); const id = ++ids; const workerProcess = createWorkerProcess(id, env); const worker = new Worker(&#123; id: id, process: workerProcess &#125;); worker.on(&apos;message&apos;, function(message, handle) &#123; cluster.emit(&apos;message&apos;, this, message, handle); &#125;); worker.process.once(&apos;exit&apos;, function(exitCode, signalCode) &#123; /* * Remove the worker from the workers list only * if it has disconnected, otherwise we might * still want to access it. */ if (!worker.isConnected()) &#123; removeHandlesForWorker(worker); removeWorker(worker); &#125; worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect; worker.state = &apos;dead&apos;; worker.emit(&apos;exit&apos;, exitCode, signalCode); cluster.emit(&apos;exit&apos;, worker, exitCode, signalCode); &#125;); worker.process.once(&apos;disconnect&apos;, function() &#123; /* * Now is a good time to remove the handles * associated with this worker because it is * not connected to the master anymore. */ removeHandlesForWorker(worker); /* * Remove the worker from the workers list only * if its process has exited. Otherwise, we might * still want to access it. */ if (worker.isDead()) removeWorker(worker); worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect; worker.state = &apos;disconnected&apos;; worker.emit(&apos;disconnect&apos;); cluster.emit(&apos;disconnect&apos;, worker); &#125;); worker.process.on(&apos;internalMessage&apos;, internal(worker, onmessage)); process.nextTick(emitForkNT, worker); cluster.workers[worker.id] = worker; return worker; &#125; 我们看到一开始就调用了一个函数cluster.setupMaster() 我们在官方文档中可以查到这个函数, 可以看到这个函数的第一个参数exec默认为process.argv[1],在主线程中打印process.argv[1]可以看到process.argv[1]指向了入口文件，所以cluster.fork()的时候，是重新运行了入口文件。这也对应了文档中的下面这句话。 Unlike the fork(2) POSIX system call, child_process.fork() does not clone the current process. 同样我们通过查看源码可以了解到下面这行代码，是根据当前的环境变量和cluster配置，传递给child_process.fork()，workerProcess就是fork后的返回值，通过查看文档，我们知道child_process.fork()返回了一个&lt;ChildProcess&gt;,关于这里面的细节，可以看child_process.fork()的细节 1const workerProcess = createWorkerProcess(id, env); 再下面，Worker对象对ChildProcess包裹了一层，提供了一些API,具体可以看文档 其他的就是一个信息的传输","tags":[{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"}]},{"title":"常见的10中排序方案的JS实现","date":"2017-03-15T08:58:40.000Z","path":"2017/03/15/sort-by-js/","text":"这段时间重新回顾了一下，算法的基础部分，排序，为了更好的理解排序，我使用JS实现了下面10种算法。 实现的排序 冒泡排序(bubble) 插入排序(insert) 快速排序(quick) 选择排序(selection) 归并排序(merge) 希尔排序(shell) 堆排序(heap) 基数排序(radix) 桶排序(bucket) 计数排序(counting) 具体的细节可以浏览sort.js 现在未对内存使用做很好的优化，如果对内存要求比较高的话，还是推荐使用c语言来实现","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"},{"name":"算法","slug":"算法","permalink":"http://wangyuekai.com/tags/算法/"}]},{"title":"IF, 三元表达式, || 的判断","date":"2017-02-27T14:43:43.000Z","path":"2017/02/27/if/","text":"\\undefinednull‘’0‘0’-0+0NaN-1IFfalsefalsefalsefalsetruefalsefalsefalsetrue三元falsefalsefalsefalsetruefalsefalsefalsetrue||falsefalsefalsefalsetruefalsefalsefalsetrue 从现在的情况看起来，三元表达式，IF 和 || 表现的结果基本一致","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"Koa中间件（middleware）实现探索","date":"2017-02-23T03:54:15.000Z","path":"2017/02/23/koa-middleware/","text":"说起Node，最常用的估计就是express和koa，两者都用到了中间件（middleware）这一概念，主要用于对请求的统一处理。 koa的请求处理是典型的洋葱模型,下面是官方的配图，而这一模型的组成部分就是middleware 接下来我们来看一下koa的源码，了解中间件的实现方式。 首先我们找到了koa的仓库Koa,好吧,我知道你们都会这一步。 在package.json中找到模块的入口文件application.js,稍微浏览一下(不得不说，tj大神的代码写的真的漂亮)就可以找到Koa处理请求的代码 12345678910111213141516171819app.callback = function()&#123; if (this.experimental) &#123; console.error(&apos;Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.&apos;) &#125; var fn = this.experimental ? compose_es7(this.middleware) : co.wrap(compose(this.middleware)); var self = this; if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror); return function handleRequest(req, res)&#123; res.statusCode = 404; var ctx = self.createContext(req, res); onFinished(res, ctx.onerror); fn.call(ctx).then(function handleResponse() &#123; respond.call(ctx); &#125;).catch(ctx.onerror); &#125;&#125;; 看完这个函数，我们了解到真正处理请求内容的函数是fn,而这个函数的定义就是下面这段函数 123var fn = this.experimental ? compose_es7(this.middleware) : co.wrap(compose(this.middleware)); 好吧，准确来说就是 1co.wrap(compose(this.middleware)); 其实我们只需要知道这段函数做了什么，就知道中间件是如何运行的了。 同时，我们在appliction.js文件找到了app.use函数 123456app.use = function(fn)&#123; ... this.middleware.push(fn); return this;&#125;; 从这段代码，我们可以知道this.middleware就是一个generator函数的数组。 接下来我们需要知道compose函数做了什么，我们找到compose函数，其实compose很短 123456789101112131415function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; return yield *next; &#125;&#125;function *noop()&#123;&#125; 这里compose函数返回了一个Generator，所以上面的代码可以变成下面的样子（当然还有middleware的变量再闭包中） 1234567891011co.wrap(function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; return yield *next; &#125;) 接下来我们看一下co.wrap 1234567co.wrap = function (fn) &#123; createPromise.__generatorFunction__ = fn; return createPromise; function createPromise() &#123; return co.call(this, fn.apply(this, arguments)); &#125;&#125;; 所以代码可以变为下面的样子 1234567891011121314function createPromise() &#123; var fn = function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; return yield *next; &#125; return co.call(this, fn.apply(this, arguments)); &#125; 接下来，我们仔细看一下这段代码 1234567if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next);&#125; 这段代码遍历了我们的中间件数组，最终生成了一个类似下面的代码 123456789101112131415161718192021222324next = (function*()&#123; // middleware1 ... yield (function*()&#123; // middleware2 ... yield (function*()&#123; // middleware3 ... yield (function *()&#123; // noop // NO next yield ! &#125;)() // ...middleware3 &#125;) // ...middleware2 &#125;) // ...middleware1&#125;)() 其实看到这里就已经可以看到洋葱模型的样子了。 而最后就是这个next的运行，其实这个next就是一个Generator函数生成的迭代器（iterator）对象，然后由co来运行，类似下面 12345co(function*()&#123; ... yield *next&#125;) co可以对generator的进行自执行。到这基本就完成可中间件的实现。 眼尖的读者可以看到这里最后用到了yield *而非yield,可以有关于co的执行，其实就是为了减少co的一次运行，其实每次都应该用yield next,可能是tj大神怕大家忘记加了，就索性在demo里面就建议大家直接yield next就好了。具体的可以看我对于co源码实现的分析，我这里就提一下`yield 可以自动执行后面的表达式的迭代器属性，而yield只会直接返回后面的表达式，所以一个yield *可以使co直接拿到后面迭代器中的每一步，而yield只可以拿到迭代器，然后递归调用co`来执行迭代器。 最后欢迎大家吐槽，谢谢。","tags":[{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"http://wangyuekai.com/tags/Koa/"}]},{"title":"Bootstrap盒模型","date":"2017-02-08T13:43:26.000Z","path":"2017/02/08/bootstrap-box-sizing/","text":"关于盒模型有两种方案，可以通过box-sizing来控制，关于盒模型其实两种方案都是表示有margin,border,’padding’,’conent’组成，唯一的区别在于一个Dom的width1到底是指那部分。 1box-sizing: content-box; 这时 width = content 1box-sizing: border-box; 这时 width = border + padding + content 但是这两个哪一个才是w3c标准盒模型呢，我一直以为是第二个，也是就border-box,因为好像一直是这么用的啊。起码看到bootstrap确实用了这个啊。 但查看了MDN的文档才知道第一种才是w3c标准盒模型 那么为什么bootstrap选择了border-box 对于这个Twitter在发布bootstrap3的时候的一篇说明提到了: Better box model by default. Everything in Bootstrap gets box-sizing: border-box, making for easier sizing options and an enhanced grid system. 可以看到之所以选择border-box是为了更加方便控制Dom的大小，也更加容易实现和使用栅格系统 在栅格系统中，bootstrap3是通过百分比来控制Dom的大小，使用border-box只需要控制宽度即可，否者需要控制宽度和padding，实现上过于麻烦，而且padding容易被修改，一旦被修改就会影响其他的布局。所以bootstrap才选择了border-box作为框架的统一的盒模型。","tags":[{"name":"css","slug":"css","permalink":"http://wangyuekai.com/tags/css/"}]},{"title":"Apache Proxy和Redirect(Proxy与Redirect冲突问题)","date":"2017-02-08T13:40:27.000Z","path":"2017/02/08/apache-proxy-redirect/","text":"最近在国外的一台机器上部署了公司的代码，但是因为有很多的图片资源，所以国内访问很慢，而客户这段时间刚好在国内，所以想要把所有的图片资源的链接重定向到国内的一台机器上。 本以为加上一段Redirect或者RedirectMatch什么的就可以了，但是加上了发现并没有起作用。看了一下Apache的配置，发现配置中还用到了proxy来指向node应用。 google了一下，猜测proxy会优先于Redirect/RedirectMatch,所以对于proxy已经命中的资源，Redirect和RedirectMatch就不会在起作用，需要在proxy排除这些文件。可以使用类似ProxyPassMatch /static/ !来使Proxy对于/static/失效。再对/static/使用Redirect 301 /static/ http://www.other-domain.com/static。 最后贴上完整一点的例子 123456789101112131415161718192021222324252627&lt;VirtualHost *:80&gt; ServerName www.example.com DocumentRoot /var/www/html/www.example.com ProxyRequests Off RewriteEngine On RedirectMatch /static/(.*).(png|svg) http://www.other-domain.com/static/$1.$2 &lt;Directory /&gt; Options FollowSymLinks AllowOverride None &lt;/Directory&gt; &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; ProxyPassMatch /static/(.*).(png|svg) ! ProxyPass / http://127.0.0.1:7300/ ProxyPassReverse / http://127.0.0.1:7300/ ProxyPreserveHost On ...&lt;/VirtualHost&gt; 除了Redirect和RedirectMatch，也可以其他的重定向配置，例如RewriteRule等","tags":[{"name":"Apache","slug":"Apache","permalink":"http://wangyuekai.com/tags/Apache/"},{"name":"服务器","slug":"服务器","permalink":"http://wangyuekai.com/tags/服务器/"}]},{"title":"学习JavaScript中的异步Generator","date":"2017-02-02T10:21:08.000Z","path":"2017/02/02/asyncing-feeling-about-javascript-generators/","text":"原文：https://www.bignerdranch.com/blog/asyncing-feeling-about-javascript-generators/ 你想看精简版本么 这里是所有三个例子的要点 异步的generators和异步iteration已经到来! 这是错误的, 它们现在还在阶段 3，这表示他们很有可能在JavaScript未来的一个版本中发布。 在他们发布之前，你可以通过Babel来在你的项目中使用还在阶段3的建议内容。 网站基本上还是一些分散运行的应用，因为任何在语言上的修改都会造成永久的影响，所以所有的未来的版本都需要向后兼容。因此，被加入到ECMAScript标准的特性，它必须是十分的可靠，而且它的语法需要很优雅。 考虑到这一点，我们希望异步generator和迭代器可以显著地影响我们如何构建今后的代码，同时也解决现在的问题。让我们开始了解异步generator是如何工作的，它在我们的正式开发中又会遇到什么样的问题。 总结: 异步的Generators是如何工作的呢简而言之，异步的generators和普通的generator函数很像，但是它可以yield Promises。如果你想很了解ES2015的generator函数，那么可以先去看一下Chris Aquino的博客，再去看一下Jafar Husain的一篇异步编程的很棒的演讲 总的来说，普通的generator函数基本上就是一个迭代器和观察者 模式的集合。generator是一个可以中止的函数，你可以通过调用.next()来一步步执行。可以同通过.next()来多次从generator输出内容，也可以通过.next(valueToPush)来多次传入参数。这种双向的接口可以使你通过一种语法同时完成迭代器和观察者的功能! 当然generators也有它的缺点:它在调用.next()的时候必须立即（同步）返回数据。换句话来说，就是代码在调用.next()的时候就需要得到数据。在generator需要时能够生成新数据的情况下是可以的，但是没有办法处理迭代一个异步的（或者临时的）数据来源，它们需要自己控制在下一次数据准备好的时候执行下一次。 WebSocket消息机制就是一个很好的异步获取数据的例子。如果我们已经接收到了所有的数据，那么我们当然可以同步地遍历它们。但是，我们也可能会遇到我们并不知道什么时候会接收到数据，所以我们需要一个机制去等待数据接收完成后去遍历。异步generators和异步迭代器可以让我们做到这个。 简单的来说就是：generator函数适用于数据可以被使用者控制的情况，异步generators适用于允许数据源本身控制的情况。 一个简单的例子: 生成和使用AsyncGenerator让我们用一个例子来练习我们的异步方案。我们需要编写一个异步的generator函数，它可以重复的等待一个随机的毫秒数后生成一个新的数字。在几秒钟中时间里，它可能会从0开始生成5个左右的数字。首先我们先通过创建一个Promise来创建一个定时器： 123456// 创建一个Promise，并在ms后resolvesvar timer = function(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;; 运行timer(5000)会返回一个Promise，并且会在5秒后resolve。现在我们可以写一个异步generator： 123456789// Repeatedly generate a number starting// from 0 after a random amount of timevar source = async function\\*() &#123; var i = 0; while (true) &#123; await timer(Math.random() \\* 1000); yield i++; &#125;&#125;; 如此复杂的功能却可以写的如此优雅！我们的异步generator函数等待一个随机的时间后yield并减小i的值。如果我们没有异步generator，我们可以像下面一样使用普通的generator函数，通过yieldPromises来实现: 1234567var source = function\\*() &#123; var i = 0; while (true) &#123; yield timer(Math.random() \\* 1000) .then(() =&gt; i++); &#125;&#125;; 当然，这里还有一些特殊情况和引用需要我们处理，所以最好有一个专门的函数类型！现在是时候编写使用代码了;因为我们需要await操作符，所以我们将会创建一个异步的run()函数。 1234567891011121314// 把所有都集合到一起var run = async function() &#123; var stream = source(); for await (let n of stream) &#123; console.log(n); &#125;&#125;;run();// =&gt; 0// =&gt; 1// =&gt; 2// =&gt; 3// ... 这是多么神奇，只有20行不到的代码。首先，我们先运行了异步generator函数source，它返回了一个特殊的AsyncGenerator对象。然后，我们使用一个语法上叫“异步迭代”的for await...of循环遍历source生成的对象。 但是我们还可以再改进一下: 假设我们是想要输出source生成的数字。我们可以在for await...of循环里面直接输出它们，但是我们最好在循环的外面“转换”stream 的值，像是使用.map()一样来转换数组里的值。它是如此的简单： 1234567// Return a new async iterator that applies a// transform to the values from another async generatorvar map = async function\\*(stream, transform) &#123; for await (let n of stream) &#123; yield transform(n); &#125;&#125;; 接下来我们只需要再往run()函数中加一行代码就好了： 123456789 // Tie everything together var run = async function() &#123; var stream = source();+ // Square values generated by source() as they arrive+ stream = map(stream, n =&gt; n \\* n); for await (let n of stream) &#123; console.log(n); &#125; &#125;; 当我们运行 run()就会输出： 12345// =&gt; 0// =&gt; 1// =&gt; 4// =&gt; 9// ... 多么感人啊！但是只是用于计算数字有一点大材小用了。 中级例子: 在WebSockets中使用AsyncIterator（异步迭代器）我们一般是通过绑定事件来监听WebSocket的数据： 1234var ws = new WebSocket(&apos;ws://localhost:3000/&apos;);ws.addEventListener(&apos;message&apos;, event =&gt; &#123; console.log(event.data);&#125;); 但是如果可以把WebSocket的信息当做stream，这样就可以用我们上面的办法“iterate”这些信息。不幸的是，WebSockets还没有异步迭代器的功能，但是我们只需要写短短的几行就可以自己来实现这个功能。我们的run()函数大概的样子如下： 1234567// Tie everything togethervar run = async () =&gt; &#123; var ws = new WebSocket(&apos;ws://localhost:3000/&apos;); for await (let message of ws) &#123; console.log(message); &#125;&#125;; Now for that polyfill.你可能会回忆起Chris Aquino’s blog series中写到的内容，一个对象要使用for...of循环，必须要有Symbol.iterator属性。同样的，一个对象要想使用for await...of循环，它必须要有Symbol.asyncIterator属性。下面就是具体的实现： 123456// Add an async iterator to all WebSocketsWebSocket.prototype[Symbol.asyncIterator] = async function\\*() &#123; while(this.readyState !== 3) &#123; yield (await oncePromise(this, &apos;message&apos;)).data; &#125;&#125;; 这个异步迭代器会等待接受信息，然后会对WebSocket的MessageEvent返回的数据的data属性进行yield。oncePromise()函数有一点黑科技：它返回了一个Promise，当事件触发时它会被resolves，然后立即移除事件监听。 12345678910// Generate a Promise that listens only once for an eventvar oncePromise = (emitter, event) =&gt; &#123; return new Promise(resolve =&gt; &#123; var handler = (...args) =&gt; &#123; emitter.removeEventListener(event, handler); resolve(...args); &#125;; emitter.addEventListener(event, handler); &#125;);&#125;; 这样看上去有一点低效，但是证明了websocket的信息接收确实可以用我们的异步迭代器实现。如果你在http://localhost:3000 有一个运行的WebSocket服务，那么你可以通过调用run()来监听信息流： 12345run();// =&gt; &quot;hello&quot;// =&gt; &quot;sandwich&quot;// =&gt; &quot;otters&quot;// ... 高级例子: 重写 RxJS现在是时候面对最后的挑战了。反应型函数编程 (FRP)在UI编程和JavaScript中被大量使用， RxJS是这种编程方式中最流行的框架。RxJS中模型事件来源例如Observable–它们很想一个一个事件流或者lazy array，它们可以被类似数组语法中的map()和filter()处理。 自从FRP补充了JavaScript中的非阻塞式理念，类RxJS的API很有可能会加入到JavaScript未来的一个版本中。同时，我们可以使用异步generators编写我们自己的类似RxJS的功能，而这仅仅只需要80行代码。下面就是我们要实现的目标： 监听所有的点击事件 过滤点击事件只获取点击anchor标签的事件 只允许不同的点击Only allow distinct clicks 将点击事件映射到点击计数器和点击事件 每500ms只可以触发一次点击 打印点击的次数和事件 这些问题都是RxJS解决了的问题，所以我们将要尝试重新实现。下面是我们的实现： 123456789101112131415161718// Tie everything togethervar run = async () =&gt; &#123; var i = 0; var clicks = streamify(&apos;click&apos;, document.querySelector(&apos;body&apos;)); clicks = filter(clicks, e =&gt; e.target.matches(&apos;a&apos;)); clicks = distinct(clicks, e =&gt; e.target); clicks = map(clicks, e =&gt; [i++, e]); clicks = throttle(clicks, 500); subscribe(clicks, ([ id, click ]) =&gt; &#123; console.log(id); console.log(click); click.preventDefault(); &#125;);&#125;;run(); 为了使上面的函数正常运行，我们还需要6个函数：streamify(), filter(), distinct(), map(), throttle() 和 subscribe()。 123456// 把所有的event emitter放入一个streamvar streamify = async function\\*(event, element) &#123; while (true) &#123; yield await oncePromise(element, event); &#125;&#125;; streamify() 像是一个WebSocket异步迭代器： oncePromise() 使用 .addEventListener() 去监听事件一次, 然后resolves Promise. 通过while (true)循环 , 我们可以一直监听事件。 12345678// Only pass along events that meet a conditionvar filter = async function\\*(stream, test) &#123; for await (var event of stream) &#123; if (test(event)) &#123; yield event; &#125; &#125;&#125;; filter() 会只允许通过test的事件被 yield. map()几乎是相同的: 123456// Transform every event of the streamvar map = async function\\*(stream, transform) &#123; for await (var event of stream) &#123; yield transform(event); &#125;&#125;; map()可以简单地在yield之前变换事件。distinct()展示了异步generator的其中一个强大的功能：它可以保存局部变量! 1234567891011121314var identity = e =&gt; e;// 只允许与最后一个不相同的事件通过var distinct = async function\\*(stream, extract = identity) &#123; var lastVal; var thisVal; for await (var event of stream) &#123; thisVal = extract(event); if (thisVal !== lastVal) &#123; lastVal = thisVal; yield event; &#125; &#125;&#125;; 最后，强大的throttle()函数和distinct()很像：它记录最后一个事件的时间，且只允许超过最后一次yield事件一个确定的时间的事件通过。 123456789101112// 只允许超过最后一次事件确定时间的事件通过。var throttle = async function\\*(stream, delay) &#123; var lastTime; var thisTime; for await (var event of stream) &#123; thisTime = (new Date()).getTime(); if (!lastTime || thisTime - lastTime &gt; delay) &#123; lastTime = thisTime; yield event; &#125; &#125;&#125;; 我们做了这么多，最后，我们还需要打印出每次的点击事件和当前的次数。subscribe()做了一些零碎的事情：它在每一次事件循环的时候运行，并执行callback，所以没有必要使用yield。 123456// 每次事件到达都调用一次回调函数var subscribe = async (stream, callback) =&gt; &#123; for await (var event of stream) &#123; callback(event); &#125;&#125;; 到这里，我们已经写了一个我们自己的反应型函数式管道！ 你可以在这里获取到所有的例子的代码和要点。 挑战异步generators是如此的优雅。而generator函数允许我们从迭代器中回去数据，异步generators可以让我们迭代“推送”过来的数据。这是多么好的异步数据结构的抽象。当然，也有一些注意事项。 首先，对一个objects增加支持for await...of的功能有一些粗糙，除非你可以避免使用yield和await。尤其是，使用.addEventListener（）转换任何东西都很棘手，因为你不可以在一个回调中使用yield操作: 1234567var streamify = async function\\*(event, element) &#123; element.addEventListener(event, e =&gt; &#123; // 这里将无法运行，因为yield // 不可以在一个普通函数中被使用 yield e; &#125;);&#125;; 同样的，你也不可以在.forEach()和其他函数型的方法中使用yield。这是一个固有的限制因为我们不能保证在generator已经完成后不使用yield。 为了绕过这个问题，我们写了一个oncePromise()函数来帮组我们。撇开一些潜在的性能问题，需要注意的是Promise的回调总是在当前的调用堆栈结束之后执行。在浏览器端，类似microtasks一样运行Promise的回调是不会出现问题的，但是一些Promise的polyfill在下一次事件循环运行之前是不会运行callback。因此，调用.preventDefault()函数有时候会没有有效果，因为可能DOM时间已经冒泡到浏览器了。 JavaScript现在已经有了多个异步流数据类型：Stream, AsyncGenerator和最后的Observable。虽然三个都是属于“推送”数据源，但是在处理回调和控制底层资源上还是有一些微妙的语义上的不同。如果你想了解更多关于反应函数式语法的细节，可以浏览General Theory of Reactivity. 更多在程序语言的竞赛中，JavaScript不是一个懒鬼。ES2015中的变量的解构赋值，ES2016中的异步函数，而现在的异步迭代器可以使JavaScript使用优雅的解决复杂UI和I/O编程的问题而不是使用充满不可控的多线程方案。 除此之外，还有很多的新内容和新特性！所以请关注博客和TC39 proposals repo来获取最新的好东西。同时，你也可以通过在Babel中开启Stage 3 提案的方式在你的代码中使用异步generator函数。 你是否有兴趣学习网页平台的下一代的JavaScript? 欢迎来我们的前端训练营, 或者 我们可以提供企业培训!","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"Javascript异步编程","date":"2017-01-31T12:30:39.000Z","path":"2017/01/31/Javascript-async-programming/","text":"随着es6的发布和Babel的出现，对于异步编程，我们慢慢告别了之前回调地狱的问题，现在的我们有了更多的选择，例如：Promise， generator， async/await等方案。下面我们一一来了解一下： ###PromisePromise在ES6发布之前就已经有很多的库和工具实现了这个功能，例如Jquery，p等等, Promise做到了将原来的回调地狱的方式，改为了链式返回，在一定程度上改善了异步编程的问题。 123456789101112131415var p1 = new Promise(function (resolve, reject) &#123; setTimeout(function() &#123; console.log(&apos;resolve&apos;); resolve(&apos;done&apos;); &#125;, 1000);&#125;);p1.then(function(data)&#123; // success console.log(data)&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&apos;发生错误！&apos;, error);&#125;); ###GeneratorGenerator是ES6中新增的语法，Generator可以做到在函数执行过程中停止和继续进行，从而使异步函数可以以同步编程的方式编写，在异步的地方停止，在异步函数执行完后继续执行Generator函数。 在调用generator函数时，并不会执行函数内容，而是会返回一个迭代器（iterator）对象, 在执行迭代器的next()函数(next()函数是iterator的属性)时可以逐步执行generator函数内容。 注：一个对象要想可以生成迭代器，该对象需要有“Symbol.iterator”属性 12345678910function* gen()&#123; var url = &apos;https://api.github.com/users/github&apos;; var result = yield fetch(url); console.log(result); yield 1;&#125;//在chrome控制台中输出&gt; gen.prototype[Symbol.iterator]//function [Symbol.iterator]() &#123; [native code] &#125; 让我们运行 gen() 12345678910111213var g = gen();var a = g.next();console.log(a);//&#123;value: Promise, done: false&#125;a = g.next();console.log(a);//&#123;value: 1, done: false&#125;a = g.next();console.log(a);//&#123;value: undefined, done: true&#125; 对于上面的结果，我们也可以参看babel对于Generator的实现，不过这并不是官方的方案，只是可以作为理解Generator的一个帮助 12345678910111213141516171819202122232425function gen() &#123; var url, result; return regeneratorRuntime.wrap(function gen$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: url = &apos;https://api.github.com/users/github&apos;; _context.next = 3;//设置下一个起始点 return fetch(url);//输出yield后面的表达式 case 3: result = _context.sent; console.log(result); _context.next = 7;//设置下一个起始点 //输出yield后面的表达式 return 1; case 7: case &apos;end&apos;: return _context.stop(); &#125; &#125; &#125;, _marked[0], this);&#125; 由此，我们也可以猜测调用Generator的时候，调用了gen.prototype[Symbol.iterator]，该函数相当于是把我们的代码根据标签yield进行分割，存储在一个“列表”中，并返回了一个迭代器，其中含有next属性，虽随着next的调用，一步步地执行“列表”中的每一段函数。 当我们运行的时候会发现上面的console.log(result);输出了undefined,这是为什么呢，因为Generator只是负责代码的停止和执行，它并不会等待后面的异步结束，而且一步步的写next太麻烦了，能不能让Generator自己执行到结束呢？ 当然可以！ 但是只有Generator并不能做到这些，因为Generator不知道异步代码什么时候结束，但是Promise知道啊，所以我们还需要上面所说的Promise。 为了方便大家理解，我们一步步来，我们先实现Generator的自执行,在每次调用next()时，都会返回一个对象，包含yield后面语句的执行的返回值和一个是否完成全部Generator函数的标记done,我们可以不断调用next直到done === true为止，就完成了Generator的自执行 123456789101112131415161718192021function* gen()&#123; yield 1; yield 2; yield 3; yield 4; yield 5;&#125;function run(fn) &#123; var gen = fn(); function next(data) &#123; var result = gen.next(data); if (result.done) return; next(result); &#125; next();&#125;run(gen); 接下来我们需要在上面的基础上引入Promise，现在我们的run函数中一个我们自己写的next函数，显而易见的，我们只需要稍微改动一下这个函数即可。为了方便，我们还写了一个readFile函数模仿异步代码，它会返回一个Promise并在1000ms后resolve。 1234567891011121314151617181920212223242526272829303132333435var readFile = function(filename) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(filename); &#125;, 1000); &#125;);&#125;function* gen() &#123; var a = yield readFile(&apos;1&apos;); console.log(a); a = yield readFile(&apos;2&apos;); console.log(a); a = yield readFile(&apos;3&apos;); console.log(a);&#125;var run = function(gen) &#123; var g = gen(); function next(err, data) &#123; var result = g.next(data); if (!result.done) &#123; result.value.then(function(data) &#123; next(null, data); return data; &#125;); &#125; else &#123; console.log(&apos;done&apos;); &#125; &#125; next();&#125;;run(gen); 上面的run函数有一个问题，现在我们默认yield后面一定是一个返回Promise的函数，那很多时候不一定会是这样，所以我们还需要一个转换器，把一切的对象都转为Promise，这个我们这里不再实现，具体可以参看TJ大神写的co。 async/await在ES6的基础上，ES2017提供了async函数，这将得异步操作变得更加方便。我们把我们上面的gen函数用async/await改写一下。其实就是去除*，加上async, 所有的yield改为await就好了 1234567891011async function gen() &#123; var a = await readFile(&apos;1&apos;); console.log(a); a = await readFile(&apos;2&apos;); console.log(a); a = await readFile(&apos;3&apos;); console.log(a);&#125;gen() 上面的代码会和上一节我们最后的代码结果一样，这是得益于async自带有自执行和异步等待。我们就不用再写自己的自执行函数和异步代码等待的逻辑了。await命令后面，可以是Promise对象，也可以是其他原始类型（数值、字符串和布尔值，数组等），是不是很酷炫。 另外不同Generator返回一个迭代器，async函数返回一个Promise对象 所以上面的例子我们还可以加上 123gen().then(function()&#123; console.log(&apos;123&apos;)&#125;) async/await很酷，但是现在浏览器还是没有完全支持，Node端只有7.0以上才可以使用，所以还是要使用Babel。 结束：随着ES6的发布，我们的异步代码方案也越来越趋于成熟了","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"modules","date":"2017-01-28T05:38:15.000Z","path":"2017/01/28/modules/","text":"Modules 访问main模块 另外：包管理器小提示 All Together 缓存 Module Caching Caveats（模块缓存警告） Core Modules(核心模块) Cycles(循环依赖) File Modules(文件模块) Folders as Modules(文件夹做为模块) Loading from node_modules Folders(从node_modules文件夹中加载模块) Loading from the global folders(从全局文件中导入模块) The module wrapper(包裹模块) The module Object(module对象) module.children module.exports exports alias(exports别名) module.filename module.id module.loaded module.parent module.require(id) Modules稳定性: 3 - locked Node.js has a simple module loading system. In Node.js, files and modules are in one-to-one correspondence. As an example, foo.js loads the module circle.js in the same directory. Node.js 有一个简单的模块加载系统。在Node.js中文件和模块是一一对应的。例如，foo.js加载了同级目录下的circle.js模块 foo.js的内容 12const circle = require(&apos;./circle.js&apos;);console.log(`The area of a circle of radius 4 is $&#123;circle.area(4)&#125;`); circle.js的内容 12345const PI = Math.PI;exports.area = (r) =&gt; PI * r * r;exports.circumference = (r) =&gt; 2 * PI * r; circle.js模块输出了area()和circumference()函数。你可以在特殊的exports对象上增加函数和对象，来把函数和对象增加到模块的根作用域下。 本地变量在模块中是私有的，因为在Node.js中模块会被一个函数所包裹（详见module wrapper）,上面的例子中，变量PI对于circle.js是私有的 如果你想要模块输出一个函数（类似构造函数）或者想要一次输出一个完整的对象而不是每次创建一个属性，就把它绑定在module.exports上，而不是exports。 下面， bar.js使用了square模块，而square模块则输出的是一个构造函数： 123const square = require(&apos;./square.js&apos;);var mySquare = square(2);console.log(`The area of my square is $&#123;mySquare.area()&#125;`); square模块定义在square.js中： 123456// 绑定在exports上不会修改当前模块，必须要使用module.exports module.exports = (width) =&gt; &#123; return &#123; area: () =&gt; width * width &#125;;&#125; 模块系统在require（“module”）模块中实现。 访问main模块当一个文件是直接被Node.js运行的，require.main被设置为它的module,这就是说你可以你可以通过以下的方式来判断一个文件是否是直接被Node.js运行的。 1require.main === module 对于文件foo.js，如果是通过执行node foo.js来运行的，上面的测试就会返回true，而如果是通过require(&#39;./foo&#39;)的方式来运行的，则会返回false。 因为模块都有一个filename属性（一般等同于__filename）, 当前项目会通过核对require.main.filename来获得入口点。 另外：包管理器小提示Node.js的require()函数的语义被设计为足够通用以来支持很多合理的目录结构。dpkg，rpm和npm等包管理系统希望能够在不修改的情况下从Node模块中构建本地包。 下面是一些我们我们建议的有效的目录结构： 我们希望保存一个包的一个特定版本的内容下/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;的文件夹中。 包可能依赖于其他的包。为了安装一个foo包，我们可能需要安装一个特定版本bar包。在某些情况下，bar可能还有他自己的依赖。这些依赖性甚至可能碰撞或形成循环。 因此Node.js寻找它加载的任何模块的真实路径（relapath），然后寻找模块的中node_modules 文件夹中的模块依赖关系，这种形式可以很简单的解决以下的文件结构： /usr/lib/node/foo/1.2.3/ - 版本1.2.3的foo的内容。 /usr/lib/node/bar/4.3.2/ - foo依赖的bar包的内容 /usr/lib/node/foo/1.2.3/node_modules/bar - 链接到的/usr/lib/node/bar/4.3.2/符号 /usr/lib/node/bar/4.3.2/node_modules/* - bar包的所有依赖的链接符号 因此，即使遇到依赖形成循环，或者依赖有冲突，每个模块都可以获取到可以用的版本的依赖。 当foo包代码中有require(&#39;bar&#39;)，它会得到链接到/usr/lib/node/foo/1.2.3/node_modules/bar的版本。当bar包中引用了require(&#39;quxux&#39;),它会得到链接到/usr/lib/node/bar/4.3.2/node_modules/quux的版本 此外，为了使模块查找的过程更加优化，我们可以吧包放在/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;中，而不是直接放在/usr/lib/node。这样Node.js就不用麻烦的在/usr/node_modules或者/node_modules寻找缺少的依赖。 为了使模块可以被Node.js的交互式解析器（REPL）使用。可以将/usr/lib/node_modules文件夹添加为$NODE_PATH环境变量。因此模块查找的node_modules都是相互关联的，require()都是基于文件的绝对地址来引用的，所以包可以放在任何地方。 All Together为了在require()的时候获取到精确的文件名字，会使用require.resolve()函数。 下面是require.resolve()的高级算法的伪码： 1234567891011121314151617181920212223242526272829303132333435363738394041在路径为Y的模块中require(X)1. 如果X为核心模块， a. 返回核心模块 b. 停止2. 如果X是以&apos;./&apos;,&apos;/&apos;或者&apos;..&apos;开头 a. LOAD_AS_FILE(Y + X) b. LOAD_AS_DIRECTORY(Y + X)3. LOAD_NODE_MODULES(X, dirname(Y))4. 抛出 &quot;not found&quot;LOAD_AS_FILE(X)1. 如果X是一个文件，以Javascript文本的方式导入X。停止寻找2. 如果X.js是一个文件，以Javascript文本的方式导入X.js。停止寻找3. 如果x.json是一个文件，格式化X.json为一个对象。停止寻找4. 如果X.node是一个文件，以二进制插件的方式导入X.node。停止寻找LOAD_AS_DIRECTORY(X)1. 如果X/package.json是一个文件 a. 解析X/package.json ,然后寻找“main”字段 b. let M = X + (json main field) c. LOAD_AS_FILE(M)2. 如果X/index.js是一个文件，以Javascript文本的方式导入X/index.js。停止寻找3. 如果X/index.json是一个文件，格式化X/index.json为一个对象。停止寻找4. 如果X.node是一个文件，以二进制插件的方式导入X/index.node。停止寻找LOAD_NODE_MODULES(X, START)1. let DIRS=NODE_MODULES_PATHS(START)2. for each DIR in DIRS: a. LOAD_AS_FILE(DIR/X) b. LOAD_AS_DIRECTORY(DIR/X) NODE_MODULES_PATHS(START)1. let PARTS = path split(START)2. let I = count of PARTS - 13. let DIRS = []4. while I &gt;= 0, a. if PARTS[I] = &quot;node_modules&quot; CONTINUE c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;) b. DIRS = DIRS + DIR c. let I = I - 15. return DIRS 缓存模块在第一次被加载之后就会被缓存。这就是说每一次调用require(&#39;foo&#39;)都会返回一个相同的对象，当然前提是每一次require都指向同一个文件。 多次调用require(&#39;foo&#39;)不会是模块代码被多次执行。这是一个很重要的特性。因为这个特性，“部分完成”的对象可以被返回，因此允许传递性的依赖甚至是形成循环的依赖都可以被加载。 如果你想要一个模块被解析多次，然后输出一个函数，并且执行那个函数。 ##Module Caching Caveats（模块缓存警告）模块是基于他们的解析后的路径（require.resolve()）来缓存的。由于模块基于调用模块的位置（从node_modules文件中加载）不同会被解析为不同的文件名字，如果模块会被解析到不同的文件，这就不能保证require(&#39;foo&#39;)会一直返回完全相同的对象。 ##Core Modules(核心模块)Node.js有一些模块会被编译成二进制文件。这些模块在文档的其他的地方有更加详细的说明。 这些核心模块被定义在Node.js的源代码中，被放置在lib/文件夹中。 这些核心模块在通过require()调用时会一直被优先加载。例如，require(&#39;http&#39;)会一直返回内置的HTTP模块，即使目录下有一个文件名是http的文件。 ##Cycles(循环依赖)当require()被循环调用，模块可能会返回一个未完成执行的对象。 比如以下这种情况： a.js 123456console.log(&apos;a starting&apos;);exports.done = false;const b = require(&apos;./b.js&apos;);console.log(&apos;in a, b.done = %j&apos;, b.done);exports.done = true;console.log(&apos;a done&apos;); b.js 123456console.log(&apos;b starting&apos;);exports.done = false;const a = require(&apos;./a.js&apos;);console.log(&apos;in b, a.done = %j&apos;, a.done);exports.done = true;console.log(&apos;b done&apos;); main.js 1234console.log(&apos;main starting&apos;);const a = require(&apos;./a.js&apos;);const b = require(&apos;./b.js&apos;);console.log(&apos;in main, a.done=%j, b.done=%j&apos;, a.done, b.done); 当main.js加载a.js，a.js反过来需要加载b.js。同时，b.js试图加载a.js。为了避免一个无限的循环，一个未完成的a.js的exports对象的拷贝被返回给b.js模块。然后当b.js模块加载完成了，它的exports对象再提供给a.js模块。 当main.js加载这两个模块时，它们都已经完成了。 这个程序的输出将是: 123456789$ node main.jsmain startinga startingb startingin b, a.done = falseb donein a, b.done = truea donein main, a.done=true, b.done=true 如果你的项目中有循环的模块依赖，请确保代码按照计划的执行。 ##File Modules(文件模块)如果准确文件名没有找到，Node.js会尝试去加载提供的文件名后面加上.js, .json, 最后是.node的文件。 .js文件会被作为Javascript文本文件被解释，.json文件会被当做JSON本文文件解析，.node会被当做编译好的插件模块被解释，并且被dlopen加载。 引用的模块的前缀为’/‘是文件的绝对路径。 例如，require（&#39;/home/marco/foo.js&#39;将加载/home/marco/foo.js下的文件。 引用的模块的前缀为’./‘是当前调用require()文件的相对路径。 例如，foo.js中依赖require（&#39;./corcle&#39;则要求circle.js必须要与foo.js在相同的目录下。 如果不是以&#39;/&#39;, &#39;./&#39;, 或者&#39;../&#39;来表示一个文件，则模块一定是一个核心模块或者是从node_modules文件中加载 如果提供的路径不存在， require()会抛出一个错误，错误信息是&#39;MODULE_NOT_FOUND&#39;。 Folders as Modules(文件夹做为模块)可以很方便将项目和或者库组织在一个自定义的目录中，然后对外提供这个库的一个简单的入口。有三种方式可以将文件夹传递给require()作为参数。 第一种方式是创建一个package.json文件在文件夹的根目录下，同时指定一个main模块。一个简单的package.json的文件可能是如下的样子： 12&#123; &quot;name&quot; : &quot;some-library&quot;, &quot;main&quot; : &quot;./lib/some-library.js&quot; &#125; 如果这个package.json文件在./some-library中，那么当require(&#39;./some-library&#39;)会试图去加载./some-library/lib/some-library.js。 这是Node.js对package.json文件的意识程度。 备注：如果package.json文件中未定义main条目，则无法被解析，Node.js会报告整个模块没有被查找的默认错误: 1Error: Cannot find module &apos;some-library&apos; 如果目录下面没有package.json，则Node.js获取尝试从该目录加载一个index.js或者index.node。比如，如果上面的例子中没有package.json文件，那么require(&#39;./some-library&#39;)会尝试加载 ./some-library/index.js ./some-library/index.node ##Loading from node_modules Folders(从node_modules文件夹中加载模块)如果模块加载时传递给require()的标识符不是原生模块，也不是以’/‘, ‘../‘, 或者’./‘开头的，那么Node.js会从当前模块的父目录开始，然后在标识符前加上/node_modules，并且尝试从加上以后的路径下加载文件。Node不会再已经是以node__modules结尾的路径上再加上node_modules。 如果在父目录下找不到，则寻找再上一层的目录，一直找到根目录下。 比如，’/home/ry/projects/foo.js’的文件调用了require(&#39;bar.js&#39;)，那么Node.js会以下面这个顺序依次寻找寻： /home/ry/projects/node_modules/bar.js /home/ry/node_modules/bar.js /home/node_modules/bar.js /node_modules/bar.js 这样可以本地化项目的依赖，并且使这些依赖不冲突。 You can require specific files or sub modules distributed with a module by including a path suffix after the module name. For instance require(‘example-module/path/to/file’) would resolve path/to/file relative to where example-module is located. The suffixed path follows the same module resolution semantics. ##Loading from the global folders(从全局文件中导入模块)如果环境变量NODE_PATH是一系列由冒号分割绝对路径组成的列表，那么Node.js如果在其他地方没有找到需要的模块则会在这些路径查询模块。（备注：在windows下，NODE_PATH是由分号分割的） NODE_PATH一开始设计是为了支持在现在的模块解析算法确定之前从不同路径加载模块。（这里的意思是说Node发展的一开始模块解析的算法还没有完成之前，是通过NODE_PATH来解决从不同的路径加载模块的问题） NODE_PATH现在依旧支持上面说的这个功能，但是在Node.js生态系统中有了定位依赖的约定（就是上面说的一大堆的模块查询规则）之后就不是那么有必要。有时候依赖于NODE_PATH的项目在部署而当人们不知道NODE_PATH必须要被设置时会发生一些奇怪的表现。有时候模块的依赖发生改变，引起NODE_PATH查询时会加载一个版本不同的模块（甚至是一个不同的模块）。 另外，Node.js会查询下面的路径 $HOME/.node_modules $HOME/.node_libraries $PREFIX/lib/node 当$HOME是用户的home目录，那么Node.js中$PREFIX会被设置为node_prefix。 这个主要是出于历史原因。你最好将你的依赖本地化在node_modules文件夹中。这样依赖会被更加可靠且快速的被加载 The module wrapper(包裹模块)在模块代码执行之前，Node.js会将它包裹在一个函数中，使其看起来像下面这个样子： 123(function (exports, require, module, __filename, __dirname) &#123;// Your module code actually lives in here&#125;); 通过这样，Node.js实现了以下事情 保证了模块中定义的顶级变量（通过var,const或者let定义的）会在module的作用域中而不是在全局。 这样可以提供一些指定给模块的变量去像是全局变量，例如： 可以使用module和exports来在模块里对外暴露一些变量 包含了模块的文件名的绝对路径和模块本身的绝对路径的__filename和__dirname变量方便被使用 ##The module Object(module对象)Added in: v0.1.16 在每个模块中，自由变量module是当前模块对象的引用。为了方便，在模块中moduls.exports也可以直接通过exports来使用。module变量实际上不是全局的，而是每个模块内部的。 ###module.childrenAdded in: v0.1.16 这个模块需要的对象（？？不知道是不是指这个模块依赖的所有模块） ###module.exportsAdded in: v0.1.16 module.exports是由模块系统创造的。有时候这是不可接受的。很多人希望他们的模块是一些类的实例。为了做到这个，分配需要export对象给module.exports。请注意，分配需要export对象给的exports会很容易被修改,而这个不是我们希望你做的。 例如，假设我们我们写的一个模块调用了a.js 123456789const EventEmitter = require(&apos;events&apos;);module.exports = new EventEmitter();// Do some work, and after some time emit// the &apos;ready&apos; event from the module itself.setTimeout(() =&gt; &#123; module.exports.emit(&apos;ready&apos;);&#125;, 1000); 接下来在另外一个文件中我们这么做 1234const a = require(&apos;./a&apos;);a.on(&apos;ready&apos;, () =&gt; &#123; console.log(&apos;module a is ready&apos;);&#125;); 注意：分配个给module.exports的内容必要立即完成。它不可以在任何一个回调中完整，下面这个例子将失败：x.js 123setTimeout(() =&gt; &#123; module.exports = &#123; a: &apos;hello&apos; &#125;;&#125;, 0); y.js 12const x = require(&apos;./x&apos;);console.log(x.a); ####exports alias(exports别名)Added in: v0.1.16在模块中exports变量可在作为module.exports的引用。与任何的变量一样，一旦你指定了新的变量给exports，则不在绑定之前的变量。为了说明这种情况，我们假设require()是这样执行的： 12345678910function require(...) &#123; // ... ((module, exports) =&gt; &#123; // Your module code here exports = some_func; // re-assigns exports, exports is no longer // a shortcut, and nothing is exported. module.exports = some_func; // makes your module export 0 &#125;)(module, module.exports); return module;&#125; 作为指导，exports和module.exports的关系视乎有些神奇，忽略exports仅适用module.exports。 ####module.filenameAdded in: v0.1.16 模块完整的解析文件名。 ####module.idAdded in: v0.1.16 模块的标识符，通常是模块完整的解析文件名。 module.loadedAdded in: v0.1.16 判断module是否已经加载完成，或者正在加载中。 ####module.parentAdded in: v0.1.16 模块对象第一个加载本模块的父模块对象。 ####module.require(id)Added in: v0.5.1 id Return: 解析到的模块的module.exportsmodule.require方法提供了一个记载模块的方式，就像从原始模块调用require()一样。 备注：为了实现这个，你必须拿到module对象的引用。由于require()是返回module.export对象,且module通常是只在模块中特定的代码中可用，因此它必须被显式到处以便使用。","tags":[{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"}]},{"title":"querystring","date":"2017-01-28T05:34:08.000Z","path":"2017/01/28/querystring/","text":"目录 Query String querystring.escape(str) querystring.parse(str[, sep[, eq[, options]]]) querystring.stringify(obj[, sep[, eq[, options]]]) querystring.unescape(str) #Query String 稳定性：2 - 稳定quertstring 模块提供了一系列用于解析和格式化url参数的工具，它可以被如下使用1const querystring = require(&apos;querystring&apos;); querystring.escape(str)加入：v0.1.25 str \\querystring.escape() 可以对字符串进行百分比编码，同时针对url查询字符串的特定要求进行了优化 querystring.escape()被querystring.stringify()使用，但是一般不推荐直接使用。主要在应用程序代码在必要的时候被用来分配给替代函数来实现百分比编码 ？？ querystring.parse(str[, sep[, eq[, options]]])加入：v0.1.25 str \\ 待解析的url查询字符串 sep \\ 用于分界查询字符串中每对key与value的字符串，默认为&#39;&amp;&#39;. eq \\ 用于分界查询字符串中key与value的字符串，默认为&#39;=&#39;. options \\ decodeURIComponent \\ 设置一个函数解码百分比编码的查询字符串，默认使用querystring.unescape(). maxKeys \\ 指定编码时key数量最多为多少。默认是1000，设置为0则表示不限数量querystring.parse()函数可以解析一个url的查询字符串（str）为一个键值对（key：value）的集合例如，一个查询字符串为&#39;foo=bar&amp;abc=xyz&amp;abc=123&#39;可以被解析为1234&#123; foo: &apos;bar&apos;, abc: [&apos;xyz&apos;, &apos;123&apos;]&#125; 注：querystring.parse()返回的对象不是原型继承于Javascript的Object对象，所以类似obj.toString(), obj.hasOwnProperty()等典型的Object对象的方法将无法使用 默认情况下，百分比编码查询字符串时会使用UFT-8编码，如果使用代替字符编码，则需要指定代替字符的decodeURIComponent选项，如下例子12// 假定 gbkDecodeURIComponent 函数已经存在..querystring.parse(&apos;w=%D6%D0%CE%C4&amp;foo=bar&apos;, null, null, &#123; decodeURIComponent: gbkDecodeURIComponent &#125;) ##querystring.stringify(obj[, sep[, eq[, options]]]) 加入：v0.1.25 obj \\ 要被序列化为查询字符串的对象. sep \\ 用于分界查询字符串中每对key与value的字符串，默认为&#39;&amp;&#39;. eq \\ 用于分界查询字符串中key与value的字符串，默认为&#39;=&#39;. options encodeURIComponent \\ 在转换查询字符传时把url中不安全的的字符串转换为百分比编码的函数.默认使用querystring.escape().querystring.stringify()函数是通过遍历对象的“own properties“来生成url查询字符串例子：12345querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;)// returns &apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;querystring.stringify(&#123;foo: &apos;bar&apos;, baz: &apos;qux&apos;&#125;, &apos;;&apos;, &apos;:&apos;)// returns &apos;foo:bar;baz:qux&apos; 一般，查询字符串中需要百分比编码的字符会被编码为UTF-8格式。如果需要代替的编码，那么将需要指定另一个encodeURIComponent选项，如以下示例所示1234// 假定 gbkEncodeURIComponent 函数已经存在,querystring.stringify(&#123; w: &apos;中文&apos;, foo: &apos;bar&apos; &#125;, null, null, &#123; encodeURIComponent: gbkEncodeURIComponent &#125;) ##querystring.unescape(str)加入：v.0.1.25 str \\querystring.unescape()方法可以对提供的字符串进行url的百分比编码.The querystring.unescape() method is used by querystring.parse() and is generally not expected to be used directly. It is exported primarily to allow application code to provide a replacement decoding implementation if necessary by assigning querystring.unescape to an alternative functionquerystring.unescape()方法被querystring.parse()函数所使用，一般来说也不推荐直接使用该函数。主要在应用程序代码在必要的时候被用来分配给替代函数来实现替换解码？？默认情况下，querystring.unescape()函数会尝试使用基于decodeURIComponent()方法来进行解码，这样即使解码失败了，也会输出一个更加安全等效的结果，而不会输出一个错误的url","tags":[{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"}]},{"title":"反思JavaScript: 通过函数代替break","date":"2017-01-27T11:05:17.000Z","path":"2017/01/27/rethinking-javascript-break-is-the-goto-of-loops/","text":"原文：https://hackernoon.com/rethinking-javascript-break-is-the-goto-of-loops-51b27b1c85f8#.k2oyppp5i 在我的上一篇文章 Death of the for Loop中，我试图去说服你放弃使用for 循环改用函数式的解决方案。反过来，你提出了一个很好的问题，那么for循环中break怎么办？ break 会相当于循环中的GOTO，我们应该避免使用。 break 应该像GOTO一样被废弃。 你可能会想“算了吧Joel，你这只是耸人听闻，break怎么可能会像GOTO一样？” 1// bad code. no copy paste. 1234567outer: for (var i in outerList) &#123;inner: for (var j in innerList) &#123; break outer; &#125; &#125; 我可以提供标记作为证明。在其他语言中，标记和GOTO是相互对应的。在JavaScript，标记与break和continue也是相互对应的。因为break和continue来自于相同标记组，这也导致了它们和GOTO很像。 JavaScript标签，break和continue是GOTO和非结构化编程时代的遗留 xkcd “但是如果它没有伤害任何人，那么我们为什么不把它留下语法中，而我们可以选择其他的方案？” 我们为什么限制我们如何编写软件?这个听上去有些违背直觉，但是限制是一个好事。限制我们使用GOTO就是一个很好的例子。我们也很欢迎限制我们的“use strict”，甚至批评不使用它的人。 “limitations can make things better. A lot better. “— Charles Scalfani 限制（规则）可以使我们写出更好的代码。 为什么编程需要限制_限制使艺术，设计，生活更美好._medium.com 我们对于break的选择是什么?我不是要做一个虚有其表的事情，但是也没有一个方案可以适合所有的情况。 这是一个完全不同的编程方式。 一个完全不同的思考方式。函数式编程的思想。 有一个好消息是，有很多的库和工具可以帮助我们，例如Lodash, Ramda, lazy.js, 递归等等 我们将从一个简单的cats集合和一个isKitten函数开始，这些将在下面所有的例子中被用到。 123456const cats = [ &#123; name: &apos;Mojo&apos;, months: 84 &#125;, &#123; name: &apos;Mao-Mao&apos;, months: 34 &#125;, &#123; name: &apos;Waffles&apos;, months: 4 &#125;, &#123; name: &apos;Pickles&apos;, months: 6 &#125;] 1const isKitten = cat =&gt; cat.months &lt; 7 让我们从一个我们熟悉的for循环的例子开始。它会遍历我们的cats，然后当找到第一只小猫的时候退出循环。 1var firstKitten 123456for (var i = 0; i &lt; cats.length; i++) &#123; if (isKitten(cats[i])) &#123; firstKitten = cats[i] break &#125;&#125; 现在，让我们和lodash中一个相同作用的例子做比较。 1const firstKitten = _.find(cats, isKitten) 这个例子相当的简单。接下来让我们尝试一些边缘情况吧。现在我们改为遍历cat集合，然后选出前5只小猫，然后退出循环。 1var first5Kittens = [] 1234// old-school edge case kitty loopfor (var i = 0; i &lt; cats.length; i++) &#123; if (isKitten(cats[i])) &#123; first5Kittens.push(cats[i]) 12345 if (first4Kittens.length &gt;= 5) &#123; break &#125; &#125;&#125; 简单的方式lodash是一个很好的库也可以坐很多的事情，但是有时候你需要一些其他更加专业的工具。这里我们介绍一个新朋友, lazy.js. “像Underscore，但是更加偷懒”。但是偷懒就是我们想要的. 123const result = Lazy(cats) .filter(isKitten) .take(5) 困难的方法库都是有趣的，但是有时候真正有趣的是从头开始创造东西。 所以我们可以创建一个通用的函数，让它可以像filter一样使用也可以增加限制的功能。 第一步就是把我们上面写的边缘情况的for循环封装在一个函数中。 接下来，让我们是这个函数更加通用并且遍历所有cat具体的内容。使用limit来代替5,predicate来代替isKitten，list来代替cats。然后把这些作为函数的参数。 现在我们有了一个可用的且可重复的takeFirst函数，这个可以让我们完全不用去关心我们cat的逻辑实现！ 我们的函数现在依旧还是一个纯函数。也就是说函数的输出只和输入的参数有关。如果传入相同的参数，一定会得到相同的结果。 现在我们已经还是有那个肮脏的for循环，所以让我们继续重构。下一步就是把i和newList放入参数列表。 当limit变为0的时候 (limit会在递归过程中减少)或者是遍历完了列表，我们希望可以退出递归(isDone)。 如果递归还在进行，我们将会核对是否有符合我们的过滤条件predicate的值。如果当前值符合过滤条件，我们会调用takeFirst，减少limit并把当前值保存在我们的newList中，否者，移动到列表的下一个值。 如果你还没有看过Rethinking JavaScript: The if statement，它会解释这个用三元表达式代替if‘的最后一步。 Rethinking JavaScript: The if statement_Thinking functionally has opened my mind about programming._medium.com 现在我们像下面这样调用我们的新方法： 1const first5Kittens = takeFirst(5, isKitten, cats) 为了兼容更多的情况，我们可以柯里化takeFirst，然后使用它去创建一些其他的函数（关于柯里化的介绍在另一篇文章中） 12const first5 = takeFirst(5)const getFirst5Kittens = first5(isKitten) 1const first5Kittens = getFirst5Kittens(cats) 总结现在有很多优秀的库例如 lodash, ramda和lazy.js供我们使用。但是如果我们足够大胆，也可以使用递归来创建我们自己的函方法。 我必须要警告虽然takeFirst看上去很酷 但是使用递归是有得也有失的. 递归在Javascript中是很危险的，它很容易就会导致超出最大调用堆栈大小的报错。 我将会在我的下一篇文章中重写JavaScript的递归。敬请关注。 我知道这只是一件小事，但是当我收到来自Medium和Twitter (@joelnet)的follow通知时会使我很开心。当然，如果你觉得我实在胡说八道，你也可以在下面的讨论区告诉我。 Cheers!","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"Node学习之路：require()工作原理","date":"2017-01-27T07:23:25.000Z","path":"2017/01/27/how-require-actually-works/","text":"原文：http://thenodeway.io/posts/how-require-actually-works/ 介绍 Node学习之路 掌握的基本知识 理解回调函数中的错误优先 测试要点 进阶 单例模式 设计自定义类型 工厂模式 高级 require() 工作原理 危险的模块设计模式 几乎所有的Node.js开发者都可以说出require()的作用，但是又有多少人真正知道require()是如何工作的呢。我们几乎每天都会使用它去加载库和模块，但是它的原理还是一个谜。 因为好奇，我查看了Node的核心源码去寻找答案。但是我不是找到了一个函数，而是找到了Node的核心模块:module.js。这个文件惊人的强大，它包含了文件的加载，编译，并且可以缓存所有使用过的文件。对外使用的require()只是冰山一角。 module.js12345function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; // ... module.js里的模块类型在Node.js中有两个主要的作用。第一，它为所有的Node.js模块提供了一个函数用于编译。每一个文件在这个基础模块中运行后都会返回一个新的实例，即使这个文件运行了也还是会存在。这就是为什么我们可以随时使用 module.exports并且可以返回它。 这个模块的第二个主要的作用就是管理Node模块加载机制。这个独立的require函数其实是module.require的一个引用，而module.require只是一个把Module._load简单包裹了一下（wapper）。这个函数才是真正控制文件的加载的，接下来我们通过这个函数继续我们的探索。 Module._load12345678Module._load = function(request, parent, isMain) &#123; // 1\\. 检查 Module._cache 是否有缓存 // 2\\. 如果没有缓存则创建一个新的模块实例 // 3\\. 将模块实例保存到缓存中 // 4\\. 通过给予的filename去调用module.load()，然后调用module.compile()去读取文件内容 // 5\\. 如果文件的载入和解析过程中发生错误，删除缓存中的该模块 // 6\\. 返回 module.exports&#125;; Module._load是一个负责新模块的加载和管理模块缓存的函数。缓存所有加载过的模块可以减少文件的重复加载并且明显地加快你的应用。此外，共享模块的实例可以把模块像单例来使用，可以在整个项目的运行中都可以保存它的状态。 如果一个模块不存在在缓存中，Module._load 会为这个文件创建一个新的基础模块。Module._load会通知模块去读取新的文件的内容，然后把内容送到module._compile。[1] 如果你看了上面的#6，那么你就会看到module.exports会被返回给用户。这就是为什么你可以通过exports和module.exports创建一个对外的公共接口，而这些就是Module._load做的事情，然后通过require返回出去。我很惊讶于除此之外没有其他的神奇的地方了，但是没有什么比它更加简洁更加好的了。 module._compile123456Module.prototype._compile = function(content, filename) &#123; // 1\\. 创建一个独立的require函数，该函数可以调用module.require。 // 2\\. 给require加上其他帮助性的函数Attach other helper methods to require. // 3\\. 将代码包裹在一个函数中，并提供了require，module等变量在模块作用域中。 // 4\\. 运行这个函数&#125;; 这里就是见证奇迹的地方。第一，一个特殊的单独的require函数被创造用于这个模块。这个require函数就是我们最熟悉的那个函数。这个函数只是把 Module.require包裹了一下，它也包含了一些鲜为人知的帮助性的属性和方法供我们使用： require(): 加载一个外部模块 require.resolve(): 通过解析一个模块绝对路径来生成模块的name require.main: 主要模块 require.cache: 所有模块的缓存 require.extensions: 每一个有效文件的编译函数都是基于这个来做扩展 一旦require完成了，整个加载好的源码会被包裹在一个新的函数里面，同时传入require, module, exports和其对外的变量作为新函数的参数。这样就创造了一个新的函数作用域，这样可以避免污染Node的全局环境。 123(function (exports, require, module, __filename, __dirname) &#123; // 你的代码会被放在这里&#125;); 最后，这个包含了模块的函数会被运行。整个Module._compile方法的执行时同步的，所以Module._load会等待Module._compile执行完，然后会返回module.exports给用户。 结论至此，我们已经看完了require的代码，通过这一圈的代码就创造出了我们一开始想要去了解的那个require 函数。 如果你了解了上面所有的内容，那么你将会了解到require(&#39;module&#39;)最后的秘密。没错，就是模块系统本身也可以通过模块系统加载进来的。一开始，这个可能听上去有些奇怪，但是这样可以让用户不用了解Node.js的核心原理就可以使用加载系统加载自己的模块。流行的模块例如mockery and rewire就是这样构建的。 如果你想了解更多的细节，你可以浏览module.js源码。你会得到更多的信息也会了解的更多，我将会给第一个回答出什么是‘NODE_MODULE_CONTEXTS’并且为什么要加上这个的人加分。 [1] module._compile函数只是用于运行JavaScript文件。JSON文件会简单地通过 JSON.parse()解析然后返回。 [2] 当然这些模块都是由一些私有的函数方法构建的，例如Module._resolveLookupPaths and Module._findPath。你可以想一想是否可以有更好的办法… 请开启你的Javascript然后浏览 comments powered by Disqus.","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"}]},{"title":"10 个技巧，让你在2017 年成为更好的 Node 开发者","date":"2017-01-27T07:22:17.000Z","path":"2017/01/27/10-tips-to-become-a-better-node-developer/","text":"本文是由我们的客座作者Azat Mardan写的。SitePoint引入客座帖子的目的是希望能给你带来web社区里著名作者和演讲者的有趣内容。 在2012年，我加入了Storify并开始使用Node作为我的主要语言。从那以后，我从未回首过去并觉得我错过了Python，Ruby，Java以及PHP，这些在过去10年里，我在web开发过程中使用的语言。 Storify提供给我一个很有趣的工作，因为Storify和其他的公司不太一样，Storify之前（可能到现在也是）所有的代码都是由JavaScript编写的。而大多数公司，特别是大公司，例如PayPal，Walmart(沃尔玛)或者Capital One(第一资本)，只是在某一些特定的部分使用了Node。通常，他们使用Node作为API接口或者用在业务流程层，这样做是很好的。但是作为一个软件工程师，没什么比得上能够完全沉浸在Node环境里。 下面我将列出10条建议，这些建议可以帮助你在2017年成为一个更好的Node开发者。其中一些建议是我在日常实践中所学到的，另一些是从那些写了最流行的Node和npm模块的人们身上学到的。 下面是我们将要介绍的内容： 避免复杂性 — 尽可能将你的代码块拆到最小，要小到极致。 使用异步编程 — 像躲避瘟疫般避免使用同步代码。 避免require阻塞 — 把你所有的require声明都放在文件的顶部，因为require是同步的，会阻塞代码运行。 了解require缓存 — 了解它则可以利用它，否则它可能会带来bug。 始终检查错误 — 错误不是足球，任何时候都不要抛出错误或者跳过错误检查。 只在同步代码中使用try…catch — 在异步代码中try...catch是没有作用的。V8引擎针对try...catch无法进行优化。 返回callbacks或者使用if … else — 返回一个callback只是为了确保不继续执行。 监听错误事件 — 几乎所有的Node的类/对象都有event emitter(观察者模式)并且会广播error事件，确保你监听了它们。 了解你的npm — 使用-S或者-D来安装模块来代替--save或者–save-dev`。 在package.json中使用精确的版本号: npm在使用-S来安装模块时会自动使用默认的版本号，你需要手动修改去锁定版本号。除非是开源模块，否者不要相信你的项目中的SemVer（语义化版本标准）。 加分 — 使用不同的依赖。把项目在开发阶段需要的东西放在 devDependencies 中，记得使用 npm i –production。多余的依赖越多，出现问题的风险就越大。 好的，接下来让我们一个个单独地去了解上面的每一点。 避免复杂性让我看一眼npm的创造者Isaac Z. Schlueter写的一些模块，例如，use-strict，这个模块是用来在Javascript中强制使用严格模式，这个模块仅仅只有三行代码： 123var module = require(&apos;module&apos;)module.wrapper[0] += &apos;&quot;use strict&quot;;&apos;Object.freeze(module.wrap) 所以我们为什么要避免复杂性呢? 一个起源于美国海军的著名短语:KEEP IT SIMPLE STUPID(或者是“Keep it simple, stupid”)。这就是原因。事实说明，人类大脑在任何一个时间只能在其工作记忆中保持五到七个项目。 把你的代码模块化成一个更加小的部分，你和其他的开发者会更加好的理解它。你也可以更加好的去测试它。如下例子， 1234567app.use(function(req, res, next) &#123; if (req.session.admin === true) return next() else return next(new Error(&apos;Not authorized&apos;))&#125;, function(req, res, next) &#123; req.db = db next()&#125;) 或者是 1234const auth = require(&apos;./middleware/auth.js&apos;)const db = require(&apos;./middleware/db.js&apos;)(db)app.use(auth, db) 我相信大多数人都会喜欢第二个例子，特别是光看名字就能了解其作用。当日，在你编写代码的时候，你可能认为你知道代码是如何运行的。甚至你想要展示你把几个功能连接在一起写在同一行中是多么的机智。但是，这样你是写了一段愚蠢的代码。如果你思考的很复杂去写这代码，那么今后你再去看这段代码将会很难去理解。保证你的代码简单，特别是在Node的异步代码中。 当然也会有left-pad 事件，但是其实它只是影响了依赖于left-pad模块的项目而且11分钟后就发布了替代品。代码的最小化带来的好处超过了它的缺点。npm已经改变了发布策略,任何重要的项目都应该使用缓存或私有的源（作为临时解决方案）。 使用异步编程在Node中同步代码只要很小的一部分。这些代码大多数都是用于命令行工具或者其他与web应用无关的脚本。Node开发者大多数都是编写web应用，因此使用异步代码可以避免阻塞现场。 例如，当你在编写一个数据库的脚本或者是一个不需要控制并行的任务时，下面这种写法可能是可以的： 1234let data = fs.readFileSync(&apos;./acconts.json&apos;)db.collection(&apos;accounts&apos;).insert(data, (results))=&gt;&#123; fs.writeFileSync(&apos;./accountIDs.json&apos;, results, ()=&gt;&#123;process.exit(1)&#125;)&#125;) 但是当你创建一个web应用时，下面这个写法会更好： 1234567app.use(&apos;/seed/:name&apos;, (req, res) =&gt; &#123; let data = fs.readFile(`./$&#123;req.params.name&#125;.json`, ()=&gt;&#123; db.collection(req.params.name).insert(data, (results))=&gt;&#123; fs.writeFile(`./$&#123;req.params.name&#125;IDs.json`, results, ()=&#123;res.status(201).send()&#125;) &#125;) &#125;)&#125;) 这个区别在于你是否需要编写一个并发（通常是长期运行）或者非并发（短期运行）的系统。根据经验来说，总是要在Node中使用异步代码。 避免require阻塞Node有一个使用了CommonJS模块格式的简单的模块加载系统。它是基于require函数，require函数可以很方便的在不同的文件中引入模块。和AMD/requirejs不同，Node/CommonJS的模块加载时同步的。require的工作方式是：引入一个模块或者一个文件export的内容: 1`const react = require(&apos;react&apos;)` 但是大多数的开发者并不知道require是会被缓存的。因此，只要解析的文件名（resolved filename）没有剧烈的变化（比如npm模块不存在的情况），模块的代码只会被执行并存入变量中一次（在当前进程中）。这是一个很好的优化。当然，即使有了缓存，你最好还是把你的require声明写在开头。下面这段代码，它在路由中真正使用到了axios模块的时候才加载。当请求发送的时候/connect会因为需要加载模块所以会变得慢。 12345app.post(&apos;/connect&apos;, (req, res) =&gt; &#123; const axios = require(&apos;axios&apos;) axios.post(&apos;/api/authorize&apos;, req.body.auth) .then((response)=&gt;res.send(response))&#125;) 一个更好，性能更优的方式是在服务定义之前就引入模块而不是在路由中: 1234567const axios = require(&apos;axios&apos;)const express = require(&apos;express&apos;)app = express()app.post(&apos;/connect&apos;, (req, res) =&gt; &#123; axios.post(&apos;/api/authorize&apos;, req.body.auth) .then((response)=&gt;res.send(response))&#125;) 知道require会被缓存我在上面一节已经提到了require会被缓存，但是有趣的是我们在module.exports之外也会有代码。举例来说： 12345console.log(&apos;I will not be cached and only run once, the first time&apos;)module.exports = () =&gt; &#123; console.log(&apos;I will be cached and will run every time this module is invoked&apos;)&#125; 从中我们了解到有一些代码只会运行一次，你可以使用这个特性来优化你的代码。 始终检查错误Node不是Java。在Java中，你可以抛出错误，因为如果发生了错误那么你会希望应用不在继续执行。在Java中，你可以在外层仅仅使用一个简单的try...catch就可以处理多个错误。 但是在Node中并不是这样的。自从Node使用了事件循环和异步执行后，任何的错误发生时都会与错误处理器（例如try...catch）的上下文分离，下面这样做在Node中是没有用的： 12345678try &#123; request.get(&apos;/accounts&apos;, (error, response)=&gt;&#123; data = JSON.parse(response) &#125;)&#125; catch(error) &#123; // Will NOT be called console.error(error)&#125; 但是try...catch在同步代码中是可以被用的。前面的代码片段可以被更好的重构为： 12345678request.get(&apos;/accounts&apos;, (error, response)=&gt;&#123; try &#123; data = JSON.parse(response) &#125; catch(error) &#123; // Will be called console.error(error) &#125;&#125;) 如果我们无法将request的返回内容包裹在try...catch中，那么我们将没有办法去处理请求的错误。Node的开发者通过在返回的参数里面加上error来解决了这个问题。因此，我们需要在每一个回调中手动去处理错误。你可以去检查这些错误（判断error不是null）,然后展示错误信息给用户或者展示在客户端上并且记录它， 或者你可以通过调用 callback ，给它传 error 参数，将错误传回给上一级调用栈（如果你在调用栈之上有另一个回调函数）。 12345678request.get(&apos;/accounts&apos;, (error, response)=&gt;&#123; if (error) return console.error(error) try &#123; data = JSON.parse(response) &#125; catch(error) &#123; console.error(error) &#125;&#125;) 一个小技巧是你可以使用okay库。你可以像下面的例子一样使用它去避免在回调地狱中手动去检查错误(你好, 回调地狱). 123456789var ok = require(&apos;okay&apos;)request.get(&apos;/accounts&apos;, ok(console.error, (response)=&gt;&#123; try &#123; data = JSON.parse(response) &#125; catch(error) &#123; console.error(error) &#125;&#125;)) 返回回调或者使用if … elseNode是并行的。但是如果你不够细心也会因为这个特性产生bug。 为了安全起见，应该要使用return来终止代码的继续执行： 123let error = trueif (error) return callback(error)console.log(&apos;I will never run - good.&apos;) 这样可以避免一些因为代码逻辑的处理不当导致一些不应该执行的内容（或者错误）被执行。 123let error = trueif (error) callback(error)console.log(&apos;I will run. Not good!&apos;) 请确保使用return去阻止代码的继续执行。 监听 error 事件Node中几乎所有的类/对象都有事件分发器（观察者模式）并且会广播 error 事件。 这是一个很好的特性，可以使开发者在这些讨厌的错误造成巨大后果之前捕捉到它们。 养成一个通过.on()来创建error事件监听的好习惯： 123456789101112var req = http.request(options, (res) =&gt; &#123; if ((&apos;&apos; + res.statusCode).match(/^2\\d\\d$/)) &#123; // Success, process response &#125; else if ((&apos;&apos; + res.statusCode).match(/^5\\d\\d$/)) // Server error, not the same as req error. Req was ok. &#125;&#125;)req.on(&apos;error&apos;, (error) =&gt; &#123; // Can&apos;t even make a request: general error, e.g. ECONNRESET, ECONNREFUSED, HPE_INVALID_VERSION console.log(error)&#125;) 了解你的npm很多的Node和前端的开发者知道在安装模块的时候使用--save会在安装模块的同时，会在package.json保存一条含有模块版本信息的条目。当然，还有--save-dev可以用于安装devDependencies(在生成环境中不需要的模块)。但是你知道用-S和-D是否可以代替--save 和--save-dev么？答案是可以的。 当你安装模块的时候，你需要删除-S和-D自动为你模块的版本号添加的^标签。否者当你使用npm install（或者npm i）安装模块的时候，就会自动拉取最新的镜像（版本号的第二位数字）。例如v6.1.0就是v6.2.0的一个镜像分支。 npm团队推荐使用semver，但是你最好不要这样。npm团队认为开源开发者会遵守semver所以他们在npm安装时自动加上了^。没有人可以去保证，所以最好是锁定你的版本号。更好的办法是使用shrinkwrap：npm shrinkwrap会生成一个包含依赖的具体版本的文件。 结束语这篇文章是两部分的第一部分，我们已经提到了很多方面，从使用callbacks和异步代码，到核查错误和锁定依赖。希望你们可以从中学习到一些新的，或者有用的信息。敬请期待即将推出的第二部分。 同时，告诉我你的想法。我是否遗漏了什么？你是否有不一样的做法？在下面的评论区告诉我你的想法吧。","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"new到底做了什么","date":"2017-01-27T07:20:49.000Z","path":"2017/01/27/new-working/","text":"在Javscript中，我们实例化一个类的时候都会使用类似的代码 1var coder = new Man() 那么在new的时候，new到底做了什么呢，其实很简单，new的作用，就是先创建一个空对象，然后将新对象的proto链接到类的prototype，最后通过将新对象作为上下文（this），调用call来执行类的构造函数。实现代码如下 123var coder = &#123;&#125;;coder.__proto__ = Man.prototypeMan.call(coder) 具体可以查看MDN的文档new运算符","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"开发推荐 mac中好用的软件","date":"2017-01-27T07:19:30.000Z","path":"2017/01/27/mac-software/","text":"这里只是我个人用到的一些比较好用的软件，本人是前端开发，所以偏前端的软件可能多一些，不喜勿喷哦，也希望大家可以推荐好的软件给我。 sublime不知道该从哪个软件开始写起，后来一想还是从自己最常用的软件开始吧 sublime作为一个轻量级的ide，性能很优秀，基本什么配置的电脑都可以流畅使用，随着sublime2到sublime3，不管你需要什么样的插件都可以找的到。 Parallers Desktop 个人认为mac上最好的虚拟机，没有之一。第一次使用Parallers的融合模式，确实是惊艳到我了，虚拟机居然可以这种地步，一直以为虚拟机就是在一个窗口中，然后在这个窗口内使用。Parallers可以使你使用其他平台的软件像是在使用mac上软件，唯一的问题就是window上的广告和通知也显示在mac上了，感觉怪怪的,另外Parallers现在好像都要收费了，而且还挺贵的，不过确实物超所值。 Dash开发往往会遇到很多的类库，用到的时候总会需要查询一些文档，一个个去找太麻烦了，dash可以把文档下载下来，而且可以很方便的查询文档，而且dash可以和大多数ide对接，只需要选中你想要查询的函数，加上快捷键就可以直接在dash中查询到对应函数的说明，可以提交开发的效率。另外网路不好的情况下，离线的文档有时候可以帮你解决很多问题。 *","tags":[{"name":"软件","slug":"软件","permalink":"http://wangyuekai.com/tags/软件/"}]},{"title":"class in ES6","date":"2017-01-27T07:18:42.000Z","path":"2017/01/27/class-in-ES6/","text":"在es6出来之后，我们看到js终于有class这个关键字，表示我们终于可以使用官方的类了。那么es6的类和之前的我们使用原型链继承实现的类有什么联系么。 答案是一模一样 JavaScript classes introduced in ECMAScript 2015 are syntactical sugar over JavaScript’s existing prototype-based inheritance. (在 ECMAScript 6 引入的 JavaScript 类（class）是 JavaScript 现有的原型继承的语法糖。) —— MDN Classes 好吧，那么为了使我们更好的理解es6的class，也是倒过来更好的理解js的原型链，下面我们把类的es6写法和原型链实现的写法一一列出 ###类的创建，类的构造器和原型方法ES61234567891011121314class Polygon &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125; calcArea() &#123; return this.height * this.width; &#125;&#125;const square = new Polygon(10, 10);// 100console.log(square.area); 原型链12345678var Polygon = function(height, width)&#123; this.height = height; this.width = width;&#125;Polygon.prototype.calcArea = function() &#123; return this.height * this.width;&#125; ###类的静态方法static关键字用来定义类的静态方法。静态方法是指那些不需要对类进行实例化)，使用类名就可以直接访问的方法，需要注意的是静态方法不能被实例化的对象调用。静态方法经常用来作为工具函数。ES6123456789101112131415161718class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; static distance(a, b) &#123; const dx = a.x - b.x; const dy = a.y - b.y; return Math.sqrt(dx*dx + dy*dy); &#125;&#125;const p1 = new Point(5, 5);const p2 = new Point(10, 10);console.log(Point.distance(p1, p2)); 原型链1234567891011var Point = function(x, y)&#123; this.x = x; this.y = y;&#125;Point.distance = function(a, b) &#123; const dx = a.x - b.x; const dy = a.y - b.y; return Math.sqrt(dx*dx + dy*dy);&#125; 至此我们也可以明白了如何用原型链去构建一个类 其实当我们去查看babel对于类的实现，其实也是一样的 123456789101112131415161718var _createClass = function() &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function(Constructor, protoProps, staticProps) &#123; //实例方法（原型方法）的实现 if (protoProps) defineProperties(Constructor.prototype, protoProps); //静态函数的实现 if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;(); ###类的继承 未完 参考文档Javascript原型链MDN Classes","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"semver","date":"2017-01-27T07:17:50.000Z","path":"2017/01/27/semver/","text":"semver规则","tags":[{"name":"编程","slug":"编程","permalink":"http://wangyuekai.com/tags/编程/"}]},{"title":"node-js-best-practices-how-to-become-a-better-developer-in-2017","date":"2017-01-27T07:16:45.000Z","path":"2017/01/27/node-js-best-practices-how-to-become-a-better-developer-in-2017/","text":"一年前，我们写了一篇文章How to Become a Better Node.js Developer in 2016 ，这篇文章成功地获取了不错的反响，所以我想现在是时候回顾这个主题为2017年做准备了。 ###2017年最好的Node.js实践 使用ES2015去年我们建议了你使用ES2015，当前现在的情况已经大有不同了 回到那个时候，Node.js v4是当时的稳定版本(LTS)，支持了ES2015中57%的功能。一年过去了，现在Node v6已经增长到支持ES2015中99%的功能了。 如果你现在在使用最新的LTS Node.js版本，你甚至可以不再需要babel就可以使用所有ES2015的特性。但是即使如此，在浏览器端你可能还是需要babel。 如果你需要关于Node.js版本对于ES2015支持情况的更多的信息，我推荐你可以查询node.green ####使用Promises 在80年代第一次提出Promises的概念。现在多数现代编程语言已经支持这一特性了，使我们的编码变得更加简单。 想象一个如下的功能，它需要读取一个文件，然后解析它，然后打印出其中的name字段。如果使用回调，它可能是下面这个样子的： 123456789101112fs.readFile(&apos;./package.json&apos;, &apos;utf-8&apos;, function (err, data) &#123; if (err) &#123; return console.log(err) &#125; try &#123; JSON.parse(data) &#125; catch (ex) &#123; return console.log(ex) &#125; console.log(data.name)&#125;) Promises可以使得这段代码变的更加有可读性：123456fs.readFileAsync(&apos;./package.json&apos;).then(JSON.parse).then((data) =&gt; &#123; console.log(data.name)&#125;).catch((e) =&gt; &#123; console.error(&apos;error reading/parsing file&apos;, e)&#125;) 当前，现在的fs的并没有一个返回一个Promise的readFileAsyncapi。为了做到这个，我们使用可以一个类似promisifyAll的模块。 ####使用标准的JavaScript格式 当我们谈到代码风格的时候，一个公司有统一的代码风格是至关重要的。只有这样，当你需要改变你的项目的时候，你才可以高效的从零开始，而不用担心基础的架构不一样。 在RisingStack，我们在所有的项目中都使用了JavaScript Standard Style。 使用 Standard后，在你安装之后就可以直接使用，你不需要再做其他的事情，也不需要管理.eslintrc, .jshintrc, 或者 .jscsrc文件。具体的Standard的规则可以查看Standard rules。 ###使用docker—容器将在2017年被大量使用在生成环境 你可以把docker镜像当做部署的工具。docker容器可以将一个软件打包在一个完整的文件系统中，这个容器可以包含你在服务器上需要的一切，例如代码，运行环境，系统工具，系统程序库。 但是为什么我们需要开始使用容器呢? 容器可以使你的应用运行在一个隔离的环境中 作为一个安全工具，可以使你的代码更加的安全 轻量级的docker镜像 使得你的部署变得稳定 你可以在本地运行模拟线上的运行环境 你可以从official getting started tutorial开始学习docker。另外也推荐Kubernetes best practices ####监控你的项目 当你的应用发生错误的时候，第一个知道的人不应该是用户而应该是开发者。 最新的一个开源解决方案Prometheus可以帮助你实现项目的监控。Prometheus是一个基于SoundCloud的开源工具箱，它可以监控你的项目并报警。Prometheus唯一的缺点是你需要设置一些配置并且需要需要自己管理。 如果你在寻找一个开箱即用的解决方案，你也可以使用我们自己开发的Trace by RisingStack Trace可以帮助你做到以下的事情 报警 生产环境下的内存和cpu分析 分布式追踪和错误寻找 性能监控 保护你的npm包的安全 ####在后台进程中使用消息服务 如果你使用http请求发送消息，当你的接收服务器宕机了，你所有的消息都会丢失。如果你的传输层支持持久化，类似使用消息队列来发送消息，你就不会有这个问题。 你的接收服务器器宕机了，消息将会被保存下来，在服务重启后会继续发送，如果你的服务器未宕机但是发送了错误，消息会被重新发送一次，这样可以保证你的数据不会丢失。 举个例子：你需要发送数千份邮件，在这个场景下，你只需要获取到一些类似邮件地址和用户的姓名等基础信息，后台就可以很轻松地将这些信息和邮件信息整合后发送出去。 这种方式最大的好处是，你可以你需要的时候横向扩展你的服务，而不会有邮件被丢失。如果你需要发送数百万的邮件，你可以用相同的方式来增加你的服务。 对于消息队列的选择有很多 RabbitMQ Kafka NSQ AWS SQS ####使用最新的LTS版本的Node.js 为了平衡稳定性和新特性，我推荐你使用最新的LTS版本的Node.js。当我写这篇文章的时候，最新的LTS版本是6.9.2。 你可以使用nvm来切换你的node版本，你只需要两个指令就可管理和切换你的node版本 12nvm install 6.9.2nvm use 6.9.2 ####使用语义化的版本管理 几个月前，我们进行了一个Node.js开发者调查，我们从中获取了开发者对于使用语义化版本的使用情况。 不幸的是，我们发现调查者只有71%的人在他们提交和使用模块时使用语义化的版本管理。我们认为这个数字应该要更高 - 每一个都应该使用语义版本!，因为不根据semver规则来提交package，会很容易摧毁你的Node.js应用。 通过版本号来管你的项目或者模块是至关重要的。你的用户应该要知道一个模块是否更新了，在使用新版本前他们要做什么。 这就是语义版本控制的来历。一个版本号应该要有主版本号、副版本号、补丁版本号，更新不同位置的版本号代表不同的意思： 主版本号:表示更新会有不兼容的API 副版本号:表示更新会有新的功能（不破坏现有的api） 补丁版本号:表示更新是模块做了向后兼容的bug修复 npm是根据semver规则来安装依赖的，因此当你发布一个模块之前，请确认是否遵循了semver规则，否则你会破坏了其他使用了你的依赖的应用。 ####保证你的应用安全 保证你的用户数据的安全将是你2017年的头等大事。仅在2016年一年，因为缺少一些安全的措施就有数百万的用户账户被泄漏。 你可以通过阅读我们的博客Node.js Security Checklist来入门Node.js的安全，博客里包含了以下的话题： 安全的HTTP Headers 强制保护 Session管理 不安全的依赖 数据验证 当你掌握了这些基础，你可以来观看我关于Node的互动讨论Surviving Web Security with Node.js 学习ServerlessServerless started with the introduction of AWS Lambda. Since then it is growing fast, with a blooming open-source community.In the next years, serverless will become a major factor for building new applications. If you’d like to stay on the edge, you should start learning it today.One of the most popular solutions is the , which helps in deploying AWS Lambda functions. Serverless是AWS Lambda第一个提出来的，之后它发展的很快，并建立了一个开源的社区。 接下来的一年，构建新应用时serverless会成为一个标准。如果你想要留在这个领域，你需要重现在开始就学习它。 Serverless Framework是当前最流行的解决方案，在部署AWS Lambda functions可以帮助你。 ####参加会议与聚会并发言 参加会议和聚会是一个很好地方式去了解和学习新的趋势，开发技巧和最佳实践。当日，这也是一个场合去认识更多新的人。 To take it one step forward, I’d like to encourage you to speak at one of these events as well!As public speaking is tough, and “imagine everyone’s naked” is the worst advice, I’d recommend checking out speaking.io for tips on public speaking! 在此基础上，我也鼓励你在一些会议上发言。 在公共场合发言是一个不容易的事情，“imagine everyone’s naked”是最坏的建议。我建议你可以去speaking.io学习一些技巧。 ####Become a better Node.js developer in 2017 原文链接","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"}]},{"title":"Closures","date":"2017-01-27T07:16:02.000Z","path":"2017/01/27/Closures/","text":"Closures are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions ‘remember’ the environment in which they were created. — MDN 看不懂上面的英文这么办，下面是中文翻译 闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。 关于闭包已经有很多很多的文章了，文章的最后会放一些链接，在这里我只写以下几点 闭包的实现是因为Js中有函数作用域，变量查询是一级一级查询上去，直到根作用域也就是说在任何一级的作用域中都可以访问之前所有作用域连的变量，同时内存回收机制是不会回收还被引用的变量。 闭包不是实现Js类的基础，但是可以通过闭包实现类的私有变量和私有函数 闭包的性能很差，有时候可以绑定在prototype中（只可以访问this下的变量） 123456789101112131415161718//在这个例子中firstName和LastName不想直接被外界访问，同时可以使用闭包使外界获取到值，//同时函数尽量绑定在prototype上，所以getFullName绑定在prototype上，//所以我个人认为在这样的情况下，一些用于访问私有变量的基础函数可以使用闭包，//大多数类函数可以绑定在prototype中，通过可以访问私有变量的基础函数来实现访问私有变量var Man = function()&#123; var firstName = &apos;wang&apos;; var LastName = &apos;yuekai&apos;; this.getFirstName = function()&#123; return firstName; &#125; this.getLastName = function()&#123; return LastName; &#125;&#125;Man.prototype.getFullName = function()&#123; return this.getFirstName() + this.getLastName()&#125; 其他文献学习Javascript闭包（Closure）闭包","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"Javascript原型链","date":"2017-01-27T07:15:21.000Z","path":"2017/01/27/prototype-chain/","text":"原型链的继承就是将子类的prototype.__proto__链接到父类的prototype，借此完成原型链1child.prototype.__proto__.= parent.prototype 实例化的对象没有prototype,prototype是函数特有的属性，所有的对象都有__proto__, 这是指向实例化这个对象的类的prototype,所有对象的原型链最后是null 下面是经典的原型链继承的例子，我借此解释一下12345678910111213141516171819 function extend(Child, Parent) &#123; var F = function()&#123;&#125;; //将父类的prototype复制到F函数中 F.prototype = Parent.prototype; /*new F()实例化F()实际的作用是生成了一个下面这个对象 &#123; __proto__: &#123; //Parent.prototype &#125; &#125; 这样就完成了 Child.prototype.__proto__ = Parent.prototype这个原型链继承的核心内容 */ Child.prototype = new F(); //Parent.prototype的constructor是Parent，为了准确这里要手动将Child.prototype.constructor改为Child Child.prototype.constructor = Child; //这里是为了代码实际开发时方便调用父类，不用使用__proto__ Child.uber = Parent.prototype; &#125; 涉及到继承这一块，Javascript 只有一种结构，那就是：对象。在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。—MDN原型链描述 上面这句话有些长，看代码获取会直观一点 12345childClass.prototype.__proto__ == parantClass.prototypechildInstance.__proto__ == childClass.prototypechildInstance.__proto__.__proto__ == childClass.prototype.prototype == parantClass.prototype 对于这里的childInstance.__proto__ == childClass.prototype，是由关键字new实现的，具体可以看我的另外一篇文章new到底做了什么 参考文献Javascript继承机制的设计思想Javascript面向对象编程（二）：构造函数的继承继承与原型链","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"Javascript 代码优化","date":"2017-01-27T07:13:35.000Z","path":"2017/01/27/optimizing-javascript/","text":"客户端的脚本可以使你的应用变得动态和生动，但是浏览器对于JavaScript的解释可能会导致效率的底下，而且随着客户端本身的不同也会导致性能的不同。我们整理了一些建议和最好的实践来优化你的Javascript 代码。 ###定义class的方法 下面这个例子是低效的，每一次实例化baz.Bar，都会创建一个新foo的闭包函数。 123456baz.Bar = function() &#123; // constructor body this.foo = function() &#123; // method body &#125;;&#125; 比较好的方法是 1234567baz.Bar = function() &#123; // constructor body&#125;;baz.Bar.prototype.foo = function() &#123; // method body&#125;; 这种方式，无论创建多少个baz.Bar的示例，都只会创建一个foo函数，同时也没有闭包函数产生。 ###初始化实例变量Place instance variable declaration/initialization on the prototype for instance variables with value type (rather than reference type) initialization values (i.e. values of type number, Boolean, null, undefined, or string).这个可以避免每次构建函数被调用时不必要地每次都运行初始化代码（但是如果你的实例变量是依赖于构建函数的传入参数，或者依赖于构建时的一些状态则不适用于该建议） 例子 123456foo.Bar = function() &#123; this.prop1_ = 4; this.prop2_ = true; this.prop3_ = []; this.prop4_ = &apos;blah&apos;;&#125;; 应该改为下面这种形式 123456789foo.Bar = function() &#123; this.prop3_ = [];&#125;;foo.Bar.prototype.prop1_ = 4;foo.Bar.prototype.prop2_ = true;foo.Bar.prototype.prop4_ = &apos;blah&apos;; ###避免落入闭包的陷进 闭包是Javascript中一个很强大也很有用的一个特性；同时，它也有一些缺点： 闭包是最常见的导致内存泄漏的原因 创建一个闭包比起不使用闭包来创建一个内在的函数来说慢得多，和重用一个静态的函数来比要更加慢。如下例子 1234function setupAlertTimeout() &#123; var msg = &apos;Message to alert&apos;; window.setTimeout(function() &#123; alert(msg); &#125;, 100);&#125; 较快的：123456function setupAlertTimeout() &#123; window.setTimeout(function() &#123; var msg = &apos;Message to alert&apos;; alert(msg); &#125;, 100);&#125; 更快的12345678function alertMsg() &#123; var msg = &apos;Message to alert&apos;; alert(msg);&#125;function setupAlertTimeout() &#123; window.setTimeout(alertMsg, 100);&#125; 闭包会增加作用域的长度。当浏览器解析属性的时候，作用域的每一级都必须被查询。如下例子 1234567891011121314var a = &apos;a&apos;;function createFunctionWithClosure() &#123; var b = &apos;b&apos;; return function () &#123; var c = &apos;c&apos;; a; b; c; &#125;;&#125;var f = createFunctionWithClosure();f(); 当f被执行，引用c快于b,快于a。在ie中使用闭包的信息可以浏览IE+JScript Performance Recommendations Part 3: JavaScript Code inefficiencies ###避免使用with在你的代码中要避免视同with。它的性能很差，因为它会修改作用域链，使得其他的作用域连中查找变量变得困难。网站应用中最常见的内存泄漏是因为JavaScript脚本引擎和浏览器的C ++对象实现DOM一件的循环引用（例如：between the JavaScript script engine and Internet Explorer’s COM infrastructure, or between the JavaScript engine and Firefox XPCOM infrastructure） ###避免浏览器内存泄漏 在web应用中内存泄漏是一个很常见的问题，它会导致巨大的性能问题。当你的网站应用导致浏览器使用的的内存增加，会影响到用户的系统的其他部分变得缓慢。 这里有一些经验的法则来避免内存泄漏： 把事件处理绑定在事件管理系统上 最常见的循环引用类型就是 [ DOM element –&gt; event handler –&gt; closure scope –&gt; DOM ]，为了避免这种问题，应该选择一个经过良好测试的事件管理系统来绑定事件处理，例如Google doctype，Dojo或者Jquery。 未完 原文链接“","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"About this and prototype","date":"2017-01-27T07:12:03.000Z","path":"2017/01/27/About-this-and-prototype/","text":"对于js中this创建的对象，相当于改变了自身的字面量，而本身有一个自带的属性为prototype，这个不属于字面量的内容123456789101112131415function Person () &#123; this.name = &quot;wang&quot;; this.age = 15;&#125;Person.prototype.name = &apos;lala&apos;;var john = new Person();console.log(JSON.stringify(john));//&#123;name:&quot;wang&quot;, age:15&#125;//这里说明了this等同于的是对象字面量console.log(john.name) //“wang”，这里说明了，js会优先寻找字面量里面是否有这个对象，其次才会去prototype里面寻找 对象的样子如下12345678&#123; name:&apos;wang&apos;, age: 15, prototype:&#123; constructor:[Function], name: &apos;lala&apos; &#125;&#125;","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"}]},{"title":"require()","date":"2017-01-26T07:05:17.000Z","path":"2017/01/26/require/","text":"1module = new Module() //module 为 Module类的实例 12345678var Module = function(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; this.filename = null; this.loaded = false; this.children = [];&#125; 123var require = function()&#123; return module.exports&#125; 模块的加载实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出。—— require() 源码解读 所以说每一个require的文件执行的过程，都是先读取文件，注入变量，再执行代码，所以node文件不需要自己实例化Module,在require的时候会自动实例化的，所以从另一个角度说，文件并不会直接执行，所以看上去文件中的require，module等变量都为创建而可以执行。1234567891011121314151617//a.jsexports.multiply = function(n) &#123; return n * 1000 &#125;;//index.jsrequire(&apos;./a.js&apos;)//require(&apos;./a.js&apos;)实际的变为了 var module = &#123; exports: &#123;&#125; &#125;;(function(module, exports) &#123; exports.multiply = function(n) &#123; return n * 1000 &#125;; &#125;(module, module.exports)) return module.exports; ####Demo require原理 读取js文件并运行","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://wangyuekai.com/tags/Node/"}]},{"title":"use generator and co in mocha","date":"2017-01-25T07:05:17.000Z","path":"2017/01/25/use-generator-and-co-in-mocha/","text":"主要的点在于当 it() 函数的回调函数带有done参数，mocha会等到回调函数里面出 done 或者或者超时才完成一条测试。同时因为每个测试用例最多执行2000毫秒，所以要面对需要很长时间的测试，需要通过设置 -t 来修改最长时间（暂时没有更好的方法）1234it(&apos;option is empty&apos;, function(done) &#123; ... done()//结束一条测试&#125;); 例子12345678910111213describe(&apos;runBash&apos;, function() &#123; it(&apos;option is Sync&apos;, function(done) &#123; var instructionList = [&apos;echo &quot;one&quot;&apos;, &apos;echo &quot;two&quot;&apos;]; var option = &#123; webRoot: &apos;../fake-natoo&apos; &#125;; co(function*(done) &#123; var errCode = yield runBash(instructionList, option); expect(errCode).to.be.equal(null); done();//完成测试 &#125;.call(this, done));//传入done &#125;);&#125;); ps Mocha默认每个测试用例最多执行2000毫秒(可以通过-t来调整)Mocha默认会高亮显示超过75毫秒的测试用例（可以通过-s来调整）&lt;&lt;测试框架 Mocha 实例教程&gt;&gt;(阮一峰)","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://wangyuekai.com/tags/Javascript/"},{"name":"Test","slug":"Test","permalink":"http://wangyuekai.com/tags/Test/"}]}]