[{"title":"IF, 三元表达式, || 的判断","date":"2017-02-27T14:43:43.000Z","path":"2017/02/27/if/","text":"\\ undefined null ‘’ 0 ‘0’ -0 +0 NaN -1 IF false false false false true false false false true 三元 false false false false true false false false true || false false false false true false false false true 从现在的情况看起来，三元表达式，IF 和 || 表现的结果基本一致","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Koa中间件（middleware）实现探索","date":"2017-02-23T03:54:15.000Z","path":"2017/02/23/koa-middleware/","text":"说起Node，最常用的估计就是express和koa，两者都用到了中间件（middleware）这一概念，主要用于对请求的统一处理。 koa的请求处理是典型的洋葱模型,下面是官方的配图，而这一模型的组成部分就是middleware 接下来我们来看一下koa的源码，了解中间件的实现方式。 首先我们找到了koa的仓库Koa,好吧,我知道你们都会这一步。 在package.json中找到模块的入口文件application.js,稍微浏览一下(不得不说，tj大神的代码写的真的漂亮)就可以找到Koa处理请求的代码 12345678910111213141516171819app.callback = function()&#123; if (this.experimental) &#123; console.error(&apos;Experimental ES7 Async Function support is deprecated. Please look into Koa v2 as the middleware signature has changed.&apos;) &#125; var fn = this.experimental ? compose_es7(this.middleware) : co.wrap(compose(this.middleware)); var self = this; if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror); return function handleRequest(req, res)&#123; res.statusCode = 404; var ctx = self.createContext(req, res); onFinished(res, ctx.onerror); fn.call(ctx).then(function handleResponse() &#123; respond.call(ctx); &#125;).catch(ctx.onerror); &#125;&#125;; 看完这个函数，我们了解到真正处理请求内容的函数是fn,而这个函数的定义就是下面这段函数 123var fn = this.experimental ? compose_es7(this.middleware) : co.wrap(compose(this.middleware)); 好吧，准确来说就是 1co.wrap(compose(this.middleware)); 其实我们只需要知道这段函数做了什么，就知道中间件是如何运行的了。 同时，我们在appliction.js文件找到了app.use函数 123456app.use = function(fn)&#123; ... this.middleware.push(fn); return this;&#125;; 从这段代码，我们可以知道this.middleware就是一个generator函数的数组。 接下来我们需要知道compose函数做了什么，我们找到compose函数，其实compose很短 123456789101112131415function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; return yield *next; &#125;&#125;function *noop()&#123;&#125; 这里compose函数返回了一个Generator，所以上面的代码可以变成下面的样子（当然还有middleware的变量再闭包中） 1234567891011co.wrap(function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; return yield *next; &#125;) 接下来我们看一下co.wrap 1234567co.wrap = function (fn) &#123; createPromise.__generatorFunction__ = fn; return createPromise; function createPromise() &#123; return co.call(this, fn.apply(this, arguments)); &#125;&#125;; 所以代码可以变为下面的样子 1234567891011121314function createPromise() &#123; var fn = function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; return yield *next; &#125; return co.call(this, fn.apply(this, arguments)); &#125; 接下来，我们仔细看一下这段代码 1234567if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next);&#125; 这段代码遍历了我们的中间件数组，最终生成了一个类似下面的代码 123456789101112131415161718192021222324next = (function*()&#123; // middleware1 ... yield (function*()&#123; // middleware2 ... yield (function*()&#123; // middleware3 ... yield (function *()&#123; // noop // NO next yield ! &#125;)() // ...middleware3 &#125;) // ...middleware2 &#125;) // ...middleware1&#125;)() 其实看到这里就已经可以看到洋葱模型的样子了。 而最后就是这个next的运行，其实这个next就是一个Generator函数生成的迭代器（iterator）对象，然后由co来运行，类似下面 12345co(function*()&#123; ... yield *next&#125;) co可以对generator的进行自执行。到这基本就完成可中间件的实现。 眼尖的读者可以看到这里最后用到了yield *而非yield,可以有关于co的执行，其实就是为了减少co的一次运行，其实每次都应该用yield next,可能是tj大神怕大家忘记加了，就索性在demo里面就建议大家直接yield next就好了。具体的可以看我对于co源码实现的分析，我这里就提一下`yield 可以自动执行后面的表达式的迭代器属性，而yield只会直接返回后面的表达式，所以一个yield *可以使co直接拿到后面迭代器中的每一步，而yield只可以拿到迭代器，然后递归调用co`来执行迭代器。 最后欢迎大家吐槽，谢谢。","tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"http://yoursite.com/tags/Koa/"}]},{"title":"Bootstrap盒模型","date":"2017-02-08T13:43:26.000Z","path":"2017/02/08/bootstrap-box-sizing/","text":"关于盒模型有两种方案，可以通过box-sizing来控制，关于盒模型其实两种方案都是表示有margin,border,’padding’,’conent’组成，唯一的区别在于一个Dom的width1到底是指那部分。 1box-sizing: content-box; 这时 width = content 1box-sizing: border-box; 这时 width = border + padding + content 但是这两个哪一个才是w3c标准盒模型呢，我一直以为是第二个，也是就border-box,因为好像一直是这么用的啊。起码看到bootstrap确实用了这个啊。 但查看了MDN的文档才知道第一种才是w3c标准盒模型 那么为什么bootstrap选择了border-box 对于这个Twitter在发布bootstrap3的时候的一篇说明提到了: Better box model by default. Everything in Bootstrap gets box-sizing: border-box, making for easier sizing options and an enhanced grid system. 可以看到之所以选择border-box是为了更加方便控制Dom的大小，也更加容易实现和使用栅格系统 在栅格系统中，bootstrap3是通过百分比来控制Dom的大小，使用border-box只需要控制宽度即可，否者需要控制宽度和padding，实现上过于麻烦，而且padding容易被修改，一旦被修改就会影响其他的布局。所以bootstrap才选择了border-box作为框架的统一的盒模型。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Apache Proxy和Redirect(Proxy与Redirect冲突问题)","date":"2017-02-08T13:40:27.000Z","path":"2017/02/08/apache-proxy-redirect/","text":"最近在国外的一台机器上部署了公司的代码，但是因为有很多的图片资源，所以国内访问很慢，而客户这段时间刚好在国内，所以想要把所有的图片资源的链接重定向到国内的一台机器上。 本以为加上一段Redirect或者RedirectMatch什么的就可以了，但是加上了发现并没有起作用。看了一下Apache的配置，发现配置中还用到了proxy来指向node应用。 google了一下，猜测proxy会优先于Redirect/RedirectMatch,所以对于proxy已经命中的资源，Redirect和RedirectMatch就不会在起作用，需要在proxy排除这些文件。可以使用类似ProxyPassMatch /static/ !来使Proxy对于/static/失效。再对/static/使用Redirect 301 /static/ http://www.other-domain.com/static。 最后贴上完整一点的例子 123456789101112131415161718192021222324252627&lt;VirtualHost *:80&gt; ServerName www.example.com DocumentRoot /var/www/html/www.example.com ProxyRequests Off RewriteEngine On RedirectMatch /static/(.*).(png|svg) http://www.other-domain.com/static/$1.$2 &lt;Directory /&gt; Options FollowSymLinks AllowOverride None &lt;/Directory&gt; &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; ProxyPassMatch /static/(.*).(png|svg) ! ProxyPass / http://127.0.0.1:7300/ ProxyPassReverse / http://127.0.0.1:7300/ ProxyPreserveHost On ...&lt;/VirtualHost&gt; 除了Redirect和RedirectMatch，也可以其他的重定向配置，例如RewriteRule等","tags":[{"name":"Apache","slug":"Apache","permalink":"http://yoursite.com/tags/Apache/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"学习JavaScript中的异步Generator","date":"2017-02-02T10:21:08.000Z","path":"2017/02/02/asyncing-feeling-about-javascript-generators/","text":"原文：https://www.bignerdranch.com/blog/asyncing-feeling-about-javascript-generators/ 你想看精简版本么 这里是所有三个例子的要点 异步的generators和异步iteration已经到来! 这是错误的, 它们现在还在阶段 3，这表示他们很有可能在JavaScript未来的一个版本中发布。 在他们发布之前，你可以通过Babel来在你的项目中使用还在阶段3的建议内容。 网站基本上还是一些分散运行的应用，因为任何在语言上的修改都会造成永久的影响，所以所有的未来的版本都需要向后兼容。因此，被加入到ECMAScript标准的特性，它必须是十分的可靠，而且它的语法需要很优雅。 考虑到这一点，我们希望异步generator和迭代器可以显著地影响我们如何构建今后的代码，同时也解决现在的问题。让我们开始了解异步generator是如何工作的，它在我们的正式开发中又会遇到什么样的问题。 总结: 异步的Generators是如何工作的呢简而言之，异步的generators和普通的generator函数很像，但是它可以yield Promises。如果你想很了解ES2015的generator函数，那么可以先去看一下Chris Aquino的博客，再去看一下Jafar Husain的一篇异步编程的很棒的演讲 总的来说，普通的generator函数基本上就是一个迭代器和观察者 模式的集合。generator是一个可以中止的函数，你可以通过调用.next()来一步步执行。可以同通过.next()来多次从generator输出内容，也可以通过.next(valueToPush)来多次传入参数。这种双向的接口可以使你通过一种语法同时完成迭代器和观察者的功能! 当然generators也有它的缺点:它在调用.next()的时候必须立即（同步）返回数据。换句话来说，就是代码在调用.next()的时候就需要得到数据。在generator需要时能够生成新数据的情况下是可以的，但是没有办法处理迭代一个异步的（或者临时的）数据来源，它们需要自己控制在下一次数据准备好的时候执行下一次。 WebSocket消息机制就是一个很好的异步获取数据的例子。如果我们已经接收到了所有的数据，那么我们当然可以同步地遍历它们。但是，我们也可能会遇到我们并不知道什么时候会接收到数据，所以我们需要一个机制去等待数据接收完成后去遍历。异步generators和异步迭代器可以让我们做到这个。 简单的来说就是：generator函数适用于数据可以被使用者控制的情况，异步generators适用于允许数据源本身控制的情况。 一个简单的例子: 生成和使用AsyncGenerator让我们用一个例子来练习我们的异步方案。我们需要编写一个异步的generator函数，它可以重复的等待一个随机的毫秒数后生成一个新的数字。在几秒钟中时间里，它可能会从0开始生成5个左右的数字。首先我们先通过创建一个Promise来创建一个定时器： 123456// 创建一个Promise，并在ms后resolvesvar timer = function(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;; 运行timer(5000)会返回一个Promise，并且会在5秒后resolve。现在我们可以写一个异步generator： 123456789// Repeatedly generate a number starting// from 0 after a random amount of timevar source = async function\\*() &#123; var i = 0; while (true) &#123; await timer(Math.random() \\* 1000); yield i++; &#125;&#125;; 如此复杂的功能却可以写的如此优雅！我们的异步generator函数等待一个随机的时间后yield并减小i的值。如果我们没有异步generator，我们可以像下面一样使用普通的generator函数，通过yieldPromises来实现: 1234567var source = function\\*() &#123; var i = 0; while (true) &#123; yield timer(Math.random() \\* 1000) .then(() =&gt; i++); &#125;&#125;; 当然，这里还有一些特殊情况和引用需要我们处理，所以最好有一个专门的函数类型！现在是时候编写使用代码了;因为我们需要await操作符，所以我们将会创建一个异步的run()函数。 1234567891011121314// 把所有都集合到一起var run = async function() &#123; var stream = source(); for await (let n of stream) &#123; console.log(n); &#125;&#125;;run();// =&gt; 0// =&gt; 1// =&gt; 2// =&gt; 3// ... 这是多么神奇，只有20行不到的代码。首先，我们先运行了异步generator函数source，它返回了一个特殊的AsyncGenerator对象。然后，我们使用一个语法上叫“异步迭代”的for await...of循环遍历source生成的对象。 但是我们还可以再改进一下: 假设我们是想要输出source生成的数字。我们可以在for await...of循环里面直接输出它们，但是我们最好在循环的外面“转换”stream 的值，像是使用.map()一样来转换数组里的值。它是如此的简单： 1234567// Return a new async iterator that applies a// transform to the values from another async generatorvar map = async function\\*(stream, transform) &#123; for await (let n of stream) &#123; yield transform(n); &#125;&#125;; 接下来我们只需要再往run()函数中加一行代码就好了： 123456789 // Tie everything together var run = async function() &#123; var stream = source();+ // Square values generated by source() as they arrive+ stream = map(stream, n =&gt; n \\* n); for await (let n of stream) &#123; console.log(n); &#125; &#125;; 当我们运行 run()就会输出： 12345// =&gt; 0// =&gt; 1// =&gt; 4// =&gt; 9// ... 多么感人啊！但是只是用于计算数字有一点大材小用了。 中级例子: 在WebSockets中使用AsyncIterator（异步迭代器）我们一般是通过绑定事件来监听WebSocket的数据： 1234var ws = new WebSocket(&apos;ws://localhost:3000/&apos;);ws.addEventListener(&apos;message&apos;, event =&gt; &#123; console.log(event.data);&#125;); 但是如果可以把WebSocket的信息当做stream，这样就可以用我们上面的办法“iterate”这些信息。不幸的是，WebSockets还没有异步迭代器的功能，但是我们只需要写短短的几行就可以自己来实现这个功能。我们的run()函数大概的样子如下： 1234567// Tie everything togethervar run = async () =&gt; &#123; var ws = new WebSocket(&apos;ws://localhost:3000/&apos;); for await (let message of ws) &#123; console.log(message); &#125;&#125;; Now for that polyfill.你可能会回忆起Chris Aquino’s blog series中写到的内容，一个对象要使用for...of循环，必须要有Symbol.iterator属性。同样的，一个对象要想使用for await...of循环，它必须要有Symbol.asyncIterator属性。下面就是具体的实现： 123456// Add an async iterator to all WebSocketsWebSocket.prototype[Symbol.asyncIterator] = async function\\*() &#123; while(this.readyState !== 3) &#123; yield (await oncePromise(this, &apos;message&apos;)).data; &#125;&#125;; 这个异步迭代器会等待接受信息，然后会对WebSocket的MessageEvent返回的数据的data属性进行yield。oncePromise()函数有一点黑科技：它返回了一个Promise，当事件触发时它会被resolves，然后立即移除事件监听。 12345678910// Generate a Promise that listens only once for an eventvar oncePromise = (emitter, event) =&gt; &#123; return new Promise(resolve =&gt; &#123; var handler = (...args) =&gt; &#123; emitter.removeEventListener(event, handler); resolve(...args); &#125;; emitter.addEventListener(event, handler); &#125;);&#125;; 这样看上去有一点低效，但是证明了websocket的信息接收确实可以用我们的异步迭代器实现。如果你在http://localhost:3000 有一个运行的WebSocket服务，那么你可以通过调用run()来监听信息流： 12345run();// =&gt; &quot;hello&quot;// =&gt; &quot;sandwich&quot;// =&gt; &quot;otters&quot;// ... 高级例子: 重写 RxJS现在是时候面对最后的挑战了。反应型函数编程 (FRP)在UI编程和JavaScript中被大量使用， RxJS是这种编程方式中最流行的框架。RxJS中模型事件来源例如Observable–它们很想一个一个事件流或者lazy array，它们可以被类似数组语法中的map()和filter()处理。 自从FRP补充了JavaScript中的非阻塞式理念，类RxJS的API很有可能会加入到JavaScript未来的一个版本中。同时，我们可以使用异步generators编写我们自己的类似RxJS的功能，而这仅仅只需要80行代码。下面就是我们要实现的目标： 监听所有的点击事件 过滤点击事件只获取点击anchor标签的事件 只允许不同的点击Only allow distinct clicks 将点击事件映射到点击计数器和点击事件 每500ms只可以触发一次点击 打印点击的次数和事件 这些问题都是RxJS解决了的问题，所以我们将要尝试重新实现。下面是我们的实现： 123456789101112131415161718// Tie everything togethervar run = async () =&gt; &#123; var i = 0; var clicks = streamify(&apos;click&apos;, document.querySelector(&apos;body&apos;)); clicks = filter(clicks, e =&gt; e.target.matches(&apos;a&apos;)); clicks = distinct(clicks, e =&gt; e.target); clicks = map(clicks, e =&gt; [i++, e]); clicks = throttle(clicks, 500); subscribe(clicks, ([ id, click ]) =&gt; &#123; console.log(id); console.log(click); click.preventDefault(); &#125;);&#125;;run(); 为了使上面的函数正常运行，我们还需要6个函数：streamify(), filter(), distinct(), map(), throttle() 和 subscribe()。 123456// 把所有的event emitter放入一个streamvar streamify = async function\\*(event, element) &#123; while (true) &#123; yield await oncePromise(element, event); &#125;&#125;; streamify() 像是一个WebSocket异步迭代器： oncePromise() 使用 .addEventListener() 去监听事件一次, 然后resolves Promise. 通过while (true)循环 , 我们可以一直监听事件。 12345678// Only pass along events that meet a conditionvar filter = async function\\*(stream, test) &#123; for await (var event of stream) &#123; if (test(event)) &#123; yield event; &#125; &#125;&#125;; filter() 会只允许通过test的事件被 yield. map()几乎是相同的: 123456// Transform every event of the streamvar map = async function\\*(stream, transform) &#123; for await (var event of stream) &#123; yield transform(event); &#125;&#125;; map()可以简单地在yield之前变换事件。distinct()展示了异步generator的其中一个强大的功能：它可以保存局部变量! 1234567891011121314var identity = e =&gt; e;// 只允许与最后一个不相同的事件通过var distinct = async function\\*(stream, extract = identity) &#123; var lastVal; var thisVal; for await (var event of stream) &#123; thisVal = extract(event); if (thisVal !== lastVal) &#123; lastVal = thisVal; yield event; &#125; &#125;&#125;; 最后，强大的throttle()函数和distinct()很像：它记录最后一个事件的时间，且只允许超过最后一次yield事件一个确定的时间的事件通过。 123456789101112// 只允许超过最后一次事件确定时间的事件通过。var throttle = async function\\*(stream, delay) &#123; var lastTime; var thisTime; for await (var event of stream) &#123; thisTime = (new Date()).getTime(); if (!lastTime || thisTime - lastTime &gt; delay) &#123; lastTime = thisTime; yield event; &#125; &#125;&#125;; 我们做了这么多，最后，我们还需要打印出每次的点击事件和当前的次数。subscribe()做了一些零碎的事情：它在每一次事件循环的时候运行，并执行callback，所以没有必要使用yield。 123456// 每次事件到达都调用一次回调函数var subscribe = async (stream, callback) =&gt; &#123; for await (var event of stream) &#123; callback(event); &#125;&#125;; 到这里，我们已经写了一个我们自己的反应型函数式管道！ 你可以在这里获取到所有的例子的代码和要点。 挑战异步generators是如此的优雅。而generator函数允许我们从迭代器中回去数据，异步generators可以让我们迭代“推送”过来的数据。这是多么好的异步数据结构的抽象。当然，也有一些注意事项。 首先，对一个objects增加支持for await...of的功能有一些粗糙，除非你可以避免使用yield和await。尤其是，使用.addEventListener（）转换任何东西都很棘手，因为你不可以在一个回调中使用yield操作: 1234567var streamify = async function\\*(event, element) &#123; element.addEventListener(event, e =&gt; &#123; // 这里将无法运行，因为yield // 不可以在一个普通函数中被使用 yield e; &#125;);&#125;; 同样的，你也不可以在.forEach()和其他函数型的方法中使用yield。这是一个固有的限制因为我们不能保证在generator已经完成后不使用yield。 为了绕过这个问题，我们写了一个oncePromise()函数来帮组我们。撇开一些潜在的性能问题，需要注意的是Promise的回调总是在当前的调用堆栈结束之后执行。在浏览器端，类似microtasks一样运行Promise的回调是不会出现问题的，但是一些Promise的polyfill在下一次事件循环运行之前是不会运行callback。因此，调用.preventDefault()函数有时候会没有有效果，因为可能DOM时间已经冒泡到浏览器了。 JavaScript现在已经有了多个异步流数据类型：Stream, AsyncGenerator和最后的Observable。虽然三个都是属于“推送”数据源，但是在处理回调和控制底层资源上还是有一些微妙的语义上的不同。如果你想了解更多关于反应函数式语法的细节，可以浏览General Theory of Reactivity. 更多在程序语言的竞赛中，JavaScript不是一个懒鬼。ES2015中的变量的解构赋值，ES2016中的异步函数，而现在的异步迭代器可以使JavaScript使用优雅的解决复杂UI和I/O编程的问题而不是使用充满不可控的多线程方案。 除此之外，还有很多的新内容和新特性！所以请关注博客和TC39 proposals repo来获取最新的好东西。同时，你也可以通过在Babel中开启Stage 3 提案的方式在你的代码中使用异步generator函数。 你是否有兴趣学习网页平台的下一代的JavaScript? 欢迎来我们的前端训练营, 或者 我们可以提供企业培训g!","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Javascript异步编程","date":"2017-01-31T12:30:39.000Z","path":"2017/01/31/Javascript-async-programming/","text":"随着es6的发布和Babel的出现，对于异步编程，我们慢慢告别了之前回调地狱的问题，现在的我们有了更多的选择，例如：Promise， generator， async/await等方案。下面我们一一来了解一下： ###PromisePromise在ES6发布之前就已经有很多的库和工具实现了这个功能，例如Jquery，p等等, Promise做到了将原来的回调地狱的方式，改为了链式返回，在一定程度上改善了异步编程的问题。 123456789101112131415var p1 = new Promise(function (resolve, reject) &#123; setTimeout(function() &#123; console.log(&apos;resolve&apos;); resolve(&apos;done&apos;); &#125;, 1000);&#125;);p1.then(function(data)&#123; // success console.log(data)&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&apos;发生错误！&apos;, error);&#125;); ###GeneratorGenerator是ES6中新增的语法，Generator可以做到在函数执行过程中停止和继续进行，从而使异步函数可以以同步编程的方式编写，在异步的地方停止，在异步函数执行完后继续执行Generator函数。 在调用generator函数时，并不会执行函数内容，而是会返回一个迭代器（iterator）对象, 在执行迭代器的next()函数(next()函数是iterator的属性)时可以逐步执行generator函数内容。 注：一个对象要想可以生成迭代器，该对象需要有“Symbol.iterator”属性 12345678910function* gen()&#123; var url = &apos;https://api.github.com/users/github&apos;; var result = yield fetch(url); console.log(result); yield 1;&#125;//在chrome控制台中输出&gt; gen.prototype[Symbol.iterator]//function [Symbol.iterator]() &#123; [native code] &#125; 让我们运行 gen() 12345678910111213var g = gen();var a = g.next();console.log(a);//&#123;value: Promise, done: false&#125;a = g.next();console.log(a);//&#123;value: 1, done: false&#125;a = g.next();console.log(a);//&#123;value: undefined, done: true&#125; 对于上面的结果，我们也可以参看babel对于Generator的实现，不过这并不是官方的方案，只是可以作为理解Generator的一个帮助 12345678910111213141516171819202122232425function gen() &#123; var url, result; return regeneratorRuntime.wrap(function gen$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: url = &apos;https://api.github.com/users/github&apos;; _context.next = 3;//设置下一个起始点 return fetch(url);//输出yield后面的表达式 case 3: result = _context.sent; console.log(result); _context.next = 7;//设置下一个起始点 //输出yield后面的表达式 return 1; case 7: case &apos;end&apos;: return _context.stop(); &#125; &#125; &#125;, _marked[0], this);&#125; 由此，我们也可以猜测调用Generator的时候，调用了gen.prototype[Symbol.iterator]，该函数相当于是把我们的代码根据标签yield进行分割，存储在一个“列表”中，并返回了一个迭代器，其中含有next属性，虽随着next的调用，一步步地执行“列表”中的每一段函数。 当我们运行的时候会发现上面的console.log(result);输出了undefined,这是为什么呢，因为Generator只是负责代码的停止和执行，它并不会等待后面的异步结束，而且一步步的写next太麻烦了，能不能让Generator自己执行到结束呢？ 当然可以！ 但是只有Generator并不能做到这些，因为Generator不知道异步代码什么时候结束，但是Promise知道啊，所以我们还需要上面所说的Promise。 为了方便大家理解，我们一步步来，我们先实现Generator的自执行,在每次调用next()时，都会返回一个对象，包含yield后面语句的执行的返回值和一个是否完成全部Generator函数的标记done,我们可以不断调用next直到done === true为止，就完成了Generator的自执行 123456789101112131415161718192021function* gen()&#123; yield 1; yield 2; yield 3; yield 4; yield 5;&#125;function run(fn) &#123; var gen = fn(); function next(data) &#123; var result = gen.next(data); if (result.done) return; next(result); &#125; next();&#125;run(gen); 接下来我们需要在上面的基础上引入Promise，现在我们的run函数中一个我们自己写的next函数，显而易见的，我们只需要稍微改动一下这个函数即可。为了方便，我们还写了一个readFile函数模仿异步代码，它会返回一个Promise并在1000ms后resolve。 1234567891011121314151617181920212223242526272829303132333435var readFile = function(filename) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(filename); &#125;, 1000); &#125;);&#125;function* gen() &#123; var a = yield readFile(&apos;1&apos;); console.log(a); a = yield readFile(&apos;2&apos;); console.log(a); a = yield readFile(&apos;3&apos;); console.log(a);&#125;var run = function(gen) &#123; var g = gen(); function next(err, data) &#123; var result = g.next(data); if (!result.done) &#123; result.value.then(function(data) &#123; next(null, data); return data; &#125;); &#125; else &#123; console.log(&apos;done&apos;); &#125; &#125; next();&#125;;run(gen); 上面的run函数有一个问题，现在我们默认yield后面一定是一个返回Promise的函数，那很多时候不一定会是这样，所以我们还需要一个转换器，把一切的对象都转为Promise，这个我们这里不再实现，具体可以参看TJ大神写的co。 async/await在ES6的基础上，ES2017提供了async函数，这将得异步操作变得更加方便。我们把我们上面的gen函数用async/await改写一下。其实就是去除*，加上async, 所有的yield改为await就好了 1234567891011async function gen() &#123; var a = await readFile(&apos;1&apos;); console.log(a); a = await readFile(&apos;2&apos;); console.log(a); a = await readFile(&apos;3&apos;); console.log(a);&#125;gen() 上面的代码会和上一节我们最后的代码结果一样，这是得益于async自带有自执行和异步等待。我们就不用再写自己的自执行函数和异步代码等待的逻辑了。await命令后面，可以是Promise对象，也可以是其他原始类型（数值、字符串和布尔值，数组等），是不是很酷炫。 另外不同Generator返回一个迭代器，async函数返回一个Promise对象 所以上面的例子我们还可以加上 123gen().then(function()&#123; console.log(&apos;123&apos;)&#125;) async/await很酷，但是现在浏览器还是没有完全支持，Node端只有7.0以上才可以使用，所以还是要使用Babel。 结束：随着ES6的发布，我们的异步代码方案也越来越趋于成熟了","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"modules","date":"2017-01-28T05:38:15.000Z","path":"2017/01/28/modules/","text":"Modules 访问main模块 另外：包管理器小提示 All Together 缓存 Module Caching Caveats（模块缓存警告） Core Modules(核心模块) Cycles(循环依赖) File Modules(文件模块) Folders as Modules(文件夹做为模块) Loading from node_modules Folders(从node_modules文件夹中加载模块) Loading from the global folders(从全局文件中导入模块) The module wrapper(包裹模块) The module Object(module对象) module.children module.exports exports alias(exports别名) module.filename module.id module.loaded module.parent module.require(id) Modules稳定性: 3 - locked Node.js has a simple module loading system. In Node.js, files and modules are in one-to-one correspondence. As an example, foo.js loads the module circle.js in the same directory. Node.js 有一个简单的模块加载系统。在Node.js中文件和模块是一一对应的。例如，foo.js加载了同级目录下的circle.js模块 foo.js的内容 12const circle = require(&apos;./circle.js&apos;);console.log(`The area of a circle of radius 4 is $&#123;circle.area(4)&#125;`); circle.js的内容 12345const PI = Math.PI;exports.area = (r) =&gt; PI * r * r;exports.circumference = (r) =&gt; 2 * PI * r; circle.js模块输出了area()和circumference()函数。你可以在特殊的exports对象上增加函数和对象，来把函数和对象增加到模块的根作用域下。 本地变量在模块中是私有的，因为在Node.js中模块会被一个函数所包裹（详见module wrapper）,上面的例子中，变量PI对于circle.js是私有的 如果你想要模块输出一个函数（类似构造函数）或者想要一次输出一个完整的对象而不是每次创建一个属性，就把它绑定在module.exports上，而不是exports。 下面， bar.js使用了square模块，而square模块则输出的是一个构造函数： 123const square = require(&apos;./square.js&apos;);var mySquare = square(2);console.log(`The area of my square is $&#123;mySquare.area()&#125;`); square模块定义在square.js中： 123456// 绑定在exports上不会修改当前模块，必须要使用module.exports module.exports = (width) =&gt; &#123; return &#123; area: () =&gt; width * width &#125;;&#125; 模块系统在require（“module”）模块中实现。 访问main模块当一个文件是直接被Node.js运行的，require.main被设置为它的module,这就是说你可以你可以通过以下的方式来判断一个文件是否是直接被Node.js运行的。 1require.main === module 对于文件foo.js，如果是通过执行node foo.js来运行的，上面的测试就会返回true，而如果是通过require(&#39;./foo&#39;)的方式来运行的，则会返回false。 因为模块都有一个filename属性（一般等同于__filename）, 当前项目会通过核对require.main.filename来获得入口点。 另外：包管理器小提示Node.js的require()函数的语义被设计为足够通用以来支持很多合理的目录结构。dpkg，rpm和npm等包管理系统希望能够在不修改的情况下从Node模块中构建本地包。 下面是一些我们我们建议的有效的目录结构： 我们希望保存一个包的一个特定版本的内容下/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;的文件夹中。 包可能依赖于其他的包。为了安装一个foo包，我们可能需要安装一个特定版本bar包。在某些情况下，bar可能还有他自己的依赖。这些依赖性甚至可能碰撞或形成循环。 因此Node.js寻找它加载的任何模块的真实路径（relapath），然后寻找模块的中node_modules 文件夹中的模块依赖关系，这种形式可以很简单的解决以下的文件结构： /usr/lib/node/foo/1.2.3/ - 版本1.2.3的foo的内容。 /usr/lib/node/bar/4.3.2/ - foo依赖的bar包的内容 /usr/lib/node/foo/1.2.3/node_modules/bar - 链接到的/usr/lib/node/bar/4.3.2/符号 /usr/lib/node/bar/4.3.2/node_modules/* - bar包的所有依赖的链接符号 因此，即使遇到依赖形成循环，或者依赖有冲突，每个模块都可以获取到可以用的版本的依赖。 当foo包代码中有require(&#39;bar&#39;)，它会得到链接到/usr/lib/node/foo/1.2.3/node_modules/bar的版本。当bar包中引用了require(&#39;quxux&#39;),它会得到链接到/usr/lib/node/bar/4.3.2/node_modules/quux的版本 此外，为了使模块查找的过程更加优化，我们可以吧包放在/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;中，而不是直接放在/usr/lib/node。这样Node.js就不用麻烦的在/usr/node_modules或者/node_modules寻找缺少的依赖。 为了使模块可以被Node.js的交互式解析器（REPL）使用。可以将/usr/lib/node_modules文件夹添加为$NODE_PATH环境变量。因此模块查找的node_modules都是相互关联的，require()都是基于文件的绝对地址来引用的，所以包可以放在任何地方。 All Together为了在require()的时候获取到精确的文件名字，会使用require.resolve()函数。 下面是require.resolve()的高级算法的伪码： 1234567891011121314151617181920212223242526272829303132333435363738394041在路径为Y的模块中require(X)1. 如果X为核心模块， a. 返回核心模块 b. 停止2. 如果X是以&apos;./&apos;,&apos;/&apos;或者&apos;..&apos;开头 a. LOAD_AS_FILE(Y + X) b. LOAD_AS_DIRECTORY(Y + X)3. LOAD_NODE_MODULES(X, dirname(Y))4. 抛出 &quot;not found&quot;LOAD_AS_FILE(X)1. 如果X是一个文件，以Javascript文本的方式导入X。停止寻找2. 如果X.js是一个文件，以Javascript文本的方式导入X.js。停止寻找3. 如果x.json是一个文件，格式化X.json为一个对象。停止寻找4. 如果X.node是一个文件，以二进制插件的方式导入X.node。停止寻找LOAD_AS_DIRECTORY(X)1. 如果X/package.json是一个文件 a. 解析X/package.json ,然后寻找“main”字段 b. let M = X + (json main field) c. LOAD_AS_FILE(M)2. 如果X/index.js是一个文件，以Javascript文本的方式导入X/index.js。停止寻找3. 如果X/index.json是一个文件，格式化X/index.json为一个对象。停止寻找4. 如果X.node是一个文件，以二进制插件的方式导入X/index.node。停止寻找LOAD_NODE_MODULES(X, START)1. let DIRS=NODE_MODULES_PATHS(START)2. for each DIR in DIRS: a. LOAD_AS_FILE(DIR/X) b. LOAD_AS_DIRECTORY(DIR/X) NODE_MODULES_PATHS(START)1. let PARTS = path split(START)2. let I = count of PARTS - 13. let DIRS = []4. while I &gt;= 0, a. if PARTS[I] = &quot;node_modules&quot; CONTINUE c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;) b. DIRS = DIRS + DIR c. let I = I - 15. return DIRS 缓存模块在第一次被加载之后就会被缓存。这就是说每一次调用require(&#39;foo&#39;)都会返回一个相同的对象，当然前提是每一次require都指向同一个文件。 多次调用require(&#39;foo&#39;)不会是模块代码被多次执行。这是一个很重要的特性。因为这个特性，“部分完成”的对象可以被返回，因此允许传递性的依赖甚至是形成循环的依赖都可以被加载。 如果你想要一个模块被解析多次，然后输出一个函数，并且执行那个函数。 ##Module Caching Caveats（模块缓存警告）模块是基于他们的解析后的路径（require.resolve()）来缓存的。由于模块基于调用模块的位置（从node_modules文件中加载）不同会被解析为不同的文件名字，如果模块会被解析到不同的文件，这就不能保证require(&#39;foo&#39;)会一直返回完全相同的对象。 ##Core Modules(核心模块)Node.js有一些模块会被编译成二进制文件。这些模块在文档的其他的地方有更加详细的说明。 这些核心模块被定义在Node.js的源代码中，被放置在lib/文件夹中。 这些核心模块在通过require()调用时会一直被优先加载。例如，require(&#39;http&#39;)会一直返回内置的HTTP模块，即使目录下有一个文件名是http的文件。 ##Cycles(循环依赖)当require()被循环调用，模块可能会返回一个未完成执行的对象。 比如以下这种情况： a.js 123456console.log(&apos;a starting&apos;);exports.done = false;const b = require(&apos;./b.js&apos;);console.log(&apos;in a, b.done = %j&apos;, b.done);exports.done = true;console.log(&apos;a done&apos;); b.js 123456console.log(&apos;b starting&apos;);exports.done = false;const a = require(&apos;./a.js&apos;);console.log(&apos;in b, a.done = %j&apos;, a.done);exports.done = true;console.log(&apos;b done&apos;); main.js 1234console.log(&apos;main starting&apos;);const a = require(&apos;./a.js&apos;);const b = require(&apos;./b.js&apos;);console.log(&apos;in main, a.done=%j, b.done=%j&apos;, a.done, b.done); 当main.js加载a.js，a.js反过来需要加载b.js。同时，b.js试图加载a.js。为了避免一个无限的循环，一个未完成的a.js的exports对象的拷贝被返回给b.js模块。然后当b.js模块加载完成了，它的exports对象再提供给a.js模块。 当main.js加载这两个模块时，它们都已经完成了。 这个程序的输出将是: 123456789$ node main.jsmain startinga startingb startingin b, a.done = falseb donein a, b.done = truea donein main, a.done=true, b.done=true 如果你的项目中有循环的模块依赖，请确保代码按照计划的执行。 ##File Modules(文件模块)如果准确文件名没有找到，Node.js会尝试去加载提供的文件名后面加上.js, .json, 最后是.node的文件。 .js文件会被作为Javascript文本文件被解释，.json文件会被当做JSON本文文件解析，.node会被当做编译好的插件模块被解释，并且被dlopen加载。 引用的模块的前缀为’/‘是文件的绝对路径。 例如，require（&#39;/home/marco/foo.js&#39;将加载/home/marco/foo.js下的文件。 引用的模块的前缀为’./‘是当前调用require()文件的相对路径。 例如，foo.js中依赖require（&#39;./corcle&#39;则要求circle.js必须要与foo.js在相同的目录下。 如果不是以&#39;/&#39;, &#39;./&#39;, 或者&#39;../&#39;来表示一个文件，则模块一定是一个核心模块或者是从node_modules文件中加载 如果提供的路径不存在， require()会抛出一个错误，错误信息是&#39;MODULE_NOT_FOUND&#39;。 Folders as Modules(文件夹做为模块)可以很方便将项目和或者库组织在一个自定义的目录中，然后对外提供这个库的一个简单的入口。有三种方式可以将文件夹传递给require()作为参数。 第一种方式是创建一个package.json文件在文件夹的根目录下，同时指定一个main模块。一个简单的package.json的文件可能是如下的样子： 12&#123; &quot;name&quot; : &quot;some-library&quot;, &quot;main&quot; : &quot;./lib/some-library.js&quot; &#125; 如果这个package.json文件在./some-library中，那么当require(&#39;./some-library&#39;)会试图去加载./some-library/lib/some-library.js。 这是Node.js对package.json文件的意识程度。 备注：如果package.json文件中未定义main条目，则无法被解析，Node.js会报告整个模块没有被查找的默认错误: 1Error: Cannot find module &apos;some-library&apos; 如果目录下面没有package.json，则Node.js获取尝试从该目录加载一个index.js或者index.node。比如，如果上面的例子中没有package.json文件，那么require(&#39;./some-library&#39;)会尝试加载 ./some-library/index.js ./some-library/index.node ##Loading from node_modules Folders(从node_modules文件夹中加载模块)如果模块加载时传递给require()的标识符不是原生模块，也不是以’/‘, ‘../‘, 或者’./‘开头的，那么Node.js会从当前模块的父目录开始，然后在标识符前加上/node_modules，并且尝试从加上以后的路径下加载文件。Node不会再已经是以node__modules结尾的路径上再加上node_modules。 如果在父目录下找不到，则寻找再上一层的目录，一直找到根目录下。 比如，’/home/ry/projects/foo.js’的文件调用了require(&#39;bar.js&#39;)，那么Node.js会以下面这个顺序依次寻找寻： /home/ry/projects/node_modules/bar.js /home/ry/node_modules/bar.js /home/node_modules/bar.js /node_modules/bar.js 这样可以本地化项目的依赖，并且使这些依赖不冲突。 You can require specific files or sub modules distributed with a module by including a path suffix after the module name. For instance require(‘example-module/path/to/file’) would resolve path/to/file relative to where example-module is located. The suffixed path follows the same module resolution semantics. ##Loading from the global folders(从全局文件中导入模块)如果环境变量NODE_PATH是一系列由冒号分割绝对路径组成的列表，那么Node.js如果在其他地方没有找到需要的模块则会在这些路径查询模块。（备注：在windows下，NODE_PATH是由分号分割的） NODE_PATH一开始设计是为了支持在现在的模块解析算法确定之前从不同路径加载模块。（这里的意思是说Node发展的一开始模块解析的算法还没有完成之前，是通过NODE_PATH来解决从不同的路径加载模块的问题） NODE_PATH现在依旧支持上面说的这个功能，但是在Node.js生态系统中有了定位依赖的约定（就是上面说的一大堆的模块查询规则）之后就不是那么有必要。有时候依赖于NODE_PATH的项目在部署而当人们不知道NODE_PATH必须要被设置时会发生一些奇怪的表现。有时候模块的依赖发生改变，引起NODE_PATH查询时会加载一个版本不同的模块（甚至是一个不同的模块）。 另外，Node.js会查询下面的路径 $HOME/.node_modules $HOME/.node_libraries $PREFIX/lib/node 当$HOME是用户的home目录，那么Node.js中$PREFIX会被设置为node_prefix。 这个主要是出于历史原因。你最好将你的依赖本地化在node_modules文件夹中。这样依赖会被更加可靠且快速的被加载 The module wrapper(包裹模块)在模块代码执行之前，Node.js会将它包裹在一个函数中，使其看起来像下面这个样子： 123(function (exports, require, module, __filename, __dirname) &#123;// Your module code actually lives in here&#125;); 通过这样，Node.js实现了以下事情 保证了模块中定义的顶级变量（通过var,const或者let定义的）会在module的作用域中而不是在全局。 这样可以提供一些指定给模块的变量去像是全局变量，例如： 可以使用module和exports来在模块里对外暴露一些变量 包含了模块的文件名的绝对路径和模块本身的绝对路径的__filename和__dirname变量方便被使用 ##The module Object(module对象)Added in: v0.1.16 在每个模块中，自由变量module是当前模块对象的引用。为了方便，在模块中moduls.exports也可以直接通过exports来使用。module变量实际上不是全局的，而是每个模块内部的。 ###module.childrenAdded in: v0.1.16 这个模块需要的对象（？？不知道是不是指这个模块依赖的所有模块） ###module.exportsAdded in: v0.1.16 module.exports是由模块系统创造的。有时候这是不可接受的。很多人希望他们的模块是一些类的实例。为了做到这个，分配需要export对象给module.exports。请注意，分配需要export对象给的exports会很容易被修改,而这个不是我们希望你做的。 例如，假设我们我们写的一个模块调用了a.js 123456789const EventEmitter = require(&apos;events&apos;);module.exports = new EventEmitter();// Do some work, and after some time emit// the &apos;ready&apos; event from the module itself.setTimeout(() =&gt; &#123; module.exports.emit(&apos;ready&apos;);&#125;, 1000); 接下来在另外一个文件中我们这么做 1234const a = require(&apos;./a&apos;);a.on(&apos;ready&apos;, () =&gt; &#123; console.log(&apos;module a is ready&apos;);&#125;); 注意：分配个给module.exports的内容必要立即完成。它不可以在任何一个回调中完整，下面这个例子将失败：x.js 123setTimeout(() =&gt; &#123; module.exports = &#123; a: &apos;hello&apos; &#125;;&#125;, 0); y.js 12const x = require(&apos;./x&apos;);console.log(x.a); ####exports alias(exports别名)Added in: v0.1.16在模块中exports变量可在作为module.exports的引用。与任何的变量一样，一旦你指定了新的变量给exports，则不在绑定之前的变量。为了说明这种情况，我们假设require()是这样执行的： 12345678910function require(...) &#123; // ... ((module, exports) =&gt; &#123; // Your module code here exports = some_func; // re-assigns exports, exports is no longer // a shortcut, and nothing is exported. module.exports = some_func; // makes your module export 0 &#125;)(module, module.exports); return module;&#125; 作为指导，exports和module.exports的关系视乎有些神奇，忽略exports仅适用module.exports。 ####module.filenameAdded in: v0.1.16 模块完整的解析文件名。 ####module.idAdded in: v0.1.16 模块的标识符，通常是模块完整的解析文件名。 module.loadedAdded in: v0.1.16 判断module是否已经加载完成，或者正在加载中。 ####module.parentAdded in: v0.1.16 模块对象第一个加载本模块的父模块对象。 ####module.require(id)Added in: v0.5.1 id Return: 解析到的模块的module.exportsmodule.require方法提供了一个记载模块的方式，就像从原始模块调用require()一样。 备注：为了实现这个，你必须拿到module对象的引用。由于require()是返回module.export对象,且module通常是只在模块中特定的代码中可用，因此它必须被显式到处以便使用。","tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"querystring","date":"2017-01-28T05:34:08.000Z","path":"2017/01/28/querystring/","text":"目录 Query String querystring.escape(str) querystring.parse(str[, sep[, eq[, options]]]) querystring.stringify(obj[, sep[, eq[, options]]]) querystring.unescape(str) #Query String 稳定性：2 - 稳定quertstring 模块提供了一系列用于解析和格式化url参数的工具，它可以被如下使用1const querystring = require(&apos;querystring&apos;); querystring.escape(str)加入：v0.1.25 str \\querystring.escape() 可以对字符串进行百分比编码，同时针对url查询字符串的特定要求进行了优化 querystring.escape()被querystring.stringify()使用，但是一般不推荐直接使用。主要在应用程序代码在必要的时候被用来分配给替代函数来实现百分比编码 ？？ querystring.parse(str[, sep[, eq[, options]]])加入：v0.1.25 str \\ 待解析的url查询字符串 sep \\ 用于分界查询字符串中每对key与value的字符串，默认为&#39;&amp;&#39;. eq \\ 用于分界查询字符串中key与value的字符串，默认为&#39;=&#39;. options \\ decodeURIComponent \\ 设置一个函数解码百分比编码的查询字符串，默认使用querystring.unescape(). maxKeys \\ 指定编码时key数量最多为多少。默认是1000，设置为0则表示不限数量querystring.parse()函数可以解析一个url的查询字符串（str）为一个键值对（key：value）的集合例如，一个查询字符串为&#39;foo=bar&amp;abc=xyz&amp;abc=123&#39;可以被解析为1234&#123; foo: &apos;bar&apos;, abc: [&apos;xyz&apos;, &apos;123&apos;]&#125; 注：querystring.parse()返回的对象不是原型继承于Javascript的Object对象，所以类似obj.toString(), obj.hasOwnProperty()等典型的Object对象的方法将无法使用 默认情况下，百分比编码查询字符串时会使用UFT-8编码，如果使用代替字符编码，则需要指定代替字符的decodeURIComponent选项，如下例子12// 假定 gbkDecodeURIComponent 函数已经存在..querystring.parse(&apos;w=%D6%D0%CE%C4&amp;foo=bar&apos;, null, null, &#123; decodeURIComponent: gbkDecodeURIComponent &#125;) ##querystring.stringify(obj[, sep[, eq[, options]]]) 加入：v0.1.25 obj \\ 要被序列化为查询字符串的对象. sep \\ 用于分界查询字符串中每对key与value的字符串，默认为&#39;&amp;&#39;. eq \\ 用于分界查询字符串中key与value的字符串，默认为&#39;=&#39;. options encodeURIComponent \\ 在转换查询字符传时把url中不安全的的字符串转换为百分比编码的函数.默认使用querystring.escape().querystring.stringify()函数是通过遍历对象的“own properties“来生成url查询字符串例子：12345querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;)// returns &apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;querystring.stringify(&#123;foo: &apos;bar&apos;, baz: &apos;qux&apos;&#125;, &apos;;&apos;, &apos;:&apos;)// returns &apos;foo:bar;baz:qux&apos; 一般，查询字符串中需要百分比编码的字符会被编码为UTF-8格式。如果需要代替的编码，那么将需要指定另一个encodeURIComponent选项，如以下示例所示1234// 假定 gbkEncodeURIComponent 函数已经存在,querystring.stringify(&#123; w: &apos;中文&apos;, foo: &apos;bar&apos; &#125;, null, null, &#123; encodeURIComponent: gbkEncodeURIComponent &#125;) ##querystring.unescape(str)加入：v.0.1.25 str \\querystring.unescape()方法可以对提供的字符串进行url的百分比编码.The querystring.unescape() method is used by querystring.parse() and is generally not expected to be used directly. It is exported primarily to allow application code to provide a replacement decoding implementation if necessary by assigning querystring.unescape to an alternative functionquerystring.unescape()方法被querystring.parse()函数所使用，一般来说也不推荐直接使用该函数。主要在应用程序代码在必要的时候被用来分配给替代函数来实现替换解码？？默认情况下，querystring.unescape()函数会尝试使用基于decodeURIComponent()方法来进行解码，这样即使解码失败了，也会输出一个更加安全等效的结果，而不会输出一个错误的url","tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"反思JavaScript: 通过函数代替break","date":"2017-01-27T11:05:17.000Z","path":"2017/01/27/rethinking-javascript-break-is-the-goto-of-loops/","text":"原文：https://hackernoon.com/rethinking-javascript-break-is-the-goto-of-loops-51b27b1c85f8#.k2oyppp5i 在我的上一篇文章 Death of the for Loop中，我试图去说服你放弃使用for 循环改用函数式的解决方案。反过来，你提出了一个很好的问题，那么for循环中break怎么办？ break 会相当于循环中的GOTO，我们应该避免使用。 break 应该像GOTO一样被废弃。 你可能会想“算了吧Joel，你这只是耸人听闻，break怎么可能会像GOTO一样？” 1// bad code. no copy paste. 1234567outer: for (var i in outerList) &#123;inner: for (var j in innerList) &#123; break outer; &#125; &#125; 我可以提供标记作为证明。在其他语言中，标记和GOTO是相互对应的。在JavaScript，标记与break和continue也是相互对应的。因为break和continue来自于相同标记组，这也导致了它们和GOTO很像。 JavaScript标签，break和continue是GOTO和非结构化编程时代的遗留 xkcd “但是如果它没有伤害任何人，那么我们为什么不把它留下语法中，而我们可以选择其他的方案？” 我们为什么限制我们如何编写软件?这个听上去有些违背直觉，但是限制是一个好事。限制我们使用GOTO就是一个很好的例子。我们也很欢迎限制我们的“use strict”，甚至批评不使用它的人。 “limitations can make things better. A lot better. “— Charles Scalfani 限制（规则）可以使我们写出更好的代码。 为什么编程需要限制_限制使艺术，设计，生活更美好._medium.com 我们对于break的选择是什么?我不是要做一个虚有其表的事情，但是也没有一个方案可以适合所有的情况。 这是一个完全不同的编程方式。 一个完全不同的思考方式。函数式编程的思想。 有一个好消息是，有很多的库和工具可以帮助我们，例如Lodash, Ramda, lazy.js, 递归等等 我们将从一个简单的cats集合和一个isKitten函数开始，这些将在下面所有的例子中被用到。 123456const cats = [ &#123; name: &apos;Mojo&apos;, months: 84 &#125;, &#123; name: &apos;Mao-Mao&apos;, months: 34 &#125;, &#123; name: &apos;Waffles&apos;, months: 4 &#125;, &#123; name: &apos;Pickles&apos;, months: 6 &#125;] 1const isKitten = cat =&gt; cat.months &lt; 7 让我们从一个我们熟悉的for循环的例子开始。它会遍历我们的cats，然后当找到第一只小猫的时候退出循环。 1var firstKitten 123456for (var i = 0; i &lt; cats.length; i++) &#123; if (isKitten(cats[i])) &#123; firstKitten = cats[i] break &#125;&#125; 现在，让我们和lodash中一个相同作用的例子做比较。 1const firstKitten = _.find(cats, isKitten) 这个例子相当的简单。接下来让我们尝试一些边缘情况吧。现在我们改为遍历cat集合，然后选出前5只小猫，然后退出循环。 1var first5Kittens = [] 1234// old-school edge case kitty loopfor (var i = 0; i &lt; cats.length; i++) &#123; if (isKitten(cats[i])) &#123; first5Kittens.push(cats[i]) 12345 if (first4Kittens.length &gt;= 5) &#123; break &#125; &#125;&#125; 简单的方式lodash是一个很好的库也可以坐很多的事情，但是有时候你需要一些其他更加专业的工具。这里我们介绍一个新朋友, lazy.js. “像Underscore，但是更加偷懒”。但是偷懒就是我们想要的. 123const result = Lazy(cats) .filter(isKitten) .take(5) 困难的方法库都是有趣的，但是有时候真正有趣的是从头开始创造东西。 所以我们可以创建一个通用的函数，让它可以像filter一样使用也可以增加限制的功能。 第一步就是把我们上面写的边缘情况的for循环封装在一个函数中。 接下来，让我们是这个函数更加通用并且遍历所有cat具体的内容。使用limit来代替5,predicate来代替isKitten，list来代替cats。然后把这些作为函数的参数。 现在我们有了一个可用的且可重复的takeFirst函数，这个可以让我们完全不用去关心我们cat的逻辑实现！ 我们的函数现在依旧还是一个纯函数。也就是说函数的输出只和输入的参数有关。如果传入相同的参数，一定会得到相同的结果。 现在我们已经还是有那个肮脏的for循环，所以让我们继续重构。下一步就是把i和newList放入参数列表。 当limit变为0的时候 (limit会在递归过程中减少)或者是遍历完了列表，我们希望可以退出递归(isDone)。 如果递归还在进行，我们将会核对是否有符合我们的过滤条件predicate的值。如果当前值符合过滤条件，我们会调用takeFirst，减少limit并把当前值保存在我们的newList中，否者，移动到列表的下一个值。 如果你还没有看过Rethinking JavaScript: The if statement，它会解释这个用三元表达式代替if‘的最后一步。 Rethinking JavaScript: The if statement_Thinking functionally has opened my mind about programming._medium.com 现在我们像下面这样调用我们的新方法： 1const first5Kittens = takeFirst(5, isKitten, cats) 为了兼容更多的情况，我们可以柯里化takeFirst，然后使用它去创建一些其他的函数（关于柯里化的介绍在另一篇文章中） 12const first5 = takeFirst(5)const getFirst5Kittens = first5(isKitten) 1const first5Kittens = getFirst5Kittens(cats) 总结现在有很多优秀的库例如 lodash, ramda和lazy.js供我们使用。但是如果我们足够大胆，也可以使用递归来创建我们自己的函方法。 我必须要警告虽然takeFirst看上去很酷 但是使用递归是有得也有失的. 递归在Javascript中是很危险的，它很容易就会导致超出最大调用堆栈大小的报错。 我将会在我的下一篇文章中重写JavaScript的递归。敬请关注。 我知道这只是一件小事，但是当我收到来自Medium和Twitter (@joelnet)的follow通知时会使我很开心。当然，如果你觉得我实在胡说八道，你也可以在下面的讨论区告诉我。 Cheers!","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Node学习之路：require()工作原理","date":"2017-01-27T07:23:25.000Z","path":"2017/01/27/how-require-actually-works/","text":"原文：http://thenodeway.io/posts/how-require-actually-works/ 介绍 Node学习之路 掌握的基本知识 理解回调函数中的错误优先 测试要点 进阶 单例模式 设计自定义类型 工厂模式 高级 require() 工作原理 危险的模块设计模式 几乎所有的Node.js开发者都可以说出require()的作用，但是又有多少人真正知道require()是如何工作的呢。我们几乎每天都会使用它去加载库和模块，但是它的原理还是一个谜。 因为好奇，我查看了Node的核心源码去寻找答案。但是我不是找到了一个函数，而是找到了Node的核心模块:module.js。这个文件惊人的强大，它包含了文件的加载，编译，并且可以缓存所有使用过的文件。对外使用的require()只是冰山一角。 module.js12345function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; // ... module.js里的模块类型在Node.js中有两个主要的作用。第一，它为所有的Node.js模块提供了一个函数用于编译。每一个文件在这个基础模块中运行后都会返回一个新的实例，即使这个文件运行了也还是会存在。这就是为什么我们可以随时使用 module.exports并且可以返回它。 这个模块的第二个主要的作用就是管理Node模块加载机制。这个独立的require函数其实是module.require的一个引用，而module.require只是一个把Module._load简单包裹了一下（wapper）。这个函数才是真正控制文件的加载的，接下来我们通过这个函数继续我们的探索。 Module._load12345678Module._load = function(request, parent, isMain) &#123; // 1\\. 检查 Module._cache 是否有缓存 // 2\\. 如果没有缓存则创建一个新的模块实例 // 3\\. 将模块实例保存到缓存中 // 4\\. 通过给予的filename去调用module.load()，然后调用module.compile()去读取文件内容 // 5\\. 如果文件的载入和解析过程中发生错误，删除缓存中的该模块 // 6\\. 返回 module.exports&#125;; Module._load是一个负责新模块的加载和管理模块缓存的函数。缓存所有加载过的模块可以减少文件的重复加载并且明显地加快你的应用。此外，共享模块的实例可以把模块像单例来使用，可以在整个项目的运行中都可以保存它的状态。 如果一个模块不存在在缓存中，Module._load 会为这个文件创建一个新的基础模块。Module._load会通知模块去读取新的文件的内容，然后把内容送到module._compile。[1] 如果你看了上面的#6，那么你就会看到module.exports会被返回给用户。这就是为什么你可以通过exports和module.exports创建一个对外的公共接口，而这些就是Module._load做的事情，然后通过require返回出去。我很惊讶于除此之外没有其他的神奇的地方了，但是没有什么比它更加简洁更加好的了。 module._compile123456Module.prototype._compile = function(content, filename) &#123; // 1\\. 创建一个独立的require函数，该函数可以调用module.require。 // 2\\. 给require加上其他帮助性的函数Attach other helper methods to require. // 3\\. 将代码包裹在一个函数中，并提供了require，module等变量在模块作用域中。 // 4\\. 运行这个函数&#125;; 这里就是见证奇迹的地方。第一，一个特殊的单独的require函数被创造用于这个模块。这个require函数就是我们最熟悉的那个函数。这个函数只是把 Module.require包裹了一下，它也包含了一些鲜为人知的帮助性的属性和方法供我们使用： require(): 加载一个外部模块 require.resolve(): 通过解析一个模块绝对路径来生成模块的name require.main: 主要模块 require.cache: 所有模块的缓存 require.extensions: 每一个有效文件的编译函数都是基于这个来做扩展 一旦require完成了，整个加载好的源码会被包裹在一个新的函数里面，同时传入require, module, exports和其对外的变量作为新函数的参数。这样就创造了一个新的函数作用域，这样可以避免污染Node的全局环境。 123(function (exports, require, module, __filename, __dirname) &#123; // 你的代码会被放在这里&#125;); 最后，这个包含了模块的函数会被运行。整个Module._compile方法的执行时同步的，所以Module._load会等待Module._compile执行完，然后会返回module.exports给用户。 结论至此，我们已经看完了require的代码，通过这一圈的代码就创造出了我们一开始想要去了解的那个require 函数。 如果你了解了上面所有的内容，那么你将会了解到require(&#39;module&#39;)最后的秘密。没错，就是模块系统本身也可以通过模块系统加载进来的。一开始，这个可能听上去有些奇怪，但是这样可以让用户不用了解Node.js的核心原理就可以使用加载系统加载自己的模块。流行的模块例如mockery and rewire就是这样构建的。 如果你想了解更多的细节，你可以浏览module.js源码。你会得到更多的信息也会了解的更多，我将会给第一个回答出什么是‘NODE_MODULE_CONTEXTS’并且为什么要加上这个的人加分。 [1] module._compile函数只是用于运行JavaScript文件。JSON文件会简单地通过 JSON.parse()解析然后返回。 [2] 当然这些模块都是由一些私有的函数方法构建的，例如Module._resolveLookupPaths and Module._findPath。你可以想一想是否可以有更好的办法… 请开启你的Javascript然后浏览 comments powered by Disqus.","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"10 个技巧，让你在2017 年成为更好的 Node 开发者","date":"2017-01-27T07:22:17.000Z","path":"2017/01/27/10-tips-to-become-a-better-node-developer/","text":"本文是由我们的客座作者Azat Mardan写的。SitePoint引入客座帖子的目的是希望能给你带来web社区里著名作者和演讲者的有趣内容。 在2012年，我加入了Storify并开始使用Node作为我的主要语言。从那以后，我从未回首过去并觉得我错过了Python，Ruby，Java以及PHP，这些在过去10年里，我在web开发过程中使用的语言。 Storify提供给我一个很有趣的工作，因为Storify和其他的公司不太一样，Storify之前（可能到现在也是）所有的代码都是由JavaScript编写的。而大多数公司，特别是大公司，例如PayPal，Walmart(沃尔玛)或者Capital One(第一资本)，只是在某一些特定的部分使用了Node。通常，他们使用Node作为API接口或者用在业务流程层，这样做是很好的。但是作为一个软件工程师，没什么比得上能够完全沉浸在Node环境里。 下面我将列出10条建议，这些建议可以帮助你在2017年成为一个更好的Node开发者。其中一些建议是我在日常实践中所学到的，另一些是从那些写了最流行的Node和npm模块的人们身上学到的。 下面是我们将要介绍的内容： 避免复杂性 — 尽可能将你的代码块拆到最小，要小到极致。 使用异步编程 — 像躲避瘟疫般避免使用同步代码。 避免require阻塞 — 把你所有的require声明都放在文件的顶部，因为require是同步的，会阻塞代码运行。 了解require缓存 — 了解它则可以利用它，否则它可能会带来bug。 始终检查错误 — 错误不是足球，任何时候都不要抛出错误或者跳过错误检查。 只在同步代码中使用try…catch — 在异步代码中try...catch是没有作用的。V8引擎针对try...catch无法进行优化。 返回callbacks或者使用if … else — 返回一个callback只是为了确保不继续执行。 监听错误事件 — 几乎所有的Node的类/对象都有event emitter(观察者模式)并且会广播error事件，确保你监听了它们。 了解你的npm — 使用-S或者-D来安装模块来代替--save或者–save-dev`。 在package.json中使用精确的版本号: npm在使用-S来安装模块时会自动使用默认的版本号，你需要手动修改去锁定版本号。除非是开源模块，否者不要相信你的项目中的SemVer（语义化版本标准）。 加分 — 使用不同的依赖。把项目在开发阶段需要的东西放在 devDependencies 中，记得使用 npm i –production。多余的依赖越多，出现问题的风险就越大。 好的，接下来让我们一个个单独地去了解上面的每一点。 避免复杂性让我看一眼npm的创造者Isaac Z. Schlueter写的一些模块，例如，use-strict，这个模块是用来在Javascript中强制使用严格模式，这个模块仅仅只有三行代码： 123var module = require(&apos;module&apos;)module.wrapper[0] += &apos;&quot;use strict&quot;;&apos;Object.freeze(module.wrap) 所以我们为什么要避免复杂性呢? 一个起源于美国海军的著名短语:KEEP IT SIMPLE STUPID(或者是“Keep it simple, stupid”)。这就是原因。事实说明，人类大脑在任何一个时间只能在其工作记忆中保持五到七个项目。 把你的代码模块化成一个更加小的部分，你和其他的开发者会更加好的理解它。你也可以更加好的去测试它。如下例子， 1234567app.use(function(req, res, next) &#123; if (req.session.admin === true) return next() else return next(new Error(&apos;Not authorized&apos;))&#125;, function(req, res, next) &#123; req.db = db next()&#125;) 或者是 1234const auth = require(&apos;./middleware/auth.js&apos;)const db = require(&apos;./middleware/db.js&apos;)(db)app.use(auth, db) 我相信大多数人都会喜欢第二个例子，特别是光看名字就能了解其作用。当日，在你编写代码的时候，你可能认为你知道代码是如何运行的。甚至你想要展示你把几个功能连接在一起写在同一行中是多么的机智。但是，这样你是写了一段愚蠢的代码。如果你思考的很复杂去写这代码，那么今后你再去看这段代码将会很难去理解。保证你的代码简单，特别是在Node的异步代码中。 当然也会有left-pad 事件，但是其实它只是影响了依赖于left-pad模块的项目而且11分钟后就发布了替代品。代码的最小化带来的好处超过了它的缺点。npm已经改变了发布策略,任何重要的项目都应该使用缓存或私有的源（作为临时解决方案）。 使用异步编程在Node中同步代码只要很小的一部分。这些代码大多数都是用于命令行工具或者其他与web应用无关的脚本。Node开发者大多数都是编写web应用，因此使用异步代码可以避免阻塞现场。 例如，当你在编写一个数据库的脚本或者是一个不需要控制并行的任务时，下面这种写法可能是可以的： 1234let data = fs.readFileSync(&apos;./acconts.json&apos;)db.collection(&apos;accounts&apos;).insert(data, (results))=&gt;&#123; fs.writeFileSync(&apos;./accountIDs.json&apos;, results, ()=&gt;&#123;process.exit(1)&#125;)&#125;) 但是当你创建一个web应用时，下面这个写法会更好： 1234567app.use(&apos;/seed/:name&apos;, (req, res) =&gt; &#123; let data = fs.readFile(`./$&#123;req.params.name&#125;.json`, ()=&gt;&#123; db.collection(req.params.name).insert(data, (results))=&gt;&#123; fs.writeFile(`./$&#123;req.params.name&#125;IDs.json`, results, ()=&#123;res.status(201).send()&#125;) &#125;) &#125;)&#125;) 这个区别在于你是否需要编写一个并发（通常是长期运行）或者非并发（短期运行）的系统。根据经验来说，总是要在Node中使用异步代码。 避免require阻塞Node有一个使用了CommonJS模块格式的简单的模块加载系统。它是基于require函数，require函数可以很方便的在不同的文件中引入模块。和AMD/requirejs不同，Node/CommonJS的模块加载时同步的。require的工作方式是：引入一个模块或者一个文件export的内容: 1`const react = require(&apos;react&apos;)` 但是大多数的开发者并不知道require是会被缓存的。因此，只要解析的文件名（resolved filename）没有剧烈的变化（比如npm模块不存在的情况），模块的代码只会被执行并存入变量中一次（在当前进程中）。这是一个很好的优化。当然，即使有了缓存，你最好还是把你的require声明写在开头。下面这段代码，它在路由中真正使用到了axios模块的时候才加载。当请求发送的时候/connect会因为需要加载模块所以会变得慢。 12345app.post(&apos;/connect&apos;, (req, res) =&gt; &#123; const axios = require(&apos;axios&apos;) axios.post(&apos;/api/authorize&apos;, req.body.auth) .then((response)=&gt;res.send(response))&#125;) 一个更好，性能更优的方式是在服务定义之前就引入模块而不是在路由中: 1234567const axios = require(&apos;axios&apos;)const express = require(&apos;express&apos;)app = express()app.post(&apos;/connect&apos;, (req, res) =&gt; &#123; axios.post(&apos;/api/authorize&apos;, req.body.auth) .then((response)=&gt;res.send(response))&#125;) 知道require会被缓存我在上面一节已经提到了require会被缓存，但是有趣的是我们在module.exports之外也会有代码。举例来说： 12345console.log(&apos;I will not be cached and only run once, the first time&apos;)module.exports = () =&gt; &#123; console.log(&apos;I will be cached and will run every time this module is invoked&apos;)&#125; 从中我们了解到有一些代码只会运行一次，你可以使用这个特性来优化你的代码。 始终检查错误Node不是Java。在Java中，你可以抛出错误，因为如果发生了错误那么你会希望应用不在继续执行。在Java中，你可以在外层仅仅使用一个简单的try...catch就可以处理多个错误。 但是在Node中并不是这样的。自从Node使用了事件循环和异步执行后，任何的错误发生时都会与错误处理器（例如try...catch）的上下文分离，下面这样做在Node中是没有用的： 12345678try &#123; request.get(&apos;/accounts&apos;, (error, response)=&gt;&#123; data = JSON.parse(response) &#125;)&#125; catch(error) &#123; // Will NOT be called console.error(error)&#125; 但是try...catch在同步代码中是可以被用的。前面的代码片段可以被更好的重构为： 12345678request.get(&apos;/accounts&apos;, (error, response)=&gt;&#123; try &#123; data = JSON.parse(response) &#125; catch(error) &#123; // Will be called console.error(error) &#125;&#125;) 如果我们无法将request的返回内容包裹在try...catch中，那么我们将没有办法去处理请求的错误。Node的开发者通过在返回的参数里面加上error来解决了这个问题。因此，我们需要在每一个回调中手动去处理错误。你可以去检查这些错误（判断error不是null）,然后展示错误信息给用户或者展示在客户端上并且记录它， 或者你可以通过调用 callback ，给它传 error 参数，将错误传回给上一级调用栈（如果你在调用栈之上有另一个回调函数）。 12345678request.get(&apos;/accounts&apos;, (error, response)=&gt;&#123; if (error) return console.error(error) try &#123; data = JSON.parse(response) &#125; catch(error) &#123; console.error(error) &#125;&#125;) 一个小技巧是你可以使用okay库。你可以像下面的例子一样使用它去避免在回调地狱中手动去检查错误(你好, 回调地狱). 123456789var ok = require(&apos;okay&apos;)request.get(&apos;/accounts&apos;, ok(console.error, (response)=&gt;&#123; try &#123; data = JSON.parse(response) &#125; catch(error) &#123; console.error(error) &#125;&#125;)) 返回回调或者使用if … elseNode是并行的。但是如果你不够细心也会因为这个特性产生bug。 为了安全起见，应该要使用return来终止代码的继续执行： 123let error = trueif (error) return callback(error)console.log(&apos;I will never run - good.&apos;) 这样可以避免一些因为代码逻辑的处理不当导致一些不应该执行的内容（或者错误）被执行。 123let error = trueif (error) callback(error)console.log(&apos;I will run. Not good!&apos;) 请确保使用return去阻止代码的继续执行。 监听 error 事件Node中几乎所有的类/对象都有事件分发器（观察者模式）并且会广播 error 事件。 这是一个很好的特性，可以使开发者在这些讨厌的错误造成巨大后果之前捕捉到它们。 养成一个通过.on()来创建error事件监听的好习惯： 123456789101112var req = http.request(options, (res) =&gt; &#123; if ((&apos;&apos; + res.statusCode).match(/^2\\d\\d$/)) &#123; // Success, process response &#125; else if ((&apos;&apos; + res.statusCode).match(/^5\\d\\d$/)) // Server error, not the same as req error. Req was ok. &#125;&#125;)req.on(&apos;error&apos;, (error) =&gt; &#123; // Can&apos;t even make a request: general error, e.g. ECONNRESET, ECONNREFUSED, HPE_INVALID_VERSION console.log(error)&#125;) 了解你的npm很多的Node和前端的开发者知道在安装模块的时候使用--save会在安装模块的同时，会在package.json保存一条含有模块版本信息的条目。当然，还有--save-dev可以用于安装devDependencies(在生成环境中不需要的模块)。但是你知道用-S和-D是否可以代替--save 和--save-dev么？答案是可以的。 当你安装模块的时候，你需要删除-S和-D自动为你模块的版本号添加的^标签。否者当你使用npm install（或者npm i）安装模块的时候，就会自动拉取最新的镜像（版本号的第二位数字）。例如v6.1.0就是v6.2.0的一个镜像分支。 npm团队推荐使用semver，但是你最好不要这样。npm团队认为开源开发者会遵守semver所以他们在npm安装时自动加上了^。没有人可以去保证，所以最好是锁定你的版本号。更好的办法是使用shrinkwrap：npm shrinkwrap会生成一个包含依赖的具体版本的文件。 结束语这篇文章是两部分的第一部分，我们已经提到了很多方面，从使用callbacks和异步代码，到核查错误和锁定依赖。希望你们可以从中学习到一些新的，或者有用的信息。敬请期待即将推出的第二部分。 同时，告诉我你的想法。我是否遗漏了什么？你是否有不一样的做法？在下面的评论区告诉我你的想法吧。","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"new到底做了什么","date":"2017-01-27T07:20:49.000Z","path":"2017/01/27/new-working/","text":"在Javscript中，我们实例化一个类的时候都会使用类似的代码 1var coder = new Man() 那么在new的时候，new到底做了什么呢，其实很简单，new的作用，就是先创建一个空对象，然后将新对象的proto链接到类的prototype，最后通过将新对象作为上下文（this），调用call来执行类的构造函数。实现代码如下 123var coder = &#123;&#125;;coder.__proto__ = Man.prototypeMan.call(coder) 具体可以查看MDN的文档new运算符","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"开发推荐 mac中好用的软件","date":"2017-01-27T07:19:30.000Z","path":"2017/01/27/mac-software/","text":"这里只是我个人用到的一些比较好用的软件，本人是前端开发，所以偏前端的软件可能多一些，不喜勿喷哦，也希望大家可以推荐好的软件给我。 sublime不知道该从哪个软件开始写起，后来一想还是从自己最常用的软件开始吧 sublime作为一个轻量级的ide，性能很优秀，基本什么配置的电脑都可以流畅使用，随着sublime2到sublime3，不管你需要什么样的插件都可以找的到。 Parallers Desktop 个人认为mac上最好的虚拟机，没有之一。第一次使用Parallers的融合模式，确实是惊艳到我了，虚拟机居然可以这种地步，一直以为虚拟机就是在一个窗口中，然后在这个窗口内使用。Parallers可以使你使用其他平台的软件像是在使用mac上软件，唯一的问题就是window上的广告和通知也显示在mac上了，感觉怪怪的,另外Parallers现在好像都要收费了，而且还挺贵的，不过确实物超所值。 Dash开发往往会遇到很多的类库，用到的时候总会需要查询一些文档，一个个去找太麻烦了，dash可以把文档下载下来，而且可以很方便的查询文档，而且dash可以和大多数ide对接，只需要选中你想要查询的函数，加上快捷键就可以直接在dash中查询到对应函数的说明，可以提交开发的效率。另外网路不好的情况下，离线的文档有时候可以帮你解决很多问题。 *","tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/软件/"}]},{"title":"class in ES6","date":"2017-01-27T07:18:42.000Z","path":"2017/01/27/class-in-ES6/","text":"在es6出来之后，我们看到js终于有class这个关键字，表示我们终于可以使用官方的类了。那么es6的类和之前的我们使用原型链继承实现的类有什么联系么。 答案是一模一样 JavaScript classes introduced in ECMAScript 2015 are syntactical sugar over JavaScript’s existing prototype-based inheritance. (在 ECMAScript 6 引入的 JavaScript 类（class）是 JavaScript 现有的原型继承的语法糖。) —— MDN Classes 好吧，那么为了使我们更好的理解es6的class，也是倒过来更好的理解js的原型链，下面我们把类的es6写法和原型链实现的写法一一列出 ###类的创建，类的构造器和原型方法ES61234567891011121314class Polygon &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125; calcArea() &#123; return this.height * this.width; &#125;&#125;const square = new Polygon(10, 10);// 100console.log(square.area); 原型链12345678var Polygon = function(height, width)&#123; this.height = height; this.width = width;&#125;Polygon.prototype.calcArea = function() &#123; return this.height * this.width;&#125; ###类的静态方法static关键字用来定义类的静态方法。静态方法是指那些不需要对类进行实例化)，使用类名就可以直接访问的方法，需要注意的是静态方法不能被实例化的对象调用。静态方法经常用来作为工具函数。ES6123456789101112131415161718class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; static distance(a, b) &#123; const dx = a.x - b.x; const dy = a.y - b.y; return Math.sqrt(dx*dx + dy*dy); &#125;&#125;const p1 = new Point(5, 5);const p2 = new Point(10, 10);console.log(Point.distance(p1, p2)); 原型链1234567891011var Point = function(x, y)&#123; this.x = x; this.y = y;&#125;Point.distance = function(a, b) &#123; const dx = a.x - b.x; const dy = a.y - b.y; return Math.sqrt(dx*dx + dy*dy);&#125; 至此我们也可以明白了如何用原型链去构建一个类 其实当我们去查看babel对于类的实现，其实也是一样的 123456789101112131415161718var _createClass = function() &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function(Constructor, protoProps, staticProps) &#123; //实例方法（原型方法）的实现 if (protoProps) defineProperties(Constructor.prototype, protoProps); //静态函数的实现 if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;(); ###类的继承 未完 参考文档Javascript原型链MDN Classes","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"semver","date":"2017-01-27T07:17:50.000Z","path":"2017/01/27/semver/","text":"semver规则","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"node-js-best-practices-how-to-become-a-better-developer-in-2017","date":"2017-01-27T07:16:45.000Z","path":"2017/01/27/node-js-best-practices-how-to-become-a-better-developer-in-2017/","text":"一年前，我们写了一篇文章How to Become a Better Node.js Developer in 2016 ，这篇文章成功地获取了不错的反响，所以我想现在是时候回顾这个主题为2017年做准备了。 ###2017年最好的Node.js实践 使用ES2015去年我们建议了你使用ES2015，当前现在的情况已经大有不同了 回到那个时候，Node.js v4是当时的稳定版本(LTS)，支持了ES2015中57%的功能。一年过去了，现在Node v6已经增长到支持ES2015中99%的功能了。 如果你现在在使用最新的LTS Node.js版本，你甚至可以不再需要babel就可以使用所有ES2015的特性。但是即使如此，在浏览器端你可能还是需要babel。 如果你需要关于Node.js版本对于ES2015支持情况的更多的信息，我推荐你可以查询node.green ####使用Promises 在80年代第一次提出Promises的概念。现在多数现代编程语言已经支持这一特性了，使我们的编码变得更加简单。 想象一个如下的功能，它需要读取一个文件，然后解析它，然后打印出其中的name字段。如果使用回调，它可能是下面这个样子的： 123456789101112fs.readFile(&apos;./package.json&apos;, &apos;utf-8&apos;, function (err, data) &#123; if (err) &#123; return console.log(err) &#125; try &#123; JSON.parse(data) &#125; catch (ex) &#123; return console.log(ex) &#125; console.log(data.name)&#125;) Promises可以使得这段代码变的更加有可读性：123456fs.readFileAsync(&apos;./package.json&apos;).then(JSON.parse).then((data) =&gt; &#123; console.log(data.name)&#125;).catch((e) =&gt; &#123; console.error(&apos;error reading/parsing file&apos;, e)&#125;) 当前，现在的fs的并没有一个返回一个Promise的readFileAsyncapi。为了做到这个，我们使用可以一个类似promisifyAll的模块。 ####使用标准的JavaScript格式 当我们谈到代码风格的时候，一个公司有统一的代码风格是至关重要的。只有这样，当你需要改变你的项目的时候，你才可以高效的从零开始，而不用担心基础的架构不一样。 在RisingStack，我们在所有的项目中都使用了JavaScript Standard Style。 使用 Standard后，在你安装之后就可以直接使用，你不需要再做其他的事情，也不需要管理.eslintrc, .jshintrc, 或者 .jscsrc文件。具体的Standard的规则可以查看Standard rules。 ###使用docker—容器将在2017年被大量使用在生成环境 你可以把docker镜像当做部署的工具。docker容器可以将一个软件打包在一个完整的文件系统中，这个容器可以包含你在服务器上需要的一切，例如代码，运行环境，系统工具，系统程序库。 但是为什么我们需要开始使用容器呢? 容器可以使你的应用运行在一个隔离的环境中 作为一个安全工具，可以使你的代码更加的安全 轻量级的docker镜像 使得你的部署变得稳定 你可以在本地运行模拟线上的运行环境 你可以从official getting started tutorial开始学习docker。另外也推荐Kubernetes best practices ####监控你的项目 当你的应用发生错误的时候，第一个知道的人不应该是用户而应该是开发者。 最新的一个开源解决方案Prometheus可以帮助你实现项目的监控。Prometheus是一个基于SoundCloud的开源工具箱，它可以监控你的项目并报警。Prometheus唯一的缺点是你需要设置一些配置并且需要需要自己管理。 如果你在寻找一个开箱即用的解决方案，你也可以使用我们自己开发的Trace by RisingStack Trace可以帮助你做到以下的事情 报警 生产环境下的内存和cpu分析 分布式追踪和错误寻找 性能监控 保护你的npm包的安全 ####在后台进程中使用消息服务 如果你使用http请求发送消息，当你的接收服务器宕机了，你所有的消息都会丢失。如果你的传输层支持持久化，类似使用消息队列来发送消息，你就不会有这个问题。 你的接收服务器器宕机了，消息将会被保存下来，在服务重启后会继续发送，如果你的服务器未宕机但是发送了错误，消息会被重新发送一次，这样可以保证你的数据不会丢失。 举个例子：你需要发送数千份邮件，在这个场景下，你只需要获取到一些类似邮件地址和用户的姓名等基础信息，后台就可以很轻松地将这些信息和邮件信息整合后发送出去。 这种方式最大的好处是，你可以你需要的时候横向扩展你的服务，而不会有邮件被丢失。如果你需要发送数百万的邮件，你可以用相同的方式来增加你的服务。 对于消息队列的选择有很多 RabbitMQ Kafka NSQ AWS SQS ####使用最新的LTS版本的Node.js 为了平衡稳定性和新特性，我推荐你使用最新的LTS版本的Node.js。当我写这篇文章的时候，最新的LTS版本是6.9.2。 你可以使用nvm来切换你的node版本，你只需要两个指令就可管理和切换你的node版本 12nvm install 6.9.2 nvm use 6.9.2 ####使用语义化的版本管理 几个月前，我们进行了一个Node.js开发者调查，我们从中获取了开发者对于使用语义化版本的使用情况。 不幸的是，我们发现调查者只有71%的人在他们提交和使用模块时使用语义化的版本管理。我们认为这个数字应该要更高 - 每一个都应该使用语义版本!，因为不根据semver规则来提交package，会很容易摧毁你的Node.js应用。 通过版本号来管你的项目或者模块是至关重要的。你的用户应该要知道一个模块是否更新了，在使用新版本前他们要做什么。 这就是语义版本控制的来历。一个版本号应该要有主版本号、副版本号、补丁版本号，更新不同位置的版本号代表不同的意思： 主版本号:表示更新会有不兼容的API 副版本号:表示更新会有新的功能（不破坏现有的api） 补丁版本号:表示更新是模块做了向后兼容的bug修复 npm是根据semver规则来安装依赖的，因此当你发布一个模块之前，请确认是否遵循了semver规则，否则你会破坏了其他使用了你的依赖的应用。 ####保证你的应用安全 保证你的用户数据的安全将是你2017年的头等大事。仅在2016年一年，因为缺少一些安全的措施就有数百万的用户账户被泄漏。 你可以通过阅读我们的博客Node.js Security Checklist来入门Node.js的安全，博客里包含了以下的话题： 安全的HTTP Headers 强制保护 Session管理 不安全的依赖 数据验证 当你掌握了这些基础，你可以来观看我关于Node的互动讨论Surviving Web Security with Node.js 学习ServerlessServerless started with the introduction of AWS Lambda. Since then it is growing fast, with a blooming open-source community.In the next years, serverless will become a major factor for building new applications. If you’d like to stay on the edge, you should start learning it today.One of the most popular solutions is the , which helps in deploying AWS Lambda functions. Serverless是AWS Lambda第一个提出来的，之后它发展的很快，并建立了一个开源的社区。 接下来的一年，构建新应用时serverless会成为一个标准。如果你想要留在这个领域，你需要重现在开始就学习它。 Serverless Framework是当前最流行的解决方案，在部署AWS Lambda functions可以帮助你。 ####参加会议与聚会并发言 参加会议和聚会是一个很好地方式去了解和学习新的趋势，开发技巧和最佳实践。当日，这也是一个场合去认识更多新的人。 To take it one step forward, I’d like to encourage you to speak at one of these events as well!As public speaking is tough, and “imagine everyone’s naked” is the worst advice, I’d recommend checking out speaking.io for tips on public speaking! 在此基础上，我也鼓励你在一些会议上发言。 在公共场合发言是一个不容易的事情，“imagine everyone’s naked”是最坏的建议。我建议你可以去speaking.io学习一些技巧。 ####Become a better Node.js developer in 2017 原文链接","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Closures","date":"2017-01-27T07:16:02.000Z","path":"2017/01/27/Closures/","text":"Closures are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions ‘remember’ the environment in which they were created. — MDN 看不懂上面的英文这么办，下面是中文翻译 闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。 关于闭包已经有很多很多的文章了，文章的最后会放一些链接，在这里我只写以下几点 闭包的实现是因为Js中有函数作用域，变量查询是一级一级查询上去，直到根作用域也就是说在任何一级的作用域中都可以访问之前所有作用域连的变量，同时内存回收机制是不会回收还被引用的变量。 闭包不是实现Js类的基础，但是可以通过闭包实现类的私有变量和私有函数 闭包的性能很差，有时候可以绑定在prototype中（只可以访问this下的变量） 123456789101112131415161718//在这个例子中firstName和LastName不想直接被外界访问，同时可以使用闭包使外界获取到值，//同时函数尽量绑定在prototype上，所以getFullName绑定在prototype上，//所以我个人认为在这样的情况下，一些用于访问私有变量的基础函数可以使用闭包，//大多数类函数可以绑定在prototype中，通过可以访问私有变量的基础函数来实现访问私有变量var Man = function()&#123; var firstName = &apos;wang&apos;; var LastName = &apos;yuekai&apos;; this.getFirstName = function()&#123; return firstName; &#125; this.getLastName = function()&#123; return LastName; &#125;&#125;Man.prototype.getFullName = function()&#123; return this.getFirstName() + this.getLastName()&#125; 其他文献学习Javascript闭包（Closure）闭包","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Javascript原型链","date":"2017-01-27T07:15:21.000Z","path":"2017/01/27/prototype-chain/","text":"原型链的继承就是将子类的prototype.__proto__链接到父类的prototype，借此完成原型链1child.prototype.__proto__.= parent.prototype 实例化的对象没有prototype,prototype是函数特有的属性，所有的对象都有__proto__, 这是指向实例化这个对象的类的prototype,所有对象的原型链最后是null 下面是经典的原型链继承的例子，我借此解释一下12345678910111213141516171819 function extend(Child, Parent) &#123; var F = function()&#123;&#125;; //将父类的prototype复制到F函数中 F.prototype = Parent.prototype; /*new F()实例化F()实际的作用是生成了一个下面这个对象 &#123; __proto__: &#123; //Parent.prototype &#125; &#125; 这样就完成了 Child.prototype.__proto__ = Parent.prototype这个原型链继承的核心内容 */ Child.prototype = new F(); //Parent.prototype的constructor是Parent，为了准确这里要手动将Child.prototype.constructor改为Child Child.prototype.constructor = Child; //这里是为了代码实际开发时方便调用父类，不用使用__proto__ Child.uber = Parent.prototype; &#125; 涉及到继承这一块，Javascript 只有一种结构，那就是：对象。在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。—MDN原型链描述 上面这句话有些长，看代码获取会直观一点 12345childClass.prototype.__proto__ == parantClass.prototypechildInstance.__proto__ == childClass.prototypechildInstance.__proto__.__proto__ == childClass.prototype.prototype == parantClass.prototype 对于这里的childInstance.__proto__ == childClass.prototype，是由关键字new实现的，具体可以看我的另外一篇文章new到底做了什么 参考文献Javascript继承机制的设计思想Javascript面向对象编程（二）：构造函数的继承继承与原型链","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Javascript 代码优化","date":"2017-01-27T07:13:35.000Z","path":"2017/01/27/optimizing-javascript/","text":"客户端的脚本可以使你的应用变得动态和生动，但是浏览器对于JavaScript的解释可能会导致效率的底下，而且随着客户端本身的不同也会导致性能的不同。我们整理了一些建议和最好的实践来优化你的Javascript 代码。 ###定义class的方法 下面这个例子是低效的，每一次实例化baz.Bar，都会创建一个新foo的闭包函数。 123456baz.Bar = function() &#123; // constructor body this.foo = function() &#123; // method body &#125;;&#125; 比较好的方法是 1234567baz.Bar = function() &#123; // constructor body&#125;;baz.Bar.prototype.foo = function() &#123; // method body&#125;; 这种方式，无论创建多少个baz.Bar的示例，都只会创建一个foo函数，同时也没有闭包函数产生。 ###初始化实例变量Place instance variable declaration/initialization on the prototype for instance variables with value type (rather than reference type) initialization values (i.e. values of type number, Boolean, null, undefined, or string).这个可以避免每次构建函数被调用时不必要地每次都运行初始化代码（但是如果你的实例变量是依赖于构建函数的传入参数，或者依赖于构建时的一些状态则不适用于该建议） 例子 123456foo.Bar = function() &#123; this.prop1_ = 4; this.prop2_ = true; this.prop3_ = []; this.prop4_ = &apos;blah&apos;;&#125;; 应该改为下面这种形式 123456789foo.Bar = function() &#123; this.prop3_ = [];&#125;;foo.Bar.prototype.prop1_ = 4;foo.Bar.prototype.prop2_ = true;foo.Bar.prototype.prop4_ = &apos;blah&apos;; ###避免落入闭包的陷进 闭包是Javascript中一个很强大也很有用的一个特性；同时，它也有一些缺点： 闭包是最常见的导致内存泄漏的原因 创建一个闭包比起不使用闭包来创建一个内在的函数来说慢得多，和重用一个静态的函数来比要更加慢。如下例子 1234function setupAlertTimeout() &#123; var msg = &apos;Message to alert&apos;; window.setTimeout(function() &#123; alert(msg); &#125;, 100);&#125; 较快的：123456function setupAlertTimeout() &#123; window.setTimeout(function() &#123; var msg = &apos;Message to alert&apos;; alert(msg); &#125;, 100);&#125; 更快的12345678function alertMsg() &#123; var msg = &apos;Message to alert&apos;; alert(msg);&#125;function setupAlertTimeout() &#123; window.setTimeout(alertMsg, 100);&#125; 闭包会增加作用域的长度。当浏览器解析属性的时候，作用域的每一级都必须被查询。如下例子 1234567891011121314var a = &apos;a&apos;;function createFunctionWithClosure() &#123; var b = &apos;b&apos;; return function () &#123; var c = &apos;c&apos;; a; b; c; &#125;;&#125;var f = createFunctionWithClosure();f(); 当f被执行，引用c快于b,快于a。在ie中使用闭包的信息可以浏览IE+JScript Performance Recommendations Part 3: JavaScript Code inefficiencies ###避免使用with在你的代码中要避免视同with。它的性能很差，因为它会修改作用域链，使得其他的作用域连中查找变量变得困难。网站应用中最常见的内存泄漏是因为JavaScript脚本引擎和浏览器的C ++对象实现DOM一件的循环引用（例如：between the JavaScript script engine and Internet Explorer’s COM infrastructure, or between the JavaScript engine and Firefox XPCOM infrastructure） ###避免浏览器内存泄漏 在web应用中内存泄漏是一个很常见的问题，它会导致巨大的性能问题。当你的网站应用导致浏览器使用的的内存增加，会影响到用户的系统的其他部分变得缓慢。 这里有一些经验的法则来避免内存泄漏： 把事件处理绑定在事件管理系统上 最常见的循环引用类型就是 [ DOM element –&gt; event handler –&gt; closure scope –&gt; DOM ]，为了避免这种问题，应该选择一个经过良好测试的事件管理系统来绑定事件处理，例如Google doctype，Dojo或者Jquery。 未完 原文链接“","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"About this and prototype","date":"2017-01-27T07:12:03.000Z","path":"2017/01/27/About-this-and-prototype/","text":"对于js中this创建的对象，相当于改变了自身的字面量，而本身有一个自带的属性为prototype，这个不属于字面量的内容123456789101112131415function Person () &#123; this.name = &quot;wang&quot;; this.age = 15;&#125;Person.prototype.name = &apos;lala&apos;;var john = new Person();console.log(JSON.stringify(john));//&#123;name:&quot;wang&quot;, age:15&#125;//这里说明了this等同于的是对象字面量console.log(john.name) //“wang”，这里说明了，js会优先寻找字面量里面是否有这个对象，其次才会去prototype里面寻找 对象的样子如下12345678&#123; name:&apos;wang&apos;, age: 15, prototype:&#123; constructor:[Function], name: &apos;lala&apos; &#125;&#125;","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"require()","date":"2017-01-26T07:05:17.000Z","path":"2017/01/26/require/","text":"1module = new Module() //module 为 Module类的实例 12345678var Module = function(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; this.filename = null; this.loaded = false; this.children = [];&#125; 123var require = function()&#123; return module.exports&#125; 模块的加载实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出。—— require() 源码解读 所以说每一个require的文件执行的过程，都是先读取文件，注入变量，再执行代码，所以node文件不需要自己实例化Module,在require的时候会自动实例化的，所以从另一个角度说，文件并不会直接执行，所以看上去文件中的require，module等变量都为创建而可以执行。1234567891011121314151617//a.jsexports.multiply = function(n) &#123; return n * 1000 &#125;;//index.jsrequire(&apos;./a.js&apos;)//require(&apos;./a.js&apos;)实际的变为了 var module = &#123; exports: &#123;&#125; &#125;;(function(module, exports) &#123; exports.multiply = function(n) &#123; return n * 1000 &#125;; &#125;(module, module.exports)) return module.exports; ####Demo require原理 读取js文件并运行","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"use generator and co in mocha","date":"2017-01-25T07:05:17.000Z","path":"2017/01/25/use-generator-and-co-in-mocha/","text":"主要的点在于当 it() 函数的回调函数带有done参数，mocha会等到回调函数里面出 done 或者或者超时才完成一条测试。同时因为每个测试用例最多执行2000毫秒，所以要面对需要很长时间的测试，需要通过设置 -t 来修改最长时间（暂时没有更好的方法）1234it(&apos;option is empty&apos;, function(done) &#123; ... done()//结束一条测试&#125;); 例子12345678910111213describe(&apos;runBash&apos;, function() &#123; it(&apos;option is Sync&apos;, function(done) &#123; var instructionList = [&apos;echo &quot;one&quot;&apos;, &apos;echo &quot;two&quot;&apos;]; var option = &#123; webRoot: &apos;../fake-natoo&apos; &#125;; co(function*(done) &#123; var errCode = yield runBash(instructionList, option); expect(errCode).to.be.equal(null); done();//完成测试 &#125;.call(this, done));//传入done &#125;);&#125;); ps Mocha默认每个测试用例最多执行2000毫秒(可以通过-t来调整)Mocha默认会高亮显示超过75毫秒的测试用例（可以通过-s来调整）&lt;&lt;测试框架 Mocha 实例教程&gt;&gt;(阮一峰)","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Test","slug":"Test","permalink":"http://yoursite.com/tags/Test/"}]}]